<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#2e2e2e">

<meta name="google-site-verification" content="6W--ve65HbCJhCzMr9T0GWQFxmoIt6TAvxAOK7mbmdw" />
<meta name="baidu-site-verification" content="gOo33cChxc" />








<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png?v=5.1.3">






  <meta name="keywords" content="python,linux," />










<meta name="description" content="这段时间都在写这个监控脚本，之前用shell写过一个，其实也可以用，但考虑到后期需要实现自动化运维，功能需要更加完善，于是就打算写一个python版的监控脚本">
<meta name="keywords" content="python,linux">
<meta property="og:type" content="article">
<meta property="og:title" content="python实现服务器监控脚本">
<meta property="og:url" content="http://www.cgspace.date/2017/10/10/linux/2017-10-10-linux-serverMonitor/index.html">
<meta property="og:site_name" content="cgspace">
<meta property="og:description" content="这段时间都在写这个监控脚本，之前用shell写过一个，其实也可以用，但考虑到后期需要实现自动化运维，功能需要更加完善，于是就打算写一个python版的监控脚本">
<meta property="og:image" content="http://www.cgspace.date/images/linux/python-monitor-2.png">
<meta property="og:updated_time" content="2017-10-12T09:08:46.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="python实现服务器监控脚本">
<meta name="twitter:description" content="这段时间都在写这个监控脚本，之前用shell写过一个，其实也可以用，但考虑到后期需要实现自动化运维，功能需要更加完善，于是就打算写一个python版的监控脚本">
<meta name="twitter:image" content="http://www.cgspace.date/images/linux/python-monitor-2.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":true},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://www.cgspace.date/2017/10/10/linux/2017-10-10-linux-serverMonitor/"/>





  <title>python实现服务器监控脚本 | cgspace</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">cgspace</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">精致地生活</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.cgspace.date/2017/10/10/linux/2017-10-10-linux-serverMonitor/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cg">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cgspace">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">python实现服务器监控脚本</h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
			  
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-10T17:27:02+08:00">
                2017-10-10 17:27:02
              </time>
			  
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index">
                    <span itemprop="name">linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv">阅读
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>次
            </span>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>这段时间都在写这个监控脚本，之前用shell写过一个，其实也可以用，但考虑到后期需要实现自动化运维，功能需要更加完善，于是就打算写一个python版的监控脚本</p>
<a id="more"></a>
<h3 id="脚本概况"><a href="#脚本概况" class="headerlink" title="脚本概况"></a>脚本概况</h3><p>分模块来总结，分为</p>
<ul>
<li>选择操作包</li>
<li>工具包</li>
<li>项目模块包</li>
</ul>
<p>目前完成的这个脚本文件中，其目录结构文件如下</p>
<p><img src="/images/linux/python-monitor-2.png" alt="python-monitor"></p>
<p><code>monitor.py</code> 脚本入口<br><code>monitorbin</code> 存放的operate.py这个文件及选择操作模块<br><code>monitorbin.util</code>存放四个工具模块<br><code>monitorbin.module</code> 存放需要监控的进程模块</p>
<h3 id="monitorbin包"><a href="#monitorbin包" class="headerlink" title="monitorbin包"></a>monitorbin包</h3><h4 id="operate-py"><a href="#operate-py" class="headerlink" title="operate.py"></a>operate.py</h4><p>选择操作模块，被<code>monitor.py</code>调用执行<br>其代码如下</p>
<pre><code>#!/usr/bin/python3
#coding=utf-8

from monitorbin.util.fileUtil import FileUtil
from monitorbin.module.tomcatCheck import TomcatOperate
from monitorbin.module.nginxCheck import NginxOperate
from monitorbin.module.redisCheck import RedisOperate
from monitorbin.util.emailUtil import EmailUtil

#author: cg错过
#time: 2017-09-30

class Operate:

    #选择执行操作类

    def __init__(self):

        self.fileUtil = FileUtil()

        dictNeedRunMsg = self.fileUtil.getNeedRunMsg()
        if(len(dictNeedRunMsg) &gt; 1):
            self.runProcess(dictNeedRunMsg)
            emailUtil = EmailUtil(dictNeedRunMsg, self.fileUtil)
        elif(len(dictNeedRunMsg) == 1):
            self.fileUtil.writerContent(&quot;配置文件参数值不全&quot;, &apos;runErr&apos;)
        else:
            self.fileUtil.writerContent(&quot;配置文件读取失败&quot;, &apos;runErr&apos;)


    def runProcess(self, dictNeedRunMsg):

        #运行检测各个项目

        listKeys = dictNeedRunMsg.keys()
        for keyItem in listKeys:
            if(keyItem.find(&apos;tomcat&apos;) != -1):
                strTomcatPath = dictNeedRunMsg.get(keyItem)
                tomcatOperate = TomcatOperate(strTomcatPath, self.fileUtil.strMinTime, self.fileUtil)
                #print(strTomcatPath)
            if(keyItem.find(&apos;nginx&apos;) != -1):
                strNginxPath = dictNeedRunMsg.get(keyItem)
                nginxOperate = NginxOperate(strNginxPath, self.fileUtil.strMinTime, self.fileUtil)
                #print(strNginxPath)
            if(keyItem.find(&apos;redis&apos;) != -1):
                strRedisPath = dictNeedRunMsg.get(keyItem)
                redisOperate = RedisOperate(strRedisPath, self.fileUtil.strMinTime, self.fileUtil)
                #print(strRedisPath)
</code></pre><p>其中实例化FileUtil这个模块类，调用类中的方法<code>getNeedRunMsg()</code>或许根据配置文件过滤得到需要检测系统所需要的数据，为dict字典类型。得到数据后进行判断，其中，当长度大于1即可认为该<code>dictNeedRunMsg</code>或许到的数据是完全的，当长度等于1时，该dict中存放的值为<code>dictNeedRunMsg={&#39;0&#39;: &#39;error&#39;}</code>,表示数据不全，即配置文件中缺少配置运行所需的数据，使运行中止，另外就是当<code>dictNeedRunMsg</code>长度为0时，即未成功读取到配置文件中的数据，当然这种情况到这一步是不会发送的，因为在此之前在FileUtil这个模块类中已经进行了判断。可以看下面FileUtil这个模块类</p>
<h3 id="monitorbin-util包"><a href="#monitorbin-util包" class="headerlink" title="monitorbin.util包"></a>monitorbin.util包</h3><h4 id="fileUtil-py"><a href="#fileUtil-py" class="headerlink" title="fileUtil.py"></a>fileUtil.py</h4><p>文件及部分数据处理类,在脚本运行中只能存在一个该对象<br>代码如下</p>
<pre><code>#!/usr/bin/python3
#coding=utf-8

import os
import xml.dom.minidom
import configparser
from monitorbin.util.sysTime import RunTime

#author: cg错过
#time: 2017-09-30

class FileUtil:

    #文件及部分数据处理类

    configurePath = &apos;conf&apos;
    configureFileName = &apos;monitor.conf&apos;

    def __init__(self):

        self.strLogPath = self.getLogPath()
        #strLogPath = self.getLogPath()
        self.setAttribute()

    def setAttribute(self):

        #设置一些属性

        runTime = RunTime()
        self.strDateTime = runTime.getDateTime()
        self.strHourTime = runTime.getHourTime()
        self.strMinTime = runTime.getMinTime()
        self.strHourMinTime = runTime.getHourMinTime()
        self.strNumSecondTime = runTime.getNumSecondTime()
        self.strNumHourTime = runTime.getNumHourTime()

        strlogContentSecondName = &quot;monitor_content-&quot; + self.strNumSecondTime + &quot;.txt&quot;
        strlogContentName = &quot;monitor_content-&quot; + self.strNumHourTime + &quot;.txt&quot;
        strlogErrName = &quot;monitor_err-&quot; + self.strNumHourTime + &quot;.txt&quot;
        strlogErrSecondName = &quot;monitor_err-&quot; + self.strNumSecondTime + &quot;.txt&quot;
        strRunErrName = &quot;err-&quot; + self.strNumSecondTime + &quot;.txt&quot;

        self.strlogContentSecondName = self.strLogPath + &apos;/&apos; + strlogContentSecondName
        self.strlogContentName = self.strLogPath + &apos;/&apos; + strlogContentName
        self.strlogErrName = self.strLogPath + &apos;/&apos; + strlogErrName
        self.strlogErrSecondName = self.strLogPath + &apos;/&apos; + strlogErrSecondName
        self.strRunErrPathName = self.strLogPath + &apos;/&apos; + strRunErrName


    def writerContent(self, strContent, strFileMark=&apos;Hour&apos;, whetherAdd=True):

        #strFileMark: 区分写入小时执行的文件还是分钟执行的文件
        #strContent: 写入文件的内容
        #whetherAdd: 是否在文件后面换行追加，默认True

        if(strFileMark == &apos;Hour&apos;):
            if(whetherAdd &amp; True):
                fileObj = open(self.strlogContentName, &apos;a&apos;)
                fileObj.write(strContent + &quot;\n&quot;)
                fileObj.close()
            else:
                fileObj = open(self.strlogContentName, &apos;w&apos;)
                fileObj.write(strContent)
                fileObj.close()
        elif(strFileMark == &apos;Second&apos;):
            if(whetherAdd &amp; True):
                fileObj = open(self.strlogContentSecondName, &apos;a&apos;)
                fileObj.write(strContent + &quot;\n&quot;)
                fileObj.close()
            else:
                fileObj = open(self.strlogContentSecondName, &apos;w&apos;)
                fileObj.write(strContent)
                fileObj.close()
        else:
            if(whetherAdd &amp; True):
                fileObj = open(self.strRunErrPathName, &apos;a&apos;)
                fileObj.write(strContent + &quot;\n&quot;)
                fileObj.close()
            else:
                fileObj = open(self.strRunErrPathName, &apos;w&apos;)
                fileObj.write(strContent)
                fileObj.close()

    def writerErr(self, strContent, strFileMark=&apos;Hour&apos;, whetherAdd=True):

        if(strFileMark == &apos;Hour&apos;):
            if(whetherAdd &amp; True):
                fileObj = open(self.strlogErrName, &apos;a&apos;)
                fileObj.write(&quot;\n&quot; + strContent)
                fileObj.close()
            else:
                fileObj = open(self.strlogErrName, &apos;w&apos;)
                fileObj.write(strContent)
                fileObj.close()
        else:
            if(whetherAdd &amp; True):
                fileObj = open(self.strlogErrSecondName, &apos;a&apos;)
                fileObj.write(&quot;\n&quot; + strContent)
                fileObj.close()
            else:
                fileObj = open(self.strlogErrSecondName, &apos;w&apos;)
                fileObj.write(strContent)
                fileObj.close()



    def getXMLTagElementValue(self, strFilePath, strTagName, strTagElementName, intTagIndex):

        #获取xml文件指定标签的内容，返回一个字符串值
        #self: 对象本身
        #strTagName: 标签名字
        #strTagElementName: 标签中的元素名字
        #intTagIndex: 文件中出现该标签的序列号(即第几个，从0开始)

        confObj = xml.dom.minidom.parse(strFilePath)

        documentElementObj = confObj.documentElement
        listElementItem = documentElementObj.getElementsByTagName(strTagName)
        #按照顺序存放，文件内容中第一个出现该标签名字的就放在集合的下标为0的位置
        tagElement = listElementItem[intTagIndex]
        strTagElementValue = tagElement.getAttribute(strTagElementName)
        print(strTagElementName + &quot;=&quot; + strTagElementValue)
        return strTagElementValue


    def getConfFileValue(self, configParserObj, configureFileNameAndPath):

        #获取conf后缀的配置文件内容，返回一个字典
        #注释了不读取，值为空会读取
        #configParserObj: 读取配置文件的对象
        #configureFileNameAndPath: 配置文件路径
        #读取写入的key名字全部小写

        dictConfMsg = {}
        intMark = self.checkFileExists(configureFileNameAndPath)
        if(intMark == 1):
            configParserObj.read(configureFileNameAndPath)
            try:
                listSectionName = configParserObj.sections()
            except:
                self.writerContent(&quot;读取配置文件出错&quot;, &apos;runErr&apos;)
            else:
                for sectionItem in listSectionName:
                    #print(sectionItem)
                    listKeyName = configParserObj.options(sectionItem)
                    #print(listKeyName)
                    sectionObj = configParserObj[sectionItem]
                    if(len(listKeyName) != 0):
                        for keyItem in  listKeyName:
                            valueItem = sectionObj[keyItem]
                            if(valueItem == None):
                                dictConfMsg[sectionItem] = listKeyName
                            else:
                                dictConfMsg[keyItem] = valueItem
                    else:
                        dictConfMsg[sectionItem] = &apos;&apos;
        #print(dictConfMsg)
        return dictConfMsg


    def readFileContent(self, inputFileName):

        #读取普通文件内容并返回

        fileObj = open(inputFileName, &apos;r&apos;)
        strFileContent = fileObj.read()
        fileObj.close()

        return strFileContent


    def initConfigureFile(self):

        #初始化配置文件

        strTomcatPath = &quot;/home/liying/dev/tomcat-7.0.73&quot;
        strNginxPath = &quot;/usr/local/nginx&quot;
        strRedisPath = &quot;/home/liying/dev/redis-2.8.24&quot;

        strServerName = &quot;116&quot;
        strUserName = &quot;林繁&quot;

        strLogPath = &quot;logs&quot;

        strSmtp_server = &quot;smtp.qq.com&quot;
        strEmail_sendAddr = &quot;yakult-cg@qq.com&quot;
        strEmail_sendPasswd = &quot;lscgsbnjddtgdegc&quot;

        strToEmail = &quot;1542723438@qq.com&quot;
        strToEmail2 = &quot;1732821152@qq.com&quot;

        strAuthor = &quot;cg错过&quot;
        strCreateTime = &quot;2017-09-30&quot;

        if not os.path.exists(self.configurePath):
            os.mkdir(self.configurePath)

        configureFileNameAndPath = self.configurePath + &apos;/&apos; + self.configureFileName

        config = configparser.ConfigParser(allow_no_value=True, delimiters=&apos;:&apos;)
        config.add_section(&apos;ProjectConfigure&apos;)
        config.add_section(&apos;UseConfigure&apos;)
        config.add_section(&apos;LogConfigure&apos;)
        config.add_section(&apos;EmailConfigure&apos;)
        config.add_section(&apos;ToEmail&apos;)
        config.add_section(&quot;Message&quot;)

        config.set(&apos;ProjectConfigure&apos;, &apos;tomcatpath&apos;, strTomcatPath)
        config.set(&apos;ProjectConfigure&apos;, &apos;nginxpath&apos;, strNginxPath)
        config.set(&apos;ProjectConfigure&apos;, &apos;redispath&apos;, strRedisPath)

        config.set(&apos;UseConfigure&apos;, &apos;servername&apos;, strServerName)
        config.set(&apos;UseConfigure&apos;, &apos;username&apos;, strUserName)

        config.set(&apos;LogConfigure&apos;, &apos;logpath&apos;, strLogPath)

        config.set(&apos;EmailConfigure&apos;, &apos;smtp_server&apos;, strSmtp_server)
        config.set(&apos;EmailConfigure&apos;, &apos;email_sendAddr&apos;, strEmail_sendAddr)
        config.set(&apos;EmailConfigure&apos;, &apos;email_sendPasswd&apos;, strEmail_sendPasswd)

        config.set(&apos;ToEmail&apos;, strToEmail)
        config.set(&apos;ToEmail&apos;, strToEmail2)

        config.set(&apos;Message&apos;, &apos;author&apos;, strAuthor)
        config.set(&apos;Message&apos;, &apos;createtime&apos;, strCreateTime)

        with open(configureFileNameAndPath, &apos;w&apos;) as configureFile:
            config.write(configureFile, space_around_delimiters=True)

        #print(&quot;done&quot;)


    def getNeedRunMsg(self):

        #根据配置文件的配置内容来选择代码执行
        #即从存放的字典中去除不需要检测运行的项目(未配置值的参数)，之后返回
        print(&quot;获取运行需要的配置数据&quot;)

        #fileUtil = FileUtil()
        dictNewConfMsg = {}
        dictConfMsg = self.readConfigureFile()
        intMark = self.checkConfMsg(dictConfMsg)
        if(intMark == 1):
            intTomcatMark = self.checkRunProject(&quot;tomcat&quot;, &quot;tomcatpath&quot;, dictConfMsg)
            if(intTomcatMark == 0):
                del dictConfMsg[&apos;tomcatpath&apos;]

            intNginxMark = self.checkRunProject(&quot;nginx&quot;, &quot;nginxpath&quot;, dictConfMsg)
            if((intNginxMark == 0)):
                del dictConfMsg[&apos;nginxpath&apos;]

            intRedisMark = self.checkRunProject(&quot;redis&quot;, &quot;redispath&quot;, dictConfMsg)
            if(intRedisMark == 0):
                del dictConfMsg[&apos;redispath&apos;]
            dictNewConfMsg = dictConfMsg
        elif(intMark == 0):
            dictNewConfMsg[&apos;0&apos;] = &apos;error&apos;


        print(&quot;需要运行的有&quot;)
        print(dictNewConfMsg)
        return dictNewConfMsg


    def readConfigureFile(self):

        #读取脚本配置文件
        dictConfMsgTotal = {}
        configureFileNameAndPath = self.configurePath + &apos;/&apos; + self.configureFileName
        self.checkAndInitConfigure(configureFileNameAndPath)
        config = configparser.ConfigParser(allow_no_value=True, delimiters=&apos;:&apos;)
        dictConfMsg = self.getConfFileValue(config, configureFileNameAndPath)
        dictConfMsgTotal.update(dictConfMsg)
        if(len(dictConfMsgTotal)  == 0):
            self.writerContent(&quot;未获取到配置文件内容&quot;, &apos;runErr&apos;)

        return dictConfMsgTotal

    def checkConfMsg(self, dictConfMsg):

        #检测配置文件是否完全
        #其中日志路径和email值必须存在
        #所以这里只检查logpath和email
        #email仅包括smtp_server, email_sendaddr, email_sendpasswd

        intMark = -1
        if(len(dictConfMsg) != 0):
            for keyItem in dictConfMsg:
                if((keyItem == &apos;logpath&apos;) | (keyItem == &apos;smtp_server&apos;) | (keyItem == &apos;email_sendaddr&apos;)
                  | (keyItem == &apos;email_sendpasswd&apos;)):
                    if(dictConfMsg.get(keyItem) == &apos;&apos;):
                        strErr = (&quot;未读取到%s配置参数的值，请修改配置文件&quot; %(keyItem))
                        self.writerContent(strErr, &apos;runErr&apos;)
                        intMark = 0
                        break
                    else:
                        intMark = 1
        else:
            self.writerContent(&quot;未读取到配置文件内容&quot;, &apos;runErr&apos;)
        return intMark



    def checkRunProject(self, projectName, strKey, dictConfMsg):

        #根据配置文件的配置，判断并选择代码块来执行
        #如果返回值为1，则表示返回允许执行检测projectName这个项目

        intMark = -1
        if(strKey in dictConfMsg):
            if(dictConfMsg.get(strKey) != &apos;&apos;):
                intMark = 1
            else:
                intMark = 0
                strErr = (&quot;未读取到%s配置参数,如需检测%s请修改配置文件&quot; %(projectName, projectName))
                self.writerContent(strErr, &apos;runErr&apos;)
        return intMark


    def checkFileExists(self, configureFileNameAndPath):

        #检测配置文件是否存在，不存在则返回-1

        intMark = -1
        if(os.path.exists(configureFileNameAndPath)):
            intMark = 1

        return intMark

    def checkAndInitConfigure(self, configureFileNameAndPath):

        #检测并初始化配置文件

        intMark = self.checkFileExists(configureFileNameAndPath)
        if(intMark != 1):
            print(&quot;配置文件monitor.conf不存在,脚本自动创建并初始化&quot;)
            print(&quot;配置文件monitor.conf路径为&quot; + self.configurePath + &quot;/&quot; + self.configureFileName)
            #self.writerContent(&quot;配置文件monitor.conf不存在,脚本自动创建并初始化&quot;, &apos;runErr&apos;)
            #strErr = (&quot;配置文件monitor.conf路径为&quot; + self.configurePath + &quot;/&quot; + self.configureFileName)
            #self.writerContent(strErr, &apos;runErr&apos;)
            self.initConfigureFile()

    def checkAndCreate(self, FileNameAndPath):

        #检测并创建日志文件路径

        intMark = self.checkFileExists(FileNameAndPath)
        if(intMark != 1):
            print(&quot;配置的日志文件夹路径不存在，脚本执行自动创建&quot;)
            #self.writerContent(&quot;配置的日志文件夹路径不存在，脚本执行自动创建&quot;, &apos;runErr&apos;)
            os.mkdir(FileNameAndPath)

    def getLogPath(self):

        #获取日志文件配置
        #需要运行的项目字典,即过滤完后的字典
        #dictConfMsg = self.getNeedRunMsg()
        #strLogPath = dictConfMsg.get(&apos;logpath&apos;)
        strLogPath = &apos;&apos;
        configureFileNameAndPath = self.configurePath + &apos;/&apos; + self.configureFileName
        self.checkAndInitConfigure(configureFileNameAndPath)
        config = configparser.ConfigParser(allow_no_value=True, delimiters=&apos;:&apos;)
        config.read(configureFileNameAndPath)
        if(config.has_section(&apos;LogConfigure&apos;)):
            strLogPath = config[&apos;LogConfigure&apos;][&apos;logpath&apos;]
            self.checkAndCreate(strLogPath)
        else:
            print(&quot;配置文件内容缺少日志配置参数&quot;)
            #self.writerContent(&quot;配置文件内容缺少日志配置参数&quot;, &apos;runErr&apos;)
        return strLogPath


    def reWriterForEmail(self, listSendContent, dictEmailMsg):

        #重构需要邮件发送的内容，并设置对应主题，并返回list
        #重构后的list数据集合格式：无错误日志list长度为3，有错误日志list长度为4
        #list[0]: Hour或者Second或者no
        #list[1]: 邮件主题
        #list[2]: 需要发送的邮件内容(已重构的内容)
        #list[3]: 错误日志的相对路径地址

        strNewContent = &apos;&apos;
        strContent = listSendContent[1]

        strServerName = &apos;none&apos;
        strUserName = &apos;cg&apos;
        for keyItem in dictEmailMsg:
            if((keyItem == &apos;servername&apos;) | (keyItem == &apos;username&apos;)):
                if(keyItem == &apos;servername&apos;):
                    strServerName = dictEmailMsg.get(&apos;servername&apos;)
                else:
                    strUserName = dictEmailMsg.get(&apos;username&apos;)
            else:
                continue

        strContentLine = &quot;====================&quot;

        strNewContent = strContent[:0] + strContentLine + &quot;\n&quot; + strContent[0:]
        strNewContent = (strNewContent + &quot;\n&quot; + strContentLine + &quot;\n&quot; + &quot;---&quot; +
                         strUserName + &quot;\n&quot; + &quot;---&quot; + self.strDateTime)

        listSendContent[1] = strNewContent
        if(listSendContent[0] == &apos;Hour&apos;):
            strSubject = strServerName + &quot;今日&quot; + self.strHourTime + &quot;时执行结果&quot;
            listSendContent.insert(1, strSubject)
        elif(listSendContent[0] == &apos;Second&apos;):
            strSubject = strServerName + &quot;今日&quot; + self.strHourMinTime + &quot;时检测到异常&quot;
            listSendContent.insert(1, strSubject)        

        else:
            strSubject = strServerName + &quot;脚本运行异常&quot;
            listSendContent.insert(1, strSubject)
        print(&quot;已重构......&quot;)
        print(listSendContent)
        return listSendContent
</code></pre><p>这个<code>fileUtil.py</code>文件中，功能包括配置文件的读取,判断,过滤以及日志文件的读取写入即邮件内容的操作，这是脚本的一个重要模块。写的时候本来时将文件处理和数据处理分开来写的，但写到中途又合并了，因为这是国庆放假前写的代码，国庆这8天假都没碰这代码，从昨天才开始继续写…..</p>
<h4 id="process-py"><a href="#process-py" class="headerlink" title="process.py"></a>process.py</h4><p>封装了调用了<code>subprocess.Popen</code>模块，实现python操作linux命令。通过python运行linux命令，截获两种输出<code>stdout</code>和<code>stderr</code>，在我看来这可分为有持续输出和无持续输出，区分这个时避免在持续输出时因存放量过大而发生阻塞，具体可参考<a href="http://www.firefoxbug.com/index.php/archives/2419/" target="_blank" rel="external">这篇文章</a>及<a href="https://docs.python.org/2/library/subprocess.html" target="_blank" rel="external">官方文档</a>,当然，这也有<a href="https://www.rddoc.com/doc/Python/3.6.0/zh/library/subprocess/?highlight=subprocess" target="_blank" rel="external">中文文档</a><br>代码如下</p>
<pre><code>#!/usr/bin/python3
#coding=utf-8

import subprocess

#author: cg错过
#time: 2017-09-30

class ProcessCL:

    #python操作Linux模块

    def getResultAndProcess(self, strCL):

        #
        #获取无持续输出的命令操作后的结果
        #获取正常输出和错误输出，存放到dict中返回
        #strCL: 操作的命令

        dictResult = {}
        strOut = &apos;&apos;
        strErr = &apos;&apos;
        subObj = subprocess.Popen(strCL, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True,
                                  universal_newlines=True)
        returnCode = subObj.poll()
        while returnCode is None:
            stdout, stderr = subObj.communicate()
            returnCode = subObj.poll()
            strOut += stdout
            strErr += stderr
        dictResult[&apos;stdout&apos;] = stdout
        dictResult[&apos;stderr&apos;] = stderr

        return dictResult


    def getContinueResultAndProcess(self, strCL):

        #获取有持续输出的程序的结果，将其分类(stdout和stderr)
        #但检测到无输出后就退出
        #strCL: 操作的命令

        strOut = &apos;&apos;
        strErr = &apos;&apos;
        dictResult = {}
        subObj = subprocess.Popen(strCL, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True,
                                  universal_newlines=True)
        returnCode = subObj.poll()
        while returnCode is None:
            lineOut = subObj.stdout.readline()
            lineErr = subObj.stdout.readline()
            returnCode = subObj.poll()
            lineOut = lineOut.strip()
            lineErr = lineErr.strip()

            strOut += lineOut
            strErr += lineErr
            if((lineOut == &apos;&apos;) | (lineErr == &apos;&apos;)):
                break

        dictResult[&apos;stdout&apos;] = strOut
        dictResult[&apos;stderr&apos;] = strErr

        return dictResult
</code></pre><p>上面的代码中，<code>getResultAndProcess()</code>这个方法虽然是针对无持续输出的命令，但依然是加上了<code>strOut += stdout</code>这个输出追加方式。因为如若不加这个，在当连续两次调用这个方法时，会出现bug，如下</p>
<pre><code>dictResult[&apos;stdout&apos;] = stdout
UnboundLocalError: local variable &apos;stdout&apos; referenced before assignment
</code></pre><p>即命令行执行时可能stdout和stderr都无值，都未给进行声明并赋值，所以导致后面添加到dict的时候就会出错，这个错误就是在变量赋值之前被引用</p>
<h4 id="emailUtil-py"><a href="#emailUtil-py" class="headerlink" title="emailUtil.py"></a>emailUtil.py</h4><p>邮件发送模块<br>代码如下</p>
<pre><code>#!/usr/bin/python3
#coding=utf-8

import sys
from smtplib import SMTP_SSL
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from email.header import Header

#author: cg错过
#time: 2017-09-30

class EmailUtil:

    #发送邮件模块

    def __init__(self, dictNeedRunMsg, fileUtilObj):

        #dictNeedRunMsg:存放从配置文件中读取到的数据，其数据是本次检测运行所需要的数据
        #fileUtilObj: FileUtil的对象(脚本从运行到结束都只有这一个FileUtil对象)
        #其中的key有
        #smtp_server:
        #mail_sendAddr:
        #mail_sendPasswd:
        #mail_toAddr:

        self.fileUtilObj = fileUtilObj
        dictEmailMsg = self.getForEmailMsg(dictNeedRunMsg)
        listEmailContentMsg = self.checkAndGetForEmailListMsg()

        strServerName = dictEmailMsg.get(&apos;servername&apos;)
        strUserName = dictEmailMsg.get(&apos;username&apos;)
        listNewEmailContentMsg = self.fileUtilObj.reWriterForEmail(listEmailContentMsg, dictEmailMsg)

        self.choiceSend(dictEmailMsg, listNewEmailContentMsg)

    def getForEmailMsg(self, dictNeedRunMsg):

        #将从配置文件的完全读取到的数据中，抽取出发送邮件需要的数据，存放为dict类型并返回
        #dictNeedRunMsg: 存放从配置文件中读取到的数据，其数据是本次检测运行所需要的数据
        #因为有可能并不是所有项目都配置了需要运行

        dictMsgForEmail = {}
        for keyItem in dictNeedRunMsg:
            if((keyItem == &apos;email_sendaddr&apos;) | (keyItem == &apos;email_sendpasswd&apos;) |
               (keyItem == &apos;smtp_server&apos;) | (keyItem == &apos;ToEmail&apos;) | (keyItem == &apos;logpath&apos;) |
               (keyItem == &apos;servername&apos;) | (keyItem == &apos;username&apos;)):
                dictMsgForEmail[keyItem] = dictNeedRunMsg.get(keyItem)

        return dictMsgForEmail

    def checkAndGetForEmailListMsg(self):

        #检查是否存在日志，并读取该日志进行返回
        #返回格式:如无错误日志list长度为2，有错误日志list长度为3
        #list[0]: Hour或者Second或者no
        #list[1]: 需要发送的邮件内容(仅运行日志)
        #list[2]: 错误日志的相对路径地址

        #产生的日志文件中，在每分钟和每小时的两种情况中，只会运行一种情况
        #也就是只会产生一个日志

        listSendContent = []
        intExistsContent = self.fileUtilObj.checkFileExists(self.fileUtilObj.strlogContentName)
        intExistsContentS = self.fileUtilObj.checkFileExists(self.fileUtilObj.strlogContentSecondName)
        if(intExistsContent == 1):
            listSendContent.append(&apos;Hour&apos;)
            print(self.fileUtilObj.strlogContentName)
            strContent = self.fileUtilObj.readFileContent(self.fileUtilObj.strlogContentName)
            listSendContent.append(strContent)

            intExistsErr = self.fileUtilObj.checkFileExists(self.fileUtilObj.strlogErrName)
            if(intExistsErr == 1):
                print(&quot;每小时，有错误，附件&quot;)
                listSendContent.append(self.fileUtilObj.strlogErrName)
            else:
                print(&quot;每小时，无错误&quot;)
        elif(intExistsContentS == 1):
            listSendContent.append(&apos;Second&apos;)
            print(self.fileUtilObj.strlogContentSecondName)
            strContentS = self.fileUtilObj.readFileContent(self.fileUtilObj.strlogContentSecondName)
            listSendContent.append(strContentS)

            intExistsErrS = self.fileUtilObj.checkFileExists(self.fileUtilObj.strlogErrSecondName)
            if(intExistsErrS == 1):
                print(&quot;每分钟，有错误，附件&quot;)
                listSendContent.append(self.fileUtilObj.strlogErrSecondName)
            else:
                print(&quot;每分钟，无错误&quot;)

        else:
            listSendContent.append(&apos;no&apos;)
            strContent = &quot;未产生日志文件&quot;
            self.fileUtilObj.writerContent(&quot;未产生日志文件&quot;, &apos;runErr&apos;)
            listSendContent.append(strContent)
        print(&quot;未重构......&quot;)
        print(listSendContent)

        return listSendContent


    def choiceSend(self, dictEmailMsg, listEmailContent):

        #选择发送类型(有无附件)
        #dictEmailMsg: 发送和接受邮件账户，及smtp服务器地址
        #listEmailContent: 发送的邮件内容，主题，附件

        strSmtpServer = dictEmailMsg.get(&apos;smtp_server&apos;)
        strSendAddr = dictEmailMsg.get(&apos;email_sendaddr&apos;)
        strPasswd = dictEmailMsg.get(&apos;email_sendpasswd&apos;)
        listToAddr = dictEmailMsg.get(&apos;ToEmail&apos;)
        strSubject = listEmailContent[1]
        strContent = listEmailContent[2]

        if(len(listEmailContent) == 3):
            if(listEmailContent[0] != &apos;no&apos;):
                self.sendEmailByString(strSmtpServer, strSendAddr, strPasswd,
                               listToAddr, strSubject, strContent)
            else:
                self.fileUtilObj.writerContent(&quot;邮件未发送&quot;, &apos;runErr&apos;)
        else:
            strErrFilePath = listEmailContent[3]
            self.sendEmailByStringAndFile(strSmtpServer, strSendAddr, strPasswd,
                               listToAddr, strSubject, strContent, strErrFilePath)

        #print(self.fileUtilObj.strlogContentSecondName)


    def sendEmailByString(self, strSmtpServer, strSendAddr, strPasswd,
                          listToAddr, strSubject, strContent):

        #用字符串来发送邮件
        #strSmtpServer: smtp服务器地址
        #strSendAddr: 邮件发送地址
        #strPasswd: 发送地址的登陆授权码
        #listToAddr: 接受邮件的地址，为list集合
        #strSubject: 邮件主题
        #strContent: 邮件内容字符串类型
        #message对象中的三个key(&apos;From&apos;,&apos;To&apos;,&apos;Subject&apos;)最好都要有，不然容易被识别为垃圾邮件

        #mail_port = &apos;465&apos;

        message = MIMEText(strContent, &quot;plain&quot;, &quot;utf-8&quot;)
        message[&apos;Subject&apos;] = Header(strSubject, &apos;utf-8&apos;)
        message[&apos;From&apos;] = Header(&apos;monitor&lt;%s&gt;&apos; % strSendAddr, &apos;utf-8&apos;)
        message[&apos;To&apos;] = Header(&apos;monitor.admin&apos;, &apos;utf-8&apos;)

        try:
            smtpObj = SMTP_SSL(strSmtpServer)
            #smtpObj.set_debuglevel(1)
            smtpObj.ehlo(strSmtpServer)
            smtpObj.login(strSendAddr, strPasswd)
            if(len(listToAddr) &gt; 0):
                smtpObj.sendmail(strSendAddr, listToAddr, message.as_string())
                smtpObj.quit()
            else:
                self.fileUtilObj.writerContent(&quot;接收邮件地址为空&quot;, &apos;runErr&apos;)
            #self.fileUtilObj.writerContent(&quot;邮件发送成功&quot;)
        except:
            print(sys.exc_info()[0])
            self.fileUtilObj.writerContent(&quot;邮件发送失败&quot;, &apos;runErr&apos;)


    def sendEmailByStringAndFile(self, strSmtpServer, strSendAddr, strPasswd,
                          listToAddr, strSubject, strContent, strErrFilePath):

        #发送有附件的邮件
        #strSmtpServer: smtp服务器地址
        #strSendAddr: 邮件发送地址
        #strPasswd: 发送地址的登陆授权码
        #listToAddr: 接受邮件的地址，为list集合
        #strSubject: 邮件主题
        #strContent: 邮件内容字符串类型
        #message对象中的三个key(&apos;From&apos;,&apos;To&apos;,&apos;Subject&apos;)最好都要有，不然容易被识别为垃圾邮件

        #mail_port = &apos;465&apos;

        message = MIMEMultipart()
        message[&apos;Subject&apos;] = Header(strSubject, &apos;utf-8&apos;)
        message[&apos;From&apos;] = Header(&apos;monitor&lt;%s&gt;&apos; % strSendAddr, &apos;utf-8&apos;)
        message[&apos;To&apos;] = Header(&apos;monitor.admin&apos;, &apos;utf-8&apos;)

        message.attach(MIMEText(strContent, &apos;plain&apos;, &apos;utf-8&apos;))

        annexFile = MIMEText(open(strErrFilePath, &apos;rb&apos;).read(), &apos;base64&apos;, &apos;utf-8&apos;)
        annexFile[&quot;Content-Type&quot;] = &apos;application/octet-stream&apos;
        annexFile[&quot;Content-Disposition&quot;] = &apos;attachment; filename=&quot;err_logs.txt&quot;&apos;
        message.attach(annexFile)

        try:
            smtpObj = SMTP_SSL(strSmtpServer)
            #smtpObj.set_debuglevel(1)
            smtpObj.ehlo(strSmtpServer)
            smtpObj.login(strSendAddr, strPasswd)
            if(len(listToAddr) &gt; 0):
                smtpObj.sendmail(strSendAddr, addrItem, message.as_string())
                smtpObj.quit()
            else:
                self.fileUtilObj.writerContent(&quot;接受邮件地址为空&quot;, &apos;runErr&apos;)
            #self.fileUtilObj.writerContent(&quot;附件邮件发送成功&quot;)
        except:
            print(sys.exc_info()[0])
            self.fileUtilObj.writerContent(&quot;附件邮件发送失败&quot;, &apos;runErr&apos;)
</code></pre><p>具体看代码中的注释即可</p>
<h4 id="sysTime-py"><a href="#sysTime-py" class="headerlink" title="sysTime.py"></a>sysTime.py</h4><p>时间模块<br>代码如下</p>
<pre><code>#!/usr/bin/python3
#coding=utf-8

import time

#author: cg错过
#time: 2017-09-30

class RunTime:

    #时间模块

    def getTime(self, strFormat):

        #按照格式获取时间

        nowTime = time.localtime()
        strFormatTime = time.strftime(strFormat, nowTime)
        return strFormatTime

    def getDateTime(self):
        return self.getTime(&quot;%Y-%m-%d %H:%M:%S&quot;)

    def getNumSecondTime(self):
        return self.getTime(&quot;%Y%m%d%H%M%S&quot;)

    def getNumHourTime(self):
        return self.getTime(&quot;%Y%m%d%H&quot;)

    def getMinTime(self):
        return self.getTime(&quot;%M&quot;)

    def getHourTime(self):
        return self.getTime(&quot;%H&quot;)

    def getHourMinTime(self):
        return self.getTime(&quot;%H%M&quot;)
</code></pre><h3 id="monitorbin-module包"><a href="#monitorbin-module包" class="headerlink" title="monitorbin.module包"></a>monitorbin.module包</h3><h4 id="tomcatCheck-py"><a href="#tomcatCheck-py" class="headerlink" title="tomcatCheck.py"></a>tomcatCheck.py</h4><p>tomcat检测模块<br>代码如下</p>
<pre><code>#!/usr/bin/python3
#coding=utf-8

import subprocess
import os
from monitorbin.util.process import ProcessCL

#author: cg错过
#time: 2017-09-30

class TomcatOperate:

    #tomcat检测模块
    #需要配合前面分时间段来运行
    #即至少要有个对tomcat进行所有全部的检测和部分检测两种功能
    #全检不提供脚本操作功能，例如自启。全检后不管是否正常都将发送邮件
    #部检提供自启，自启后只有检测到不正常才发送邮件

    def __init__(self, strTotalPath, intDateMin, fileUtilObj):

        #strTotalPath: tomcat的安装文件根目录的上一级目录
        #intDateMin: 当前运行脚本的分钟数
        #fileUtilObj: FileUtil的对象(脚本从运行到结束都只有这一个FileUtil对象)

        self.fileUtil = fileUtilObj
        self.intDateMin = intDateMin
        self.strTotalPath = strTotalPath
        #self.fileUtil.writerContent(&quot;你好&quot;)
        intCheckResult = self.fileUtil.checkFileExists(self.strTotalPath)
        if(intCheckResult == 1):
            self.checkTomcat()
        else:
            self.fileUtil.writerContent(&quot;配置的tomcat路径不存在&quot;, &apos;runErr&apos;)

    def checkTomcat(self):

        #检测tomcat

        strTomcatStatus = self.getTomcatStatus()
        dictTomcatMsg = self.getTomcatMsg(self.strTotalPath)
        listTomcatName = dictTomcatMsg.get(&apos;tomcatName&apos;)
        listTomcatPort = dictTomcatMsg.get(&apos;tomcatPort&apos;)
        listTomcatPath = dictTomcatMsg.get(&apos;tomcatPath&apos;)

        if(self.intDateMin == 30):
            for i in range(len(listTomcatPort)):
                intMark = self.checkTomcatStatusByPort(i, listTomcatName, listTomcatPort, strTomcatStatus)
                if(intMark == 1):
                    #print(&quot;查看日志&quot;)
                    #self.fileUtil.writerContent(&quot;查看日志&quot;)
                    self.checkTomcatLogStatusByTomcatName(i, listTomcatName, listTomcatPort)
        else:
            for i in range(len(listTomcatPort)):
                #print(i)
                intMark = self.checkTomcatStatusByPort(i, listTomcatName, listTomcatPort,
                                                       strTomcatStatus, &apos;Second&apos;)
                if(intMark != 1):
                    #print(&quot;重启&quot;)
                    self.tryStartTomcat(i, listTomcatPath, listTomcatName)


    def getTomcatStatus(self):

        #获取进程中的tomcat
        tomcatStatusCL = &quot;ps -ef | grep tomcat&quot;
        processCL = ProcessCL()
        dictResult = processCL.getResultAndProcess(tomcatStatusCL)
        strTomcatStatus = dictResult.get(&apos;stdout&apos;)
        return strTomcatStatus


    def checkTomcatStatusByPort(self, intIndex, listTomcatName, listTomcatPort, strTomcatStatus,
                                strFileMark=&apos;Hour&apos;):

        #检测tomcat是否运行，在运行返回1
        #intIndex: 要检测的tomcat所在dictTomcatMsg中tomcatName的下标
        #dictTomcatMsg: 存放tomcat文件名,端口号和对应路径,为字典类型包含列表

        intMark = -1

        #listTomcatName = dictTomcatMsg.get(&apos;tomcatName&apos;)
        #listTomcatPort = dictTomcatMsg.get(&apos;tomcatPort&apos;)

        if(strTomcatStatus.find(listTomcatName[intIndex]) != -1):
            intMark = 1
            if(strFileMark==&apos;Hour&apos;):
                self.fileUtil.writerContent((&quot;%s在运行&quot; %(listTomcatName[intIndex])), &apos;Hour&apos;, False)
            #else:
                #self.fileUtil.writerContent((&quot;%s在运行&quot; %(listTomcatName[intIndex])), &apos;Second&apos;)
        else:
            if(strFileMark==&apos;Hour&apos;):
                self.fileUtil.writerContent((&quot;%s未运行&quot; %(listTomcatName[intIndex])))
            else:
                self.fileUtil.writerContent((&quot;%s未运行&quot; %(listTomcatName[intIndex])), &apos;Second&apos;)
                #print(&quot;%s未运行&quot; %(listTomcatName[intIndex]))

        return intMark


    def checkTomcatLogStatusByTomcatName(self, intIndex, listTomcatName, listTomcatPort):

        #检测tomcat日志输出是否正常，正常返回1
        #intIndex: tomcat所在dictTomcatMsg中tomcatName的下标，一般检测在运行的tomcat
        #dictTomcatMsg: 存放tomcat文件名,端口号和对应路径,为字典类型包含列表

        intMark = 1

        #listTomcatName = dictTomcatMsg.get(&apos;tomcatName&apos;)
        #listTomcatPort = dictTomcatMsg.get(&apos;tomcatPort&apos;)
        strOperateTomcatPath = listTomcatPath[intIndex]

        checkLogCL = &quot;tail -n 200 &quot; + strOperateTomcatPath + &quot;/logs/catalina.out&quot;
        processCL = ProcessCL()
        dictResult = processCL.getResultAndProcess(checkLogCL)
        strOut = dictResult.get(&apos;stdout&apos;)
        if(strOut.find(&quot;exception&quot;) != -1):
            intMark = -1
            #print(&quot;%s日志输出异常&quot; %(listTomcatName[intIndex]))
            self.fileUtil.writerContent((&quot;%s日志输出异常&quot; %(listTomcatName[intIndex])))
        else:
            self.fileUtil.writerContent((&quot;%s日志输出正常&quot; %(listTomcatName[intIndex])))
            #print(&quot;%s日志输出正常&quot; %(listTomcatName[intIndex]))
            self.fileUtil.writerErr(strOut)
        return intMark



    def tryStartTomcat(self, intIndex, listTomcatPath, listTomcatName):

        #启动未运行的tomcat，启动成功返回1
        #intIndex: 未运行的tomcat所在dictTomcatMsg中tomcatName的下标
        #dictTomcatMsg: 存放tomcat文件名,端口号和对应路径，为字典类型包含列表

        intMark = -1

        #listTomcatPath = dictTomcatMsg.get(&apos;tomcatPath&apos;)
        #listTomcatName = dictTomcatMsg.get(&apos;tomcatName&apos;)
        #print(&quot;脚本尝试将其启动....&quot;)
        self.fileUtil.writerContent(&quot;脚本尝试将其启动....&quot;, &apos;Second&apos;)
        strOperateTomcatPath = listTomcatPath[intIndex]
        tryStartTomcatCL = strOperateTomcatPath + &quot;/bin/./catalina.sh start&quot;
        processCL = ProcessCL()
        dictResult = processCL.getResultAndProcess(tryStartTomcatCL)
        strOut = dictResult.get(&apos;stdout&apos;)
        strErr = dictResult.get(&apos;stderr&apos;)
        if(strOut != &apos;&apos;):
            if((strOut.find(&apos;Tomcat started&apos;) != -1) &amp; (strErr == &apos;&apos;)):
                #print(&quot;%s已被脚本启动成功&quot; %(listTomcatName[intIndex]))
                self.fileUtil.writerContent((&quot;%s已被脚本启动成功&quot; %(listTomcatName[intIndex])),
                                            &apos;Second&apos;)
                intMark = 1
            else:
                #print(&quot;脚本启动%s未成功,请手动启动&quot; %(listTomcatName[intIndex]))
                self.fileUtil.writerContent((&quot;脚本启动%s未成功,请手动启动&quot; %(listTomcatName[intIndex])),
                                            &apos;Second&apos;)
                self.fileUtil.writerErr(strErr, &apos;Second&apos;)
        else:
            #print(&quot;%s启动命令未执行&quot; %(listTomcatName[intIndex]))
            self.fileUtil.writerContent((&quot;%s启动命令未执行,请手动执行&quot; %(listTomcatName[intIndex])), &apos;Second&apos;)
            #print(strErr)
            self.fileUtil.writerErr(strErr, &apos;Second&apos;)
        return intMark


    def getTomcatMsg(self, strTotalPath):

        #根据存放多个tomcat的文件路径来查找多少个tomcat
        #获取tomcat安装文件的名称和对应的端口
        #通过读取tomcat配置文件，以此来获得端口号
        #返回一个字典，存放tomcat安装文件名和对应端口号

        dictTomcatMsg = {}
        listTomcatName = []
        listMsgName = os.listdir(strTotalPath)
        for item in listMsgName:
            nextPath = (strTotalPath + &apos;/&apos; +  item)
            if(os.path.isdir(nextPath)):
                confPath = (nextPath + &apos;/conf/server.xml&apos;)
                if((item.find(&quot;tomcat&quot;) != -1) &amp; (os.path.exists(confPath))):
                    listMsgName.remove(item)
                    listTomcatName.append(item)

        #fileUtil = FileUtil()
        listTomcatPort = []
        listTomcatPath = []
        for item in listTomcatName:
            nextPath = (strTotalPath + &apos;/&apos; +  item)
            confPath = (nextPath + &apos;/conf/server.xml&apos;)
            intItemPort = self.fileUtil.getXMLTagElementValue(confPath, &apos;Connector&apos;, &apos;port&apos;, 0)
            listTomcatPort.append(intItemPort)
            listTomcatPath.append(nextPath)

        dictTomcatMsg[&apos;tomcatName&apos;] = listTomcatName
        dictTomcatMsg[&apos;tomcatPort&apos;] = listTomcatPort
        dictTomcatMsg[&apos;tomcatPath&apos;] = listTomcatPath
        print(dictTomcatMsg)

        return dictTomcatMsg
</code></pre><p>这个tomcat检测模块中，可以比较自动识别tomcat安装个数及相对应的端口，操作xml配置文件的方法在fileUtil.py这个模块类中</p>
<h4 id="redisCheck-py"><a href="#redisCheck-py" class="headerlink" title="redisCheck.py"></a>redisCheck.py</h4><p>redis检测模块<br>代码如下</p>
<pre><code>#!/usr/bin/python3
#coding=utf-8

import os
from monitorbin.util.process import ProcessCL

#author: cg错过
#time: 2017-09-30

class RedisOperate:

    #redis检测模块

    def __init__(self, strRedisPath, intDateMin, fileUtilObj):

        #strRedisPath: redis的安装文件目录
        #intDateMin: 当前运行脚本的分钟数
        #fileUtilObj: FileUtil的对象(脚本从运行到结束都只有这一个FileUtil对象)

        self.fileUtil = fileUtilObj
        self.intDateMin = intDateMin
        self.strRedisPath = strRedisPath
        intCheckResult = self.fileUtil.checkFileExists(self.strRedisPath)
        if(intCheckResult == 1):
            self.checkRedis()
        else:
            self.fileUtil.writerContent(&quot;配置的redis路径不存在&quot;, &apos;runErr&apos;)

    def checkRedis(self):

        #每个小时检测一遍，不做操作
        #其他时候，当检测到未运行时，脚本尝试自启一次

        strRedisStatus = self.getRedisStatus()

        if(self.intDateMin == 30):
            self.checkRedisStatus(strRedisStatus)
        else:
            intMark = self.checkRedisStatus(strRedisStatus, &apos;Second&apos;)
            if(intMark == -1):
                self.tryStartRedis(self.strRedisPath)


    def getRedisStatus(self):

        #获取进程中的redis

        redisStatusCL = &quot;ps -ef | grep redis&quot;
        processCL = ProcessCL()
        dictResult = processCL.getResultAndProcess(redisStatusCL)
        strRedisStatus = dictResult.get(&apos;stdout&apos;)
        return strRedisStatus


    def checkRedisStatus(self, strRedisStatus, strFileMark=&apos;Hour&apos;):

        #判断redis是否运行

        intMark = -1
        strRedis = &quot;redis-server&quot;

        if(strRedisStatus.find(strRedis) != -1):
            #print(&quot;redis在运行&quot;)
            if(strFileMark==&apos;Hour&apos;):
                self.fileUtil.writerContent(&quot;redis在运行&quot;)
            intMark = 1
        else:
            if(strFileMark==&apos;Hour&apos;):
                self.fileUtil.writerContent(&quot;redis未运行&quot;)
            else:
                self.fileUtil.writerContent(&quot;redis未运行&quot;, &apos;Second&apos;)
            #print(&quot;redis未运行&quot;)
        return intMark


    def tryStartRedis(self, strRedisPath):

        #脚本启动redis

        intMark = -1
        #print(&quot;脚本尝试将其启动....&quot;)
        #print(strRedisPath)
        self.fileUtil.writerContent(&quot;脚本尝试将其启动....&quot;, &apos;Second&apos;)
        strStartRedisCL = strRedisPath + &quot;/src/./redis-server&quot;
        processCL = ProcessCL()
        dictResult = processCL.getContinueResultAndProcess(strStartRedisCL)
        strOut = dictResult.get(&apos;stdout&apos;)
        strErr = dictResult.get(&apos;stderr&apos;)
        if(strOut.find(&apos;redis.io&apos;) != -1):
            self.fileUtil.writerContent(&quot;redis已被脚本启动&quot;, &apos;Second&apos;)
            #print(&quot;redis已被脚本启动成功&quot;)
            intMark = 1
        else:
            #print(&quot;脚本启动redis未成功，请手动启动&quot;)
            self.fileUtil.writerContent(&quot;脚本启动redis未成功，请手动启动&quot;, &apos;Second&apos;)
            self.fileUtil.writerErr(strErr, &apos;Second&apos;)
            #print(strErr)
        return intMark
</code></pre><h4 id="nginxCheck-py"><a href="#nginxCheck-py" class="headerlink" title="nginxCheck.py"></a>nginxCheck.py</h4><p>nginx检测模块<br>代码如下</p>
<pre><code>#!/usr/bin/python3
#coding=utf-8

from monitorbin.util.process import ProcessCL

#author: cg错过
#time: 2017-09-30

class NginxOperate:

    #nginx检测模块

    def __init__(self, strNginxPath, intDateMin, fileUtilObj):

        #strNginxPath: nginx的安装目录
        #intDateMin: 当前运行脚本的分钟数
        #fileUtilObj: FileUtil的对象(脚本从运行到结束都只有这一个FileUtil对象)

        self.fileUtil = fileUtilObj
        self.intDateMin = intDateMin
        self.strNginxPath = strNginxPath
        intCheckResult = self.fileUtil.checkFileExists(self.strNginxPath)
        if(intCheckResult == 1):
            self.checkNginx()
        else:
            self.fileUtil.writerContent(&quot;配置的nginx路径不存在&quot;, &apos;runErr&apos;)

    def checkNginx(self):

        #每个小时检测一遍，不做操作
        #其他时候，当检测到未运行时，脚本尝试自启一次

        strNginxStatus = self.getNginxStatus()

        if(self.intDateMin == 30):
            self.checkNginxStatus(strNginxStatus)
        else:
             intMark = self.checkNginxStatus(strNginxStatus, &apos;Second&apos;)
             if(intMark == -1):
                 self.tryStartNginx(self.strNginxPath)



    def getNginxStatus(self):

        #获取进程中的nginx

        nginxStatusCL = &quot;ps -ef | grep nginx&quot;
        processCL = ProcessCL()
        dictResult = processCL.getResultAndProcess(nginxStatusCL)
        strNginxStatus = dictResult.get(&apos;stdout&apos;)
        return strNginxStatus


    def checkNginxStatus(self, strNginxStatus, strFileMark=&apos;Hour&apos;):

        #判断nginx是否运行

        intMark = -1
        strNginx = &quot;nginx:&quot;

        if(strNginxStatus.find(strNginx) != -1):
            #print(&quot;nginx在运行&quot;)
            intMark = 1
            if(strFileMark==&apos;Hour&apos;):
                self.fileUtil.writerContent(&quot;nginx在运行&quot;)
        else:
            if(strFileMark==&apos;Hour&apos;):
                self.fileUtil.writerContent(&quot;nginx未运行&quot;)
            else:
                self.fileUtil.writerContent(&quot;nginx未运行&quot;, &apos;Second&apos;)
            #print(&quot;nginx未运行&quot;)
        return intMark


    def tryStartNginx(self, strNginxPath):

        #脚本启动nginx

        intMark = -1
        self.fileUtil.writerContent(&quot;脚本尝试将其启动....&quot;, &apos;Second&apos;)
        strStartNginxCL = strNginxPath + &quot;/sbin/./nginx&quot;
        processCL = ProcessCL()
        dictResult = processCL.getResultAndProcess(strStartNginxCL)
        strErr = dictResult.get(&apos;stderr&apos;)
        if(strErr == &apos;&apos;):
            #print(&quot;nginx已被脚本启动&quot;)
            self.fileUtil.writerContent(&quot;nginx已被脚本启动&quot;, &apos;Second&apos;)
            intMark = 1
        else:
            #print(&quot;脚本启动nginx未成功，请手动启动&quot;)
            self.fileUtil.writerContent(&quot;脚本启动nginx未成功，请手动启动&quot;, &apos;Second&apos;)
            self.fileUtil.writerErr(strErr, &apos;Second&apos;)
            #print(strErr)
        return intMark
</code></pre><p>nginx和redis这两个检测模块代码比较类似</p>
<h3 id="monitor-conf"><a href="#monitor-conf" class="headerlink" title="monitor.conf"></a>monitor.conf</h3><p>配置文件内容字段如下</p>
<pre><code>[ProjectConfigure]
tomcatpath : tomcat安装目录的上一级目录，如果有多个tomcat,则为多个tomcat安装目录的上一级。需要这多个tomcat在同一目录下
nginxpath : nginx安装目录
redispath : redis安装目录

[UseConfigure]
servername : 服务器别称
username : 发送邮件用户名

[LogConfigure]
logpath : 存放日志文件的路径名,例如&apos;logpath :logs&apos;即将在本脚本根目录下创建logs文件夹来存放日志

[EmailConfigure]
smtp_server : smtp服务地址,例如&apos;smtp.qq.com&apos;
email_sendaddr : 发送邮件的邮箱账户
email_sendpasswd : 发送邮件的账户授权码

[ToEmail]
//在此处填写接受邮件的邮箱地址，可以为多个，例如如下
1732821152@qq.com
</code></pre><h3 id="定时执行实现"><a href="#定时执行实现" class="headerlink" title="定时执行实现"></a>定时执行实现</h3><p>现在的实现方式是使用linux上的crontab定时器来执行脚本<br>命令<br><code>sudo vim /etc/crontab</code><br>在其中添加<br><code>*/5 * * * * root /usr/bin/python3 /usr/scripts/python/automatic_monitor/monitor.py &gt;&gt; /var/log/monitor.py.log 2&gt;&amp;1</code><br>其代码的意思就是告诉crontab，这个脚本是每隔5分钟使用root身份，用<code>/usr/bin/</code>此路径下的python3命令来运行monitor.py这个脚本，并将脚本中的输出和脚本运行出错的输出写入到<code>/var/log/monitor.py.log这个文件中</code><br>使用这个方法会出现两个问题<br>1.编码问题<br>输出如下</p>
<pre><code>Traceback (most recent call last):
  File &quot;/usr/scripts/python/automatic_monitor/test.py&quot;, line 7, in &lt;module&gt;
    print(&quot;\u914d\u7f6e\u6587\u4ef6monitor.conf\u4e0d\u5b58\u5728,\u811a\u672c\u81ea\u52a8\u521b\u5efa\u5e76\u521d\u59cb\u5316&quot;)
UnicodeEncodeError: &apos;ascii&apos; codec can&apos;t encode characters in position 0-3: ordinal not in range(128)
</code></pre><p>这个问题很奇怪，使用命令行运行脚本就不会出现这个问题。gg<br>解决这个问题的方法是在<code>/etc/crontab</code>这个文件中添加字段<br><code>LANG=zh_CN.UTF-8</code><br>其原因就是crontab使用的环境变量配置文件并不是<code>/etc/profile</code>这个，而是使用自己的环境变量，即它自身的环境变量配置在就crontab这个文件中(文件内容开头部分)</p>
<p>2.这个问题是本身的脚本问题，脚本设定的配置文件路径是固定的，即脚本目录的根目录。如果在这个情况下，使用crontab来做定时任务，那么脚本自动创建的配置文件路径将不是脚本存放目录的根目录，而将是<code>/root</code>这个目录，因为是以root身份运行，所以也就是说，使用crontab这个定时器来运行脚本，那么脚本的工作目录将会是<code>/root</code>这个路径，其创建的配置文件夹路径将为<code>/root/conf</code>.<br>所以这需要在脚本上进行调整。</p>
<p>后面将对代码进行更改，将定时功能直接添加到脚本本身中。</p>
<p>目前脚本简单检测这三个项目的功能已经实现，后期只需要在进程模块包中进行添加模块，同是配置文件也需要更改<br>后面再写，慢慢维护。项目代码已经提交至github仓库中，<a href="https://github.com/cgstudios/createUtil-daily-me/tree/master/python/automatic_monitor/automatic_monitor-base" target="_blank" rel="external">这是里链接</a></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/python/" rel="tag"># python</a>
          
            <a href="/tags/linux/" rel="tag"># linux</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/10/10/daily/2017-10-10-daily-cambodiaNote/" rel="next" title="柬埔寨笔记">
                <i class="fa fa-chevron-left"></i> 柬埔寨笔记
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/10/11/python/2017-10-11-python-installPython3/" rel="prev" title="Linux上安装python3">
                Linux上安装python3 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>

<div id="gitalk-container"></div>
<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
<script>
var gitalk = new Gitalk({
  clientID: '72b592f61c3081484782',
  clientSecret: 'f52ccfc473ec10411d5357cd7cb980fb6a940ed7',
  repo: 'cgstudios.github.io',
  owner: 'cgstudios',
  admin: ['cgstudios'],
  distractionFreeMode: true
})
gitalk.render('gitalk-container')
</script>
  
  
  

          </div>
          


          
  


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
      <div id="sidebar-dimmer"></div>
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="cg" />
            
              <p class="site-author-name" itemprop="name">cg</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">53</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">24</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
              
                <span class="links-of-author-item">
                  <a href="https://github.com/cgstudios" target="_blank" title="GitHub">
                    
                      <i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://twitter.com/cg082702" target="_blank" title="Twitter">
                    
                      <i class="fa fa-fw fa-twitter"></i>Twitter</a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="http://weibo.com/5123957375" target="_blank" title="weibo">
                    
                      <i class="fa fa-fw fa-globe"></i>weibo</a>
                </span>
              
            
          </div>

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-globe"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://qqdie.com" title="QQ 爹博客" target="_blank">QQ 爹博客</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.neverlove.me/" title="不才博客" target="_blank">不才博客</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://siitake.cn/" title="香菇社长" target="_blank">香菇社长</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.dreamwings.cn/" title="若是凉夜已成梦" target="_blank">若是凉夜已成梦</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://blog.thkira.com/" title="兰陵の记事簿" target="_blank">兰陵の记事簿</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://Lao.si" title="孙老四 Lao.si" target="_blank">孙老四 Lao.si</a>
                  </li>
                
              </ul>
            </div>
          

          <div id="aplayer1" class="aplayer"></div>
<script src="/lib/aplayer/APlayer.min.js"></script>
<script>
	var ap = new APlayer({
		element: document.getElementById('aplayer1'),
		narrow: false,
		autoplay: false,
		showlrc: false,
		mutex: true,
		theme: '#e6d0b2',
		preload: 'metadata',
		mode: 'circulation',
		music: {
			title: '流浪者之歌',
			author: '陈绮贞',
			url: '/lib/song/llzzg/The-song-of-the-Rangers.mp3',
			pic: 'http://p3.music.126.net/uXxV1FqCCQz61vsOX0JXdA==/5779033115676966.jpg?param=300y300'
		}
	});
</script>

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#脚本概况"><span class="nav-number">1.</span> <span class="nav-text">脚本概况</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#monitorbin包"><span class="nav-number">2.</span> <span class="nav-text">monitorbin包</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#operate-py"><span class="nav-number">2.1.</span> <span class="nav-text">operate.py</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#monitorbin-util包"><span class="nav-number">3.</span> <span class="nav-text">monitorbin.util包</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#fileUtil-py"><span class="nav-number">3.1.</span> <span class="nav-text">fileUtil.py</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#process-py"><span class="nav-number">3.2.</span> <span class="nav-text">process.py</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#emailUtil-py"><span class="nav-number">3.3.</span> <span class="nav-text">emailUtil.py</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#sysTime-py"><span class="nav-number">3.4.</span> <span class="nav-text">sysTime.py</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#monitorbin-module包"><span class="nav-number">4.</span> <span class="nav-text">monitorbin.module包</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#tomcatCheck-py"><span class="nav-number">4.1.</span> <span class="nav-text">tomcatCheck.py</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#redisCheck-py"><span class="nav-number">4.2.</span> <span class="nav-text">redisCheck.py</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#nginxCheck-py"><span class="nav-number">4.3.</span> <span class="nav-text">nginxCheck.py</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#monitor-conf"><span class="nav-number">5.</span> <span class="nav-text">monitor.conf</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#定时执行实现"><span class="nav-number">6.</span> <span class="nav-text">定时执行实现</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2016 - <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">cg</span>

  
  
  <span class="span-time"></span>
  <script>
  var startTime = new Date("2016/12/27");
  setInterval(function () {
    var nowTime = new Date();
    var time = nowTime - startTime;
    var day = parseInt(time / 1000 / 60 / 60 / 24);
    var hour = parseInt(time / 1000 / 60 / 60 % 24);
    var minute = parseInt(time / 1000 / 60 % 60);
    var seconds = parseInt(time / 1000 % 60);
    $('.span-time').html("&nbsp;| &nbsp;" + "建站" + day + "天" + hour + "小时" + minute + "分钟" + seconds + "秒");
  }, 1000);
  </script>
</div>









        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>访问人次
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      人
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>访问次数
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  








  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  

  

  

  

</body>
</html>
