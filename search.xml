<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[night]]></title>
      <url>/2017/12/09/daily/2017-12-09-daily-wu/</url>
      <content type="html"><![CDATA[<p>好久没更博客了<br>最近事有点多</p>
<a id="more"></a>
<p>还是要找点自己的事做<br>做回自己</p>
<p>琐事太多<br>飘忽不定<br>或许飘泊不定的日子才是我们所谓的生活</p>
]]></content>
      
        <categories>
            
            <category> daily </category>
            
        </categories>
        
        
        <tags>
            
            <tag> daily </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[随感]]></title>
      <url>/2017/10/13/daily/2017-10-13-daily-withTheFeeling/</url>
      <content type="html"><![CDATA[<p>今天突然就想明白了</p>
<p>朋友总是要走的<br>人还是要交朋友的<br>朋友来，我欢迎<br>朋友走，我也不强留</p>
<a id="more"></a>
<p>跟以前相比，朋友走了<br>我老是会那么不习惯<br>会不想再重新交朋友<br>想着，<br>那样算是背叛</p>
<p>而如今<br>我变了<br>感觉像是那种没心没肺的了</p>
<p>朋友来<br>我还是要认真对待<br>用心去交<br>走后<br>就当是一段经历吧</p>
<p>总之<br>人生而孤独<br>走或来<br>结果都一样</p>
<p>或许也有不一样<br>就如你和我</p>
]]></content>
      
        <categories>
            
            <category> daily </category>
            
        </categories>
        
        
        <tags>
            
            <tag> daily </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux上安装python3]]></title>
      <url>/2017/10/11/python/2017-10-11-python-installPython3/</url>
      <content type="html"><![CDATA[<p>目的是安装在cento服务器上安装python3，实现python3和python2共存，因为linux系统中很多是依赖于python2，所以避免出错python2不能卸载。这就想到了防火墙iptables也不能卸载，之前折腾公司服务器差点把iptables卸了…<br>所以这里就安装python3与系统自带的python2共存</p>
<a id="more"></a>
<p>首先创建文件夹python3来存放安装文件，例如我在/usr/local/创建python3目录<br>这里我下载的是<code>Python-3.5.4.tar.xz</code>这个版本，将其上传到服务器<br>然后命令解压<br><code>sudo tar -xf Python-3.5.4.tar.xz</code><br>解压后<code>cd Python-3.5.4</code>进入解压目录<br>再运行命令<br><code>sudo ./configure --prefix=/usr/local/python3/</code><br>设定安装目录为<code>/usr/local/python3/</code>这个，运行之后它将检测源码，当然如果直接运行<code>sudo ./configure</code>也可以，默认也是安装到<code>/usr/local/</code>下</p>
<p>然后<br><code>sudo make</code><br>来构建源码<br>之后<br><code>sudo make install</code><br>才算安装</p>
<p>像这种源代码编译安装的方式，其卸载方法就是删除安装目录即可<br>之后<code>cd /usr/loca/python3/bin</code>中</p>
<p><code>sudo cp pip3 python3 /usr/bin/</code><br>将其复制到/usr/bin中，这样就可以直接使用<code>python3</code>命令来运行python3了，这样也就使得系统自带的python2和python3共存了。同时不过为方便管理，通</p>
<p>常也会将pip3复制到<code>/usr/bin/</code>下，这样安装python3的第三方包就使用pip3命令了</p>
<p>至于复制到<code>/usr/bin/</code>目录下而不复制到别的目录，例如<code>/bin</code>,<code>/usr/sbin/</code>….的原因，<br>网上搜到个解释感觉很ok，如下</p>
<p><code>/bin</code><br>是存放系统的一些指令。bin为binary的简写主要放置一些系统的必备执行档例如: cat、cp、chmod、df、dmesg、gzip、kill、ls、mkdir、more、mount、rm、su、tar等。</p>
<p><code>/sbin</code><br>一般是指超级用户指令。主要放置一些系统管理的必备程式例如: cfdisk、dhcpcd、dump、e2fsck、fdisk、halt、ifconfig、ifup、ifdown、init、insmod、lilo、lsmod、mke2fs、modprobe、quotacheck、reboot、rmmod、 runlevel、shutdown等。</p>
<p><code>/usr/bin</code><br>是用户在后期安装的一些软件的运行脚本。主要放置一些应用软体工具的必备执行档例如: c++、g++、gcc、chdrv、diff、dig、du、eject、elm、free、gnome、gzip、htpasswd、kfm、ktop、last、less、locale、m4、make、man、mcopy、ncftp、 newaliases、nslookup passwd、quota、smb、wget等。</p>
<p><code>/usr/sbin</code><br>放置一些用户安装的系统管理的必备程式例如: dhcpd、httpd、imap、in.*d、inetd、lpd、named、netconfig、nmbd、samba、sendmail、squid、swap、tcpd、tcpdump等。</p>
]]></content>
      
        <categories>
            
            <category> python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
            <tag> linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[python实现服务器监控脚本]]></title>
      <url>/2017/10/10/linux/2017-10-10-linux-serverMonitor/</url>
      <content type="html"><![CDATA[<p>这段时间都在写这个监控脚本，之前用shell写过一个，其实也可以用，但考虑到后期需要实现自动化运维，功能需要更加完善，于是就打算写一个python版的监控脚本</p>
<a id="more"></a>
<h3 id="脚本概况"><a href="#脚本概况" class="headerlink" title="脚本概况"></a>脚本概况</h3><p>分模块来总结，分为</p>
<ul>
<li>选择操作包</li>
<li>工具包</li>
<li>项目模块包</li>
</ul>
<p>目前完成的这个脚本文件中，其目录结构文件如下</p>
<p><img src="/images/linux/python-monitor-2.png" alt="python-monitor"></p>
<p><code>monitor.py</code> 脚本入口<br><code>monitorbin</code> 存放的operate.py这个文件及选择操作模块<br><code>monitorbin.util</code>存放四个工具模块<br><code>monitorbin.module</code> 存放需要监控的进程模块</p>
<h3 id="monitorbin包"><a href="#monitorbin包" class="headerlink" title="monitorbin包"></a>monitorbin包</h3><h4 id="operate-py"><a href="#operate-py" class="headerlink" title="operate.py"></a>operate.py</h4><p>选择操作模块，被<code>monitor.py</code>调用执行<br>其代码如下</p>
<pre><code>#!/usr/bin/python3
#coding=utf-8

from monitorbin.util.fileUtil import FileUtil
from monitorbin.module.tomcatCheck import TomcatOperate
from monitorbin.module.nginxCheck import NginxOperate
from monitorbin.module.redisCheck import RedisOperate
from monitorbin.util.emailUtil import EmailUtil

#author: cg错过
#time: 2017-09-30

class Operate:

    #选择执行操作类

    def __init__(self):

        self.fileUtil = FileUtil()

        dictNeedRunMsg = self.fileUtil.getNeedRunMsg()
        if(len(dictNeedRunMsg) &gt; 1):
            self.runProcess(dictNeedRunMsg)
            emailUtil = EmailUtil(dictNeedRunMsg, self.fileUtil)
        elif(len(dictNeedRunMsg) == 1):
            self.fileUtil.writerContent(&quot;配置文件参数值不全&quot;, &apos;runErr&apos;)
        else:
            self.fileUtil.writerContent(&quot;配置文件读取失败&quot;, &apos;runErr&apos;)


    def runProcess(self, dictNeedRunMsg):

        #运行检测各个项目

        listKeys = dictNeedRunMsg.keys()
        for keyItem in listKeys:
            if(keyItem.find(&apos;tomcat&apos;) != -1):
                strTomcatPath = dictNeedRunMsg.get(keyItem)
                tomcatOperate = TomcatOperate(strTomcatPath, self.fileUtil.strMinTime, self.fileUtil)
                #print(strTomcatPath)
            if(keyItem.find(&apos;nginx&apos;) != -1):
                strNginxPath = dictNeedRunMsg.get(keyItem)
                nginxOperate = NginxOperate(strNginxPath, self.fileUtil.strMinTime, self.fileUtil)
                #print(strNginxPath)
            if(keyItem.find(&apos;redis&apos;) != -1):
                strRedisPath = dictNeedRunMsg.get(keyItem)
                redisOperate = RedisOperate(strRedisPath, self.fileUtil.strMinTime, self.fileUtil)
                #print(strRedisPath)
</code></pre><p>其中实例化FileUtil这个模块类，调用类中的方法<code>getNeedRunMsg()</code>或许根据配置文件过滤得到需要检测系统所需要的数据，为dict字典类型。得到数据后进行判断，其中，当长度大于1即可认为该<code>dictNeedRunMsg</code>或许到的数据是完全的，当长度等于1时，该dict中存放的值为<code>dictNeedRunMsg={&#39;0&#39;: &#39;error&#39;}</code>,表示数据不全，即配置文件中缺少配置运行所需的数据，使运行中止，另外就是当<code>dictNeedRunMsg</code>长度为0时，即未成功读取到配置文件中的数据，当然这种情况到这一步是不会发送的，因为在此之前在FileUtil这个模块类中已经进行了判断。可以看下面FileUtil这个模块类</p>
<h3 id="monitorbin-util包"><a href="#monitorbin-util包" class="headerlink" title="monitorbin.util包"></a>monitorbin.util包</h3><h4 id="fileUtil-py"><a href="#fileUtil-py" class="headerlink" title="fileUtil.py"></a>fileUtil.py</h4><p>文件及部分数据处理类,在脚本运行中只能存在一个该对象<br>代码如下</p>
<pre><code>#!/usr/bin/python3
#coding=utf-8

import os
import xml.dom.minidom
import configparser
from monitorbin.util.sysTime import RunTime

#author: cg错过
#time: 2017-09-30

class FileUtil:

    #文件及部分数据处理类

    configurePath = &apos;conf&apos;
    configureFileName = &apos;monitor.conf&apos;

    def __init__(self):

        self.strLogPath = self.getLogPath()
        #strLogPath = self.getLogPath()
        self.setAttribute()

    def setAttribute(self):

        #设置一些属性

        runTime = RunTime()
        self.strDateTime = runTime.getDateTime()
        self.strHourTime = runTime.getHourTime()
        self.strMinTime = runTime.getMinTime()
        self.strHourMinTime = runTime.getHourMinTime()
        self.strNumSecondTime = runTime.getNumSecondTime()
        self.strNumHourTime = runTime.getNumHourTime()

        strlogContentSecondName = &quot;monitor_content-&quot; + self.strNumSecondTime + &quot;.txt&quot;
        strlogContentName = &quot;monitor_content-&quot; + self.strNumHourTime + &quot;.txt&quot;
        strlogErrName = &quot;monitor_err-&quot; + self.strNumHourTime + &quot;.txt&quot;
        strlogErrSecondName = &quot;monitor_err-&quot; + self.strNumSecondTime + &quot;.txt&quot;
        strRunErrName = &quot;err-&quot; + self.strNumSecondTime + &quot;.txt&quot;

        self.strlogContentSecondName = self.strLogPath + &apos;/&apos; + strlogContentSecondName
        self.strlogContentName = self.strLogPath + &apos;/&apos; + strlogContentName
        self.strlogErrName = self.strLogPath + &apos;/&apos; + strlogErrName
        self.strlogErrSecondName = self.strLogPath + &apos;/&apos; + strlogErrSecondName
        self.strRunErrPathName = self.strLogPath + &apos;/&apos; + strRunErrName


    def writerContent(self, strContent, strFileMark=&apos;Hour&apos;, whetherAdd=True):

        #strFileMark: 区分写入小时执行的文件还是分钟执行的文件
        #strContent: 写入文件的内容
        #whetherAdd: 是否在文件后面换行追加，默认True

        if(strFileMark == &apos;Hour&apos;):
            if(whetherAdd &amp; True):
                fileObj = open(self.strlogContentName, &apos;a&apos;)
                fileObj.write(strContent + &quot;\n&quot;)
                fileObj.close()
            else:
                fileObj = open(self.strlogContentName, &apos;w&apos;)
                fileObj.write(strContent)
                fileObj.close()
        elif(strFileMark == &apos;Second&apos;):
            if(whetherAdd &amp; True):
                fileObj = open(self.strlogContentSecondName, &apos;a&apos;)
                fileObj.write(strContent + &quot;\n&quot;)
                fileObj.close()
            else:
                fileObj = open(self.strlogContentSecondName, &apos;w&apos;)
                fileObj.write(strContent)
                fileObj.close()
        else:
            if(whetherAdd &amp; True):
                fileObj = open(self.strRunErrPathName, &apos;a&apos;)
                fileObj.write(strContent + &quot;\n&quot;)
                fileObj.close()
            else:
                fileObj = open(self.strRunErrPathName, &apos;w&apos;)
                fileObj.write(strContent)
                fileObj.close()

    def writerErr(self, strContent, strFileMark=&apos;Hour&apos;, whetherAdd=True):

        if(strFileMark == &apos;Hour&apos;):
            if(whetherAdd &amp; True):
                fileObj = open(self.strlogErrName, &apos;a&apos;)
                fileObj.write(&quot;\n&quot; + strContent)
                fileObj.close()
            else:
                fileObj = open(self.strlogErrName, &apos;w&apos;)
                fileObj.write(strContent)
                fileObj.close()
        else:
            if(whetherAdd &amp; True):
                fileObj = open(self.strlogErrSecondName, &apos;a&apos;)
                fileObj.write(&quot;\n&quot; + strContent)
                fileObj.close()
            else:
                fileObj = open(self.strlogErrSecondName, &apos;w&apos;)
                fileObj.write(strContent)
                fileObj.close()



    def getXMLTagElementValue(self, strFilePath, strTagName, strTagElementName, intTagIndex):

        #获取xml文件指定标签的内容，返回一个字符串值
        #self: 对象本身
        #strTagName: 标签名字
        #strTagElementName: 标签中的元素名字
        #intTagIndex: 文件中出现该标签的序列号(即第几个，从0开始)

        confObj = xml.dom.minidom.parse(strFilePath)

        documentElementObj = confObj.documentElement
        listElementItem = documentElementObj.getElementsByTagName(strTagName)
        #按照顺序存放，文件内容中第一个出现该标签名字的就放在集合的下标为0的位置
        tagElement = listElementItem[intTagIndex]
        strTagElementValue = tagElement.getAttribute(strTagElementName)
        print(strTagElementName + &quot;=&quot; + strTagElementValue)
        return strTagElementValue


    def getConfFileValue(self, configParserObj, configureFileNameAndPath):

        #获取conf后缀的配置文件内容，返回一个字典
        #注释了不读取，值为空会读取
        #configParserObj: 读取配置文件的对象
        #configureFileNameAndPath: 配置文件路径
        #读取写入的key名字全部小写

        dictConfMsg = {}
        intMark = self.checkFileExists(configureFileNameAndPath)
        if(intMark == 1):
            configParserObj.read(configureFileNameAndPath)
            try:
                listSectionName = configParserObj.sections()
            except:
                self.writerContent(&quot;读取配置文件出错&quot;, &apos;runErr&apos;)
            else:
                for sectionItem in listSectionName:
                    #print(sectionItem)
                    listKeyName = configParserObj.options(sectionItem)
                    #print(listKeyName)
                    sectionObj = configParserObj[sectionItem]
                    if(len(listKeyName) != 0):
                        for keyItem in  listKeyName:
                            valueItem = sectionObj[keyItem]
                            if(valueItem == None):
                                dictConfMsg[sectionItem] = listKeyName
                            else:
                                dictConfMsg[keyItem] = valueItem
                    else:
                        dictConfMsg[sectionItem] = &apos;&apos;
        #print(dictConfMsg)
        return dictConfMsg


    def readFileContent(self, inputFileName):

        #读取普通文件内容并返回

        fileObj = open(inputFileName, &apos;r&apos;)
        strFileContent = fileObj.read()
        fileObj.close()

        return strFileContent


    def initConfigureFile(self):

        #初始化配置文件

        strTomcatPath = &quot;/home/liying/dev/tomcat-7.0.73&quot;
        strNginxPath = &quot;/usr/local/nginx&quot;
        strRedisPath = &quot;/home/liying/dev/redis-2.8.24&quot;

        strServerName = &quot;116&quot;
        strUserName = &quot;林繁&quot;

        strLogPath = &quot;logs&quot;

        strSmtp_server = &quot;smtp.qq.com&quot;
        strEmail_sendAddr = &quot;yakult-cg@qq.com&quot;
        strEmail_sendPasswd = &quot;lscgsbnjddtgdegc&quot;

        strToEmail = &quot;1542723438@qq.com&quot;
        strToEmail2 = &quot;1732821152@qq.com&quot;

        strAuthor = &quot;cg错过&quot;
        strCreateTime = &quot;2017-09-30&quot;

        if not os.path.exists(self.configurePath):
            os.mkdir(self.configurePath)

        configureFileNameAndPath = self.configurePath + &apos;/&apos; + self.configureFileName

        config = configparser.ConfigParser(allow_no_value=True, delimiters=&apos;:&apos;)
        config.add_section(&apos;ProjectConfigure&apos;)
        config.add_section(&apos;UseConfigure&apos;)
        config.add_section(&apos;LogConfigure&apos;)
        config.add_section(&apos;EmailConfigure&apos;)
        config.add_section(&apos;ToEmail&apos;)
        config.add_section(&quot;Message&quot;)

        config.set(&apos;ProjectConfigure&apos;, &apos;tomcatpath&apos;, strTomcatPath)
        config.set(&apos;ProjectConfigure&apos;, &apos;nginxpath&apos;, strNginxPath)
        config.set(&apos;ProjectConfigure&apos;, &apos;redispath&apos;, strRedisPath)

        config.set(&apos;UseConfigure&apos;, &apos;servername&apos;, strServerName)
        config.set(&apos;UseConfigure&apos;, &apos;username&apos;, strUserName)

        config.set(&apos;LogConfigure&apos;, &apos;logpath&apos;, strLogPath)

        config.set(&apos;EmailConfigure&apos;, &apos;smtp_server&apos;, strSmtp_server)
        config.set(&apos;EmailConfigure&apos;, &apos;email_sendAddr&apos;, strEmail_sendAddr)
        config.set(&apos;EmailConfigure&apos;, &apos;email_sendPasswd&apos;, strEmail_sendPasswd)

        config.set(&apos;ToEmail&apos;, strToEmail)
        config.set(&apos;ToEmail&apos;, strToEmail2)

        config.set(&apos;Message&apos;, &apos;author&apos;, strAuthor)
        config.set(&apos;Message&apos;, &apos;createtime&apos;, strCreateTime)

        with open(configureFileNameAndPath, &apos;w&apos;) as configureFile:
            config.write(configureFile, space_around_delimiters=True)

        #print(&quot;done&quot;)


    def getNeedRunMsg(self):

        #根据配置文件的配置内容来选择代码执行
        #即从存放的字典中去除不需要检测运行的项目(未配置值的参数)，之后返回
        print(&quot;获取运行需要的配置数据&quot;)

        #fileUtil = FileUtil()
        dictNewConfMsg = {}
        dictConfMsg = self.readConfigureFile()
        intMark = self.checkConfMsg(dictConfMsg)
        if(intMark == 1):
            intTomcatMark = self.checkRunProject(&quot;tomcat&quot;, &quot;tomcatpath&quot;, dictConfMsg)
            if(intTomcatMark == 0):
                del dictConfMsg[&apos;tomcatpath&apos;]

            intNginxMark = self.checkRunProject(&quot;nginx&quot;, &quot;nginxpath&quot;, dictConfMsg)
            if((intNginxMark == 0)):
                del dictConfMsg[&apos;nginxpath&apos;]

            intRedisMark = self.checkRunProject(&quot;redis&quot;, &quot;redispath&quot;, dictConfMsg)
            if(intRedisMark == 0):
                del dictConfMsg[&apos;redispath&apos;]
            dictNewConfMsg = dictConfMsg
        elif(intMark == 0):
            dictNewConfMsg[&apos;0&apos;] = &apos;error&apos;


        print(&quot;需要运行的有&quot;)
        print(dictNewConfMsg)
        return dictNewConfMsg


    def readConfigureFile(self):

        #读取脚本配置文件
        dictConfMsgTotal = {}
        configureFileNameAndPath = self.configurePath + &apos;/&apos; + self.configureFileName
        self.checkAndInitConfigure(configureFileNameAndPath)
        config = configparser.ConfigParser(allow_no_value=True, delimiters=&apos;:&apos;)
        dictConfMsg = self.getConfFileValue(config, configureFileNameAndPath)
        dictConfMsgTotal.update(dictConfMsg)
        if(len(dictConfMsgTotal)  == 0):
            self.writerContent(&quot;未获取到配置文件内容&quot;, &apos;runErr&apos;)

        return dictConfMsgTotal

    def checkConfMsg(self, dictConfMsg):

        #检测配置文件是否完全
        #其中日志路径和email值必须存在
        #所以这里只检查logpath和email
        #email仅包括smtp_server, email_sendaddr, email_sendpasswd

        intMark = -1
        if(len(dictConfMsg) != 0):
            for keyItem in dictConfMsg:
                if((keyItem == &apos;logpath&apos;) | (keyItem == &apos;smtp_server&apos;) | (keyItem == &apos;email_sendaddr&apos;)
                  | (keyItem == &apos;email_sendpasswd&apos;)):
                    if(dictConfMsg.get(keyItem) == &apos;&apos;):
                        strErr = (&quot;未读取到%s配置参数的值，请修改配置文件&quot; %(keyItem))
                        self.writerContent(strErr, &apos;runErr&apos;)
                        intMark = 0
                        break
                    else:
                        intMark = 1
        else:
            self.writerContent(&quot;未读取到配置文件内容&quot;, &apos;runErr&apos;)
        return intMark



    def checkRunProject(self, projectName, strKey, dictConfMsg):

        #根据配置文件的配置，判断并选择代码块来执行
        #如果返回值为1，则表示返回允许执行检测projectName这个项目

        intMark = -1
        if(strKey in dictConfMsg):
            if(dictConfMsg.get(strKey) != &apos;&apos;):
                intMark = 1
            else:
                intMark = 0
                strErr = (&quot;未读取到%s配置参数,如需检测%s请修改配置文件&quot; %(projectName, projectName))
                self.writerContent(strErr, &apos;runErr&apos;)
        return intMark


    def checkFileExists(self, configureFileNameAndPath):

        #检测配置文件是否存在，不存在则返回-1

        intMark = -1
        if(os.path.exists(configureFileNameAndPath)):
            intMark = 1

        return intMark

    def checkAndInitConfigure(self, configureFileNameAndPath):

        #检测并初始化配置文件

        intMark = self.checkFileExists(configureFileNameAndPath)
        if(intMark != 1):
            print(&quot;配置文件monitor.conf不存在,脚本自动创建并初始化&quot;)
            print(&quot;配置文件monitor.conf路径为&quot; + self.configurePath + &quot;/&quot; + self.configureFileName)
            #self.writerContent(&quot;配置文件monitor.conf不存在,脚本自动创建并初始化&quot;, &apos;runErr&apos;)
            #strErr = (&quot;配置文件monitor.conf路径为&quot; + self.configurePath + &quot;/&quot; + self.configureFileName)
            #self.writerContent(strErr, &apos;runErr&apos;)
            self.initConfigureFile()

    def checkAndCreate(self, FileNameAndPath):

        #检测并创建日志文件路径

        intMark = self.checkFileExists(FileNameAndPath)
        if(intMark != 1):
            print(&quot;配置的日志文件夹路径不存在，脚本执行自动创建&quot;)
            #self.writerContent(&quot;配置的日志文件夹路径不存在，脚本执行自动创建&quot;, &apos;runErr&apos;)
            os.mkdir(FileNameAndPath)

    def getLogPath(self):

        #获取日志文件配置
        #需要运行的项目字典,即过滤完后的字典
        #dictConfMsg = self.getNeedRunMsg()
        #strLogPath = dictConfMsg.get(&apos;logpath&apos;)
        strLogPath = &apos;&apos;
        configureFileNameAndPath = self.configurePath + &apos;/&apos; + self.configureFileName
        self.checkAndInitConfigure(configureFileNameAndPath)
        config = configparser.ConfigParser(allow_no_value=True, delimiters=&apos;:&apos;)
        config.read(configureFileNameAndPath)
        if(config.has_section(&apos;LogConfigure&apos;)):
            strLogPath = config[&apos;LogConfigure&apos;][&apos;logpath&apos;]
            self.checkAndCreate(strLogPath)
        else:
            print(&quot;配置文件内容缺少日志配置参数&quot;)
            #self.writerContent(&quot;配置文件内容缺少日志配置参数&quot;, &apos;runErr&apos;)
        return strLogPath


    def reWriterForEmail(self, listSendContent, dictEmailMsg):

        #重构需要邮件发送的内容，并设置对应主题，并返回list
        #重构后的list数据集合格式：无错误日志list长度为3，有错误日志list长度为4
        #list[0]: Hour或者Second或者no
        #list[1]: 邮件主题
        #list[2]: 需要发送的邮件内容(已重构的内容)
        #list[3]: 错误日志的相对路径地址

        strNewContent = &apos;&apos;
        strContent = listSendContent[1]

        strServerName = &apos;none&apos;
        strUserName = &apos;cg&apos;
        for keyItem in dictEmailMsg:
            if((keyItem == &apos;servername&apos;) | (keyItem == &apos;username&apos;)):
                if(keyItem == &apos;servername&apos;):
                    strServerName = dictEmailMsg.get(&apos;servername&apos;)
                else:
                    strUserName = dictEmailMsg.get(&apos;username&apos;)
            else:
                continue

        strContentLine = &quot;====================&quot;

        strNewContent = strContent[:0] + strContentLine + &quot;\n&quot; + strContent[0:]
        strNewContent = (strNewContent + &quot;\n&quot; + strContentLine + &quot;\n&quot; + &quot;---&quot; +
                         strUserName + &quot;\n&quot; + &quot;---&quot; + self.strDateTime)

        listSendContent[1] = strNewContent
        if(listSendContent[0] == &apos;Hour&apos;):
            strSubject = strServerName + &quot;今日&quot; + self.strHourTime + &quot;时执行结果&quot;
            listSendContent.insert(1, strSubject)
        elif(listSendContent[0] == &apos;Second&apos;):
            strSubject = strServerName + &quot;今日&quot; + self.strHourMinTime + &quot;时检测到异常&quot;
            listSendContent.insert(1, strSubject)        

        else:
            strSubject = strServerName + &quot;脚本运行异常&quot;
            listSendContent.insert(1, strSubject)
        print(&quot;已重构......&quot;)
        print(listSendContent)
        return listSendContent
</code></pre><p>这个<code>fileUtil.py</code>文件中，功能包括配置文件的读取,判断,过滤以及日志文件的读取写入即邮件内容的操作，这是脚本的一个重要模块。写的时候本来时将文件处理和数据处理分开来写的，但写到中途又合并了，因为这是国庆放假前写的代码，国庆这8天假都没碰这代码，从昨天才开始继续写…..</p>
<h4 id="process-py"><a href="#process-py" class="headerlink" title="process.py"></a>process.py</h4><p>封装了调用了<code>subprocess.Popen</code>模块，实现python操作linux命令。通过python运行linux命令，截获两种输出<code>stdout</code>和<code>stderr</code>，在我看来这可分为有持续输出和无持续输出，区分这个时避免在持续输出时因存放量过大而发生阻塞，具体可参考<a href="http://www.firefoxbug.com/index.php/archives/2419/" target="_blank" rel="external">这篇文章</a>及<a href="https://docs.python.org/2/library/subprocess.html" target="_blank" rel="external">官方文档</a>,当然，这也有<a href="https://www.rddoc.com/doc/Python/3.6.0/zh/library/subprocess/?highlight=subprocess" target="_blank" rel="external">中文文档</a><br>代码如下</p>
<pre><code>#!/usr/bin/python3
#coding=utf-8

import subprocess

#author: cg错过
#time: 2017-09-30

class ProcessCL:

    #python操作Linux模块

    def getResultAndProcess(self, strCL):

        #
        #获取无持续输出的命令操作后的结果
        #获取正常输出和错误输出，存放到dict中返回
        #strCL: 操作的命令

        dictResult = {}
        strOut = &apos;&apos;
        strErr = &apos;&apos;
        subObj = subprocess.Popen(strCL, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True,
                                  universal_newlines=True)
        returnCode = subObj.poll()
        while returnCode is None:
            stdout, stderr = subObj.communicate()
            returnCode = subObj.poll()
            strOut += stdout
            strErr += stderr
        dictResult[&apos;stdout&apos;] = stdout
        dictResult[&apos;stderr&apos;] = stderr

        return dictResult


    def getContinueResultAndProcess(self, strCL):

        #获取有持续输出的程序的结果，将其分类(stdout和stderr)
        #但检测到无输出后就退出
        #strCL: 操作的命令

        strOut = &apos;&apos;
        strErr = &apos;&apos;
        dictResult = {}
        subObj = subprocess.Popen(strCL, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True,
                                  universal_newlines=True)
        returnCode = subObj.poll()
        while returnCode is None:
            lineOut = subObj.stdout.readline()
            lineErr = subObj.stdout.readline()
            returnCode = subObj.poll()
            lineOut = lineOut.strip()
            lineErr = lineErr.strip()

            strOut += lineOut
            strErr += lineErr
            if((lineOut == &apos;&apos;) | (lineErr == &apos;&apos;)):
                break

        dictResult[&apos;stdout&apos;] = strOut
        dictResult[&apos;stderr&apos;] = strErr

        return dictResult
</code></pre><p>上面的代码中，<code>getResultAndProcess()</code>这个方法虽然是针对无持续输出的命令，但依然是加上了<code>strOut += stdout</code>这个输出追加方式。因为如若不加这个，在当连续两次调用这个方法时，会出现bug，如下</p>
<pre><code>dictResult[&apos;stdout&apos;] = stdout
UnboundLocalError: local variable &apos;stdout&apos; referenced before assignment
</code></pre><p>即命令行执行时可能stdout和stderr都无值，都未给进行声明并赋值，所以导致后面添加到dict的时候就会出错，这个错误就是在变量赋值之前被引用</p>
<h4 id="emailUtil-py"><a href="#emailUtil-py" class="headerlink" title="emailUtil.py"></a>emailUtil.py</h4><p>邮件发送模块<br>代码如下</p>
<pre><code>#!/usr/bin/python3
#coding=utf-8

import sys
from smtplib import SMTP_SSL
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from email.header import Header

#author: cg错过
#time: 2017-09-30

class EmailUtil:

    #发送邮件模块

    def __init__(self, dictNeedRunMsg, fileUtilObj):

        #dictNeedRunMsg:存放从配置文件中读取到的数据，其数据是本次检测运行所需要的数据
        #fileUtilObj: FileUtil的对象(脚本从运行到结束都只有这一个FileUtil对象)
        #其中的key有
        #smtp_server:
        #mail_sendAddr:
        #mail_sendPasswd:
        #mail_toAddr:

        self.fileUtilObj = fileUtilObj
        dictEmailMsg = self.getForEmailMsg(dictNeedRunMsg)
        listEmailContentMsg = self.checkAndGetForEmailListMsg()

        strServerName = dictEmailMsg.get(&apos;servername&apos;)
        strUserName = dictEmailMsg.get(&apos;username&apos;)
        listNewEmailContentMsg = self.fileUtilObj.reWriterForEmail(listEmailContentMsg, dictEmailMsg)

        self.choiceSend(dictEmailMsg, listNewEmailContentMsg)

    def getForEmailMsg(self, dictNeedRunMsg):

        #将从配置文件的完全读取到的数据中，抽取出发送邮件需要的数据，存放为dict类型并返回
        #dictNeedRunMsg: 存放从配置文件中读取到的数据，其数据是本次检测运行所需要的数据
        #因为有可能并不是所有项目都配置了需要运行

        dictMsgForEmail = {}
        for keyItem in dictNeedRunMsg:
            if((keyItem == &apos;email_sendaddr&apos;) | (keyItem == &apos;email_sendpasswd&apos;) |
               (keyItem == &apos;smtp_server&apos;) | (keyItem == &apos;ToEmail&apos;) | (keyItem == &apos;logpath&apos;) |
               (keyItem == &apos;servername&apos;) | (keyItem == &apos;username&apos;)):
                dictMsgForEmail[keyItem] = dictNeedRunMsg.get(keyItem)

        return dictMsgForEmail

    def checkAndGetForEmailListMsg(self):

        #检查是否存在日志，并读取该日志进行返回
        #返回格式:如无错误日志list长度为2，有错误日志list长度为3
        #list[0]: Hour或者Second或者no
        #list[1]: 需要发送的邮件内容(仅运行日志)
        #list[2]: 错误日志的相对路径地址

        #产生的日志文件中，在每分钟和每小时的两种情况中，只会运行一种情况
        #也就是只会产生一个日志

        listSendContent = []
        intExistsContent = self.fileUtilObj.checkFileExists(self.fileUtilObj.strlogContentName)
        intExistsContentS = self.fileUtilObj.checkFileExists(self.fileUtilObj.strlogContentSecondName)
        if(intExistsContent == 1):
            listSendContent.append(&apos;Hour&apos;)
            print(self.fileUtilObj.strlogContentName)
            strContent = self.fileUtilObj.readFileContent(self.fileUtilObj.strlogContentName)
            listSendContent.append(strContent)

            intExistsErr = self.fileUtilObj.checkFileExists(self.fileUtilObj.strlogErrName)
            if(intExistsErr == 1):
                print(&quot;每小时，有错误，附件&quot;)
                listSendContent.append(self.fileUtilObj.strlogErrName)
            else:
                print(&quot;每小时，无错误&quot;)
        elif(intExistsContentS == 1):
            listSendContent.append(&apos;Second&apos;)
            print(self.fileUtilObj.strlogContentSecondName)
            strContentS = self.fileUtilObj.readFileContent(self.fileUtilObj.strlogContentSecondName)
            listSendContent.append(strContentS)

            intExistsErrS = self.fileUtilObj.checkFileExists(self.fileUtilObj.strlogErrSecondName)
            if(intExistsErrS == 1):
                print(&quot;每分钟，有错误，附件&quot;)
                listSendContent.append(self.fileUtilObj.strlogErrSecondName)
            else:
                print(&quot;每分钟，无错误&quot;)

        else:
            listSendContent.append(&apos;no&apos;)
            strContent = &quot;未产生日志文件&quot;
            self.fileUtilObj.writerContent(&quot;未产生日志文件&quot;, &apos;runErr&apos;)
            listSendContent.append(strContent)
        print(&quot;未重构......&quot;)
        print(listSendContent)

        return listSendContent


    def choiceSend(self, dictEmailMsg, listEmailContent):

        #选择发送类型(有无附件)
        #dictEmailMsg: 发送和接受邮件账户，及smtp服务器地址
        #listEmailContent: 发送的邮件内容，主题，附件

        strSmtpServer = dictEmailMsg.get(&apos;smtp_server&apos;)
        strSendAddr = dictEmailMsg.get(&apos;email_sendaddr&apos;)
        strPasswd = dictEmailMsg.get(&apos;email_sendpasswd&apos;)
        listToAddr = dictEmailMsg.get(&apos;ToEmail&apos;)
        strSubject = listEmailContent[1]
        strContent = listEmailContent[2]

        if(len(listEmailContent) == 3):
            if(listEmailContent[0] != &apos;no&apos;):
                self.sendEmailByString(strSmtpServer, strSendAddr, strPasswd,
                               listToAddr, strSubject, strContent)
            else:
                self.fileUtilObj.writerContent(&quot;邮件未发送&quot;, &apos;runErr&apos;)
        else:
            strErrFilePath = listEmailContent[3]
            self.sendEmailByStringAndFile(strSmtpServer, strSendAddr, strPasswd,
                               listToAddr, strSubject, strContent, strErrFilePath)

        #print(self.fileUtilObj.strlogContentSecondName)


    def sendEmailByString(self, strSmtpServer, strSendAddr, strPasswd,
                          listToAddr, strSubject, strContent):

        #用字符串来发送邮件
        #strSmtpServer: smtp服务器地址
        #strSendAddr: 邮件发送地址
        #strPasswd: 发送地址的登陆授权码
        #listToAddr: 接受邮件的地址，为list集合
        #strSubject: 邮件主题
        #strContent: 邮件内容字符串类型
        #message对象中的三个key(&apos;From&apos;,&apos;To&apos;,&apos;Subject&apos;)最好都要有，不然容易被识别为垃圾邮件

        #mail_port = &apos;465&apos;

        message = MIMEText(strContent, &quot;plain&quot;, &quot;utf-8&quot;)
        message[&apos;Subject&apos;] = Header(strSubject, &apos;utf-8&apos;)
        message[&apos;From&apos;] = Header(&apos;monitor&lt;%s&gt;&apos; % strSendAddr, &apos;utf-8&apos;)
        message[&apos;To&apos;] = Header(&apos;monitor.admin&apos;, &apos;utf-8&apos;)

        try:
            smtpObj = SMTP_SSL(strSmtpServer)
            #smtpObj.set_debuglevel(1)
            smtpObj.ehlo(strSmtpServer)
            smtpObj.login(strSendAddr, strPasswd)
            if(len(listToAddr) &gt; 0):
                smtpObj.sendmail(strSendAddr, listToAddr, message.as_string())
                smtpObj.quit()
            else:
                self.fileUtilObj.writerContent(&quot;接收邮件地址为空&quot;, &apos;runErr&apos;)
            #self.fileUtilObj.writerContent(&quot;邮件发送成功&quot;)
        except:
            print(sys.exc_info()[0])
            self.fileUtilObj.writerContent(&quot;邮件发送失败&quot;, &apos;runErr&apos;)


    def sendEmailByStringAndFile(self, strSmtpServer, strSendAddr, strPasswd,
                          listToAddr, strSubject, strContent, strErrFilePath):

        #发送有附件的邮件
        #strSmtpServer: smtp服务器地址
        #strSendAddr: 邮件发送地址
        #strPasswd: 发送地址的登陆授权码
        #listToAddr: 接受邮件的地址，为list集合
        #strSubject: 邮件主题
        #strContent: 邮件内容字符串类型
        #message对象中的三个key(&apos;From&apos;,&apos;To&apos;,&apos;Subject&apos;)最好都要有，不然容易被识别为垃圾邮件

        #mail_port = &apos;465&apos;

        message = MIMEMultipart()
        message[&apos;Subject&apos;] = Header(strSubject, &apos;utf-8&apos;)
        message[&apos;From&apos;] = Header(&apos;monitor&lt;%s&gt;&apos; % strSendAddr, &apos;utf-8&apos;)
        message[&apos;To&apos;] = Header(&apos;monitor.admin&apos;, &apos;utf-8&apos;)

        message.attach(MIMEText(strContent, &apos;plain&apos;, &apos;utf-8&apos;))

        annexFile = MIMEText(open(strErrFilePath, &apos;rb&apos;).read(), &apos;base64&apos;, &apos;utf-8&apos;)
        annexFile[&quot;Content-Type&quot;] = &apos;application/octet-stream&apos;
        annexFile[&quot;Content-Disposition&quot;] = &apos;attachment; filename=&quot;err_logs.txt&quot;&apos;
        message.attach(annexFile)

        try:
            smtpObj = SMTP_SSL(strSmtpServer)
            #smtpObj.set_debuglevel(1)
            smtpObj.ehlo(strSmtpServer)
            smtpObj.login(strSendAddr, strPasswd)
            if(len(listToAddr) &gt; 0):
                smtpObj.sendmail(strSendAddr, addrItem, message.as_string())
                smtpObj.quit()
            else:
                self.fileUtilObj.writerContent(&quot;接受邮件地址为空&quot;, &apos;runErr&apos;)
            #self.fileUtilObj.writerContent(&quot;附件邮件发送成功&quot;)
        except:
            print(sys.exc_info()[0])
            self.fileUtilObj.writerContent(&quot;附件邮件发送失败&quot;, &apos;runErr&apos;)
</code></pre><p>具体看代码中的注释即可</p>
<h4 id="sysTime-py"><a href="#sysTime-py" class="headerlink" title="sysTime.py"></a>sysTime.py</h4><p>时间模块<br>代码如下</p>
<pre><code>#!/usr/bin/python3
#coding=utf-8

import time

#author: cg错过
#time: 2017-09-30

class RunTime:

    #时间模块

    def getTime(self, strFormat):

        #按照格式获取时间

        nowTime = time.localtime()
        strFormatTime = time.strftime(strFormat, nowTime)
        return strFormatTime

    def getDateTime(self):
        return self.getTime(&quot;%Y-%m-%d %H:%M:%S&quot;)

    def getNumSecondTime(self):
        return self.getTime(&quot;%Y%m%d%H%M%S&quot;)

    def getNumHourTime(self):
        return self.getTime(&quot;%Y%m%d%H&quot;)

    def getMinTime(self):
        return self.getTime(&quot;%M&quot;)

    def getHourTime(self):
        return self.getTime(&quot;%H&quot;)

    def getHourMinTime(self):
        return self.getTime(&quot;%H%M&quot;)
</code></pre><h3 id="monitorbin-module包"><a href="#monitorbin-module包" class="headerlink" title="monitorbin.module包"></a>monitorbin.module包</h3><h4 id="tomcatCheck-py"><a href="#tomcatCheck-py" class="headerlink" title="tomcatCheck.py"></a>tomcatCheck.py</h4><p>tomcat检测模块<br>代码如下</p>
<pre><code>#!/usr/bin/python3
#coding=utf-8

import subprocess
import os
from monitorbin.util.process import ProcessCL

#author: cg错过
#time: 2017-09-30

class TomcatOperate:

    #tomcat检测模块
    #需要配合前面分时间段来运行
    #即至少要有个对tomcat进行所有全部的检测和部分检测两种功能
    #全检不提供脚本操作功能，例如自启。全检后不管是否正常都将发送邮件
    #部检提供自启，自启后只有检测到不正常才发送邮件

    def __init__(self, strTotalPath, intDateMin, fileUtilObj):

        #strTotalPath: tomcat的安装文件根目录的上一级目录
        #intDateMin: 当前运行脚本的分钟数
        #fileUtilObj: FileUtil的对象(脚本从运行到结束都只有这一个FileUtil对象)

        self.fileUtil = fileUtilObj
        self.intDateMin = intDateMin
        self.strTotalPath = strTotalPath
        #self.fileUtil.writerContent(&quot;你好&quot;)
        intCheckResult = self.fileUtil.checkFileExists(self.strTotalPath)
        if(intCheckResult == 1):
            self.checkTomcat()
        else:
            self.fileUtil.writerContent(&quot;配置的tomcat路径不存在&quot;, &apos;runErr&apos;)

    def checkTomcat(self):

        #检测tomcat

        strTomcatStatus = self.getTomcatStatus()
        dictTomcatMsg = self.getTomcatMsg(self.strTotalPath)
        listTomcatName = dictTomcatMsg.get(&apos;tomcatName&apos;)
        listTomcatPort = dictTomcatMsg.get(&apos;tomcatPort&apos;)
        listTomcatPath = dictTomcatMsg.get(&apos;tomcatPath&apos;)

        if(self.intDateMin == 30):
            for i in range(len(listTomcatPort)):
                intMark = self.checkTomcatStatusByPort(i, listTomcatName, listTomcatPort, strTomcatStatus)
                if(intMark == 1):
                    #print(&quot;查看日志&quot;)
                    #self.fileUtil.writerContent(&quot;查看日志&quot;)
                    self.checkTomcatLogStatusByTomcatName(i, listTomcatName, listTomcatPort)
        else:
            for i in range(len(listTomcatPort)):
                #print(i)
                intMark = self.checkTomcatStatusByPort(i, listTomcatName, listTomcatPort,
                                                       strTomcatStatus, &apos;Second&apos;)
                if(intMark != 1):
                    #print(&quot;重启&quot;)
                    self.tryStartTomcat(i, listTomcatPath, listTomcatName)


    def getTomcatStatus(self):

        #获取进程中的tomcat
        tomcatStatusCL = &quot;ps -ef | grep tomcat&quot;
        processCL = ProcessCL()
        dictResult = processCL.getResultAndProcess(tomcatStatusCL)
        strTomcatStatus = dictResult.get(&apos;stdout&apos;)
        return strTomcatStatus


    def checkTomcatStatusByPort(self, intIndex, listTomcatName, listTomcatPort, strTomcatStatus,
                                strFileMark=&apos;Hour&apos;):

        #检测tomcat是否运行，在运行返回1
        #intIndex: 要检测的tomcat所在dictTomcatMsg中tomcatName的下标
        #dictTomcatMsg: 存放tomcat文件名,端口号和对应路径,为字典类型包含列表

        intMark = -1

        #listTomcatName = dictTomcatMsg.get(&apos;tomcatName&apos;)
        #listTomcatPort = dictTomcatMsg.get(&apos;tomcatPort&apos;)

        if(strTomcatStatus.find(listTomcatName[intIndex]) != -1):
            intMark = 1
            if(strFileMark==&apos;Hour&apos;):
                self.fileUtil.writerContent((&quot;%s在运行&quot; %(listTomcatName[intIndex])), &apos;Hour&apos;, False)
            #else:
                #self.fileUtil.writerContent((&quot;%s在运行&quot; %(listTomcatName[intIndex])), &apos;Second&apos;)
        else:
            if(strFileMark==&apos;Hour&apos;):
                self.fileUtil.writerContent((&quot;%s未运行&quot; %(listTomcatName[intIndex])))
            else:
                self.fileUtil.writerContent((&quot;%s未运行&quot; %(listTomcatName[intIndex])), &apos;Second&apos;)
                #print(&quot;%s未运行&quot; %(listTomcatName[intIndex]))

        return intMark


    def checkTomcatLogStatusByTomcatName(self, intIndex, listTomcatName, listTomcatPort):

        #检测tomcat日志输出是否正常，正常返回1
        #intIndex: tomcat所在dictTomcatMsg中tomcatName的下标，一般检测在运行的tomcat
        #dictTomcatMsg: 存放tomcat文件名,端口号和对应路径,为字典类型包含列表

        intMark = 1

        #listTomcatName = dictTomcatMsg.get(&apos;tomcatName&apos;)
        #listTomcatPort = dictTomcatMsg.get(&apos;tomcatPort&apos;)
        strOperateTomcatPath = listTomcatPath[intIndex]

        checkLogCL = &quot;tail -n 200 &quot; + strOperateTomcatPath + &quot;/logs/catalina.out&quot;
        processCL = ProcessCL()
        dictResult = processCL.getResultAndProcess(checkLogCL)
        strOut = dictResult.get(&apos;stdout&apos;)
        if(strOut.find(&quot;exception&quot;) != -1):
            intMark = -1
            #print(&quot;%s日志输出异常&quot; %(listTomcatName[intIndex]))
            self.fileUtil.writerContent((&quot;%s日志输出异常&quot; %(listTomcatName[intIndex])))
        else:
            self.fileUtil.writerContent((&quot;%s日志输出正常&quot; %(listTomcatName[intIndex])))
            #print(&quot;%s日志输出正常&quot; %(listTomcatName[intIndex]))
            self.fileUtil.writerErr(strOut)
        return intMark



    def tryStartTomcat(self, intIndex, listTomcatPath, listTomcatName):

        #启动未运行的tomcat，启动成功返回1
        #intIndex: 未运行的tomcat所在dictTomcatMsg中tomcatName的下标
        #dictTomcatMsg: 存放tomcat文件名,端口号和对应路径，为字典类型包含列表

        intMark = -1

        #listTomcatPath = dictTomcatMsg.get(&apos;tomcatPath&apos;)
        #listTomcatName = dictTomcatMsg.get(&apos;tomcatName&apos;)
        #print(&quot;脚本尝试将其启动....&quot;)
        self.fileUtil.writerContent(&quot;脚本尝试将其启动....&quot;, &apos;Second&apos;)
        strOperateTomcatPath = listTomcatPath[intIndex]
        tryStartTomcatCL = strOperateTomcatPath + &quot;/bin/./catalina.sh start&quot;
        processCL = ProcessCL()
        dictResult = processCL.getResultAndProcess(tryStartTomcatCL)
        strOut = dictResult.get(&apos;stdout&apos;)
        strErr = dictResult.get(&apos;stderr&apos;)
        if(strOut != &apos;&apos;):
            if((strOut.find(&apos;Tomcat started&apos;) != -1) &amp; (strErr == &apos;&apos;)):
                #print(&quot;%s已被脚本启动成功&quot; %(listTomcatName[intIndex]))
                self.fileUtil.writerContent((&quot;%s已被脚本启动成功&quot; %(listTomcatName[intIndex])),
                                            &apos;Second&apos;)
                intMark = 1
            else:
                #print(&quot;脚本启动%s未成功,请手动启动&quot; %(listTomcatName[intIndex]))
                self.fileUtil.writerContent((&quot;脚本启动%s未成功,请手动启动&quot; %(listTomcatName[intIndex])),
                                            &apos;Second&apos;)
                self.fileUtil.writerErr(strErr, &apos;Second&apos;)
        else:
            #print(&quot;%s启动命令未执行&quot; %(listTomcatName[intIndex]))
            self.fileUtil.writerContent((&quot;%s启动命令未执行,请手动执行&quot; %(listTomcatName[intIndex])), &apos;Second&apos;)
            #print(strErr)
            self.fileUtil.writerErr(strErr, &apos;Second&apos;)
        return intMark


    def getTomcatMsg(self, strTotalPath):

        #根据存放多个tomcat的文件路径来查找多少个tomcat
        #获取tomcat安装文件的名称和对应的端口
        #通过读取tomcat配置文件，以此来获得端口号
        #返回一个字典，存放tomcat安装文件名和对应端口号

        dictTomcatMsg = {}
        listTomcatName = []
        listMsgName = os.listdir(strTotalPath)
        for item in listMsgName:
            nextPath = (strTotalPath + &apos;/&apos; +  item)
            if(os.path.isdir(nextPath)):
                confPath = (nextPath + &apos;/conf/server.xml&apos;)
                if((item.find(&quot;tomcat&quot;) != -1) &amp; (os.path.exists(confPath))):
                    listMsgName.remove(item)
                    listTomcatName.append(item)

        #fileUtil = FileUtil()
        listTomcatPort = []
        listTomcatPath = []
        for item in listTomcatName:
            nextPath = (strTotalPath + &apos;/&apos; +  item)
            confPath = (nextPath + &apos;/conf/server.xml&apos;)
            intItemPort = self.fileUtil.getXMLTagElementValue(confPath, &apos;Connector&apos;, &apos;port&apos;, 0)
            listTomcatPort.append(intItemPort)
            listTomcatPath.append(nextPath)

        dictTomcatMsg[&apos;tomcatName&apos;] = listTomcatName
        dictTomcatMsg[&apos;tomcatPort&apos;] = listTomcatPort
        dictTomcatMsg[&apos;tomcatPath&apos;] = listTomcatPath
        print(dictTomcatMsg)

        return dictTomcatMsg
</code></pre><p>这个tomcat检测模块中，可以比较自动识别tomcat安装个数及相对应的端口，操作xml配置文件的方法在fileUtil.py这个模块类中</p>
<h4 id="redisCheck-py"><a href="#redisCheck-py" class="headerlink" title="redisCheck.py"></a>redisCheck.py</h4><p>redis检测模块<br>代码如下</p>
<pre><code>#!/usr/bin/python3
#coding=utf-8

import os
from monitorbin.util.process import ProcessCL

#author: cg错过
#time: 2017-09-30

class RedisOperate:

    #redis检测模块

    def __init__(self, strRedisPath, intDateMin, fileUtilObj):

        #strRedisPath: redis的安装文件目录
        #intDateMin: 当前运行脚本的分钟数
        #fileUtilObj: FileUtil的对象(脚本从运行到结束都只有这一个FileUtil对象)

        self.fileUtil = fileUtilObj
        self.intDateMin = intDateMin
        self.strRedisPath = strRedisPath
        intCheckResult = self.fileUtil.checkFileExists(self.strRedisPath)
        if(intCheckResult == 1):
            self.checkRedis()
        else:
            self.fileUtil.writerContent(&quot;配置的redis路径不存在&quot;, &apos;runErr&apos;)

    def checkRedis(self):

        #每个小时检测一遍，不做操作
        #其他时候，当检测到未运行时，脚本尝试自启一次

        strRedisStatus = self.getRedisStatus()

        if(self.intDateMin == 30):
            self.checkRedisStatus(strRedisStatus)
        else:
            intMark = self.checkRedisStatus(strRedisStatus, &apos;Second&apos;)
            if(intMark == -1):
                self.tryStartRedis(self.strRedisPath)


    def getRedisStatus(self):

        #获取进程中的redis

        redisStatusCL = &quot;ps -ef | grep redis&quot;
        processCL = ProcessCL()
        dictResult = processCL.getResultAndProcess(redisStatusCL)
        strRedisStatus = dictResult.get(&apos;stdout&apos;)
        return strRedisStatus


    def checkRedisStatus(self, strRedisStatus, strFileMark=&apos;Hour&apos;):

        #判断redis是否运行

        intMark = -1
        strRedis = &quot;redis-server&quot;

        if(strRedisStatus.find(strRedis) != -1):
            #print(&quot;redis在运行&quot;)
            if(strFileMark==&apos;Hour&apos;):
                self.fileUtil.writerContent(&quot;redis在运行&quot;)
            intMark = 1
        else:
            if(strFileMark==&apos;Hour&apos;):
                self.fileUtil.writerContent(&quot;redis未运行&quot;)
            else:
                self.fileUtil.writerContent(&quot;redis未运行&quot;, &apos;Second&apos;)
            #print(&quot;redis未运行&quot;)
        return intMark


    def tryStartRedis(self, strRedisPath):

        #脚本启动redis

        intMark = -1
        #print(&quot;脚本尝试将其启动....&quot;)
        #print(strRedisPath)
        self.fileUtil.writerContent(&quot;脚本尝试将其启动....&quot;, &apos;Second&apos;)
        strStartRedisCL = strRedisPath + &quot;/src/./redis-server&quot;
        processCL = ProcessCL()
        dictResult = processCL.getContinueResultAndProcess(strStartRedisCL)
        strOut = dictResult.get(&apos;stdout&apos;)
        strErr = dictResult.get(&apos;stderr&apos;)
        if(strOut.find(&apos;redis.io&apos;) != -1):
            self.fileUtil.writerContent(&quot;redis已被脚本启动&quot;, &apos;Second&apos;)
            #print(&quot;redis已被脚本启动成功&quot;)
            intMark = 1
        else:
            #print(&quot;脚本启动redis未成功，请手动启动&quot;)
            self.fileUtil.writerContent(&quot;脚本启动redis未成功，请手动启动&quot;, &apos;Second&apos;)
            self.fileUtil.writerErr(strErr, &apos;Second&apos;)
            #print(strErr)
        return intMark
</code></pre><h4 id="nginxCheck-py"><a href="#nginxCheck-py" class="headerlink" title="nginxCheck.py"></a>nginxCheck.py</h4><p>nginx检测模块<br>代码如下</p>
<pre><code>#!/usr/bin/python3
#coding=utf-8

from monitorbin.util.process import ProcessCL

#author: cg错过
#time: 2017-09-30

class NginxOperate:

    #nginx检测模块

    def __init__(self, strNginxPath, intDateMin, fileUtilObj):

        #strNginxPath: nginx的安装目录
        #intDateMin: 当前运行脚本的分钟数
        #fileUtilObj: FileUtil的对象(脚本从运行到结束都只有这一个FileUtil对象)

        self.fileUtil = fileUtilObj
        self.intDateMin = intDateMin
        self.strNginxPath = strNginxPath
        intCheckResult = self.fileUtil.checkFileExists(self.strNginxPath)
        if(intCheckResult == 1):
            self.checkNginx()
        else:
            self.fileUtil.writerContent(&quot;配置的nginx路径不存在&quot;, &apos;runErr&apos;)

    def checkNginx(self):

        #每个小时检测一遍，不做操作
        #其他时候，当检测到未运行时，脚本尝试自启一次

        strNginxStatus = self.getNginxStatus()

        if(self.intDateMin == 30):
            self.checkNginxStatus(strNginxStatus)
        else:
             intMark = self.checkNginxStatus(strNginxStatus, &apos;Second&apos;)
             if(intMark == -1):
                 self.tryStartNginx(self.strNginxPath)



    def getNginxStatus(self):

        #获取进程中的nginx

        nginxStatusCL = &quot;ps -ef | grep nginx&quot;
        processCL = ProcessCL()
        dictResult = processCL.getResultAndProcess(nginxStatusCL)
        strNginxStatus = dictResult.get(&apos;stdout&apos;)
        return strNginxStatus


    def checkNginxStatus(self, strNginxStatus, strFileMark=&apos;Hour&apos;):

        #判断nginx是否运行

        intMark = -1
        strNginx = &quot;nginx:&quot;

        if(strNginxStatus.find(strNginx) != -1):
            #print(&quot;nginx在运行&quot;)
            intMark = 1
            if(strFileMark==&apos;Hour&apos;):
                self.fileUtil.writerContent(&quot;nginx在运行&quot;)
        else:
            if(strFileMark==&apos;Hour&apos;):
                self.fileUtil.writerContent(&quot;nginx未运行&quot;)
            else:
                self.fileUtil.writerContent(&quot;nginx未运行&quot;, &apos;Second&apos;)
            #print(&quot;nginx未运行&quot;)
        return intMark


    def tryStartNginx(self, strNginxPath):

        #脚本启动nginx

        intMark = -1
        self.fileUtil.writerContent(&quot;脚本尝试将其启动....&quot;, &apos;Second&apos;)
        strStartNginxCL = strNginxPath + &quot;/sbin/./nginx&quot;
        processCL = ProcessCL()
        dictResult = processCL.getResultAndProcess(strStartNginxCL)
        strErr = dictResult.get(&apos;stderr&apos;)
        if(strErr == &apos;&apos;):
            #print(&quot;nginx已被脚本启动&quot;)
            self.fileUtil.writerContent(&quot;nginx已被脚本启动&quot;, &apos;Second&apos;)
            intMark = 1
        else:
            #print(&quot;脚本启动nginx未成功，请手动启动&quot;)
            self.fileUtil.writerContent(&quot;脚本启动nginx未成功，请手动启动&quot;, &apos;Second&apos;)
            self.fileUtil.writerErr(strErr, &apos;Second&apos;)
            #print(strErr)
        return intMark
</code></pre><p>nginx和redis这两个检测模块代码比较类似</p>
<h3 id="monitor-conf"><a href="#monitor-conf" class="headerlink" title="monitor.conf"></a>monitor.conf</h3><p>配置文件内容字段如下</p>
<pre><code>[ProjectConfigure]
tomcatpath : tomcat安装目录的上一级目录，如果有多个tomcat,则为多个tomcat安装目录的上一级。需要这多个tomcat在同一目录下
nginxpath : nginx安装目录
redispath : redis安装目录

[UseConfigure]
servername : 服务器别称
username : 发送邮件用户名

[LogConfigure]
logpath : 存放日志文件的路径名,例如&apos;logpath :logs&apos;即将在本脚本根目录下创建logs文件夹来存放日志

[EmailConfigure]
smtp_server : smtp服务地址,例如&apos;smtp.qq.com&apos;
email_sendaddr : 发送邮件的邮箱账户
email_sendpasswd : 发送邮件的账户授权码

[ToEmail]
//在此处填写接受邮件的邮箱地址，可以为多个，例如如下
1732821152@qq.com
</code></pre><h3 id="定时执行实现"><a href="#定时执行实现" class="headerlink" title="定时执行实现"></a>定时执行实现</h3><p>现在的实现方式是使用linux上的crontab定时器来执行脚本<br>命令<br><code>sudo vim /etc/crontab</code><br>在其中添加<br><code>*/5 * * * * root /usr/bin/python3 /usr/scripts/python/automatic_monitor/monitor.py &gt;&gt; /var/log/monitor.py.log 2&gt;&amp;1</code><br>其代码的意思就是告诉crontab，这个脚本是每隔5分钟使用root身份，用<code>/usr/bin/</code>此路径下的python3命令来运行monitor.py这个脚本，并将脚本中的输出和脚本运行出错的输出写入到<code>/var/log/monitor.py.log这个文件中</code><br>使用这个方法会出现两个问题<br>1.编码问题<br>输出如下</p>
<pre><code>Traceback (most recent call last):
  File &quot;/usr/scripts/python/automatic_monitor/test.py&quot;, line 7, in &lt;module&gt;
    print(&quot;\u914d\u7f6e\u6587\u4ef6monitor.conf\u4e0d\u5b58\u5728,\u811a\u672c\u81ea\u52a8\u521b\u5efa\u5e76\u521d\u59cb\u5316&quot;)
UnicodeEncodeError: &apos;ascii&apos; codec can&apos;t encode characters in position 0-3: ordinal not in range(128)
</code></pre><p>这个问题很奇怪，使用命令行运行脚本就不会出现这个问题。gg<br>解决这个问题的方法是在<code>/etc/crontab</code>这个文件中添加字段<br><code>LANG=zh_CN.UTF-8</code><br>其原因就是crontab使用的环境变量配置文件并不是<code>/etc/profile</code>这个，而是使用自己的环境变量，即它自身的环境变量配置在就crontab这个文件中(文件内容开头部分)</p>
<p>2.这个问题是本身的脚本问题，脚本设定的配置文件路径是固定的，即脚本目录的根目录。如果在这个情况下，使用crontab来做定时任务，那么脚本自动创建的配置文件路径将不是脚本存放目录的根目录，而将是<code>/root</code>这个目录，因为是以root身份运行，所以也就是说，使用crontab这个定时器来运行脚本，那么脚本的工作目录将会是<code>/root</code>这个路径，其创建的配置文件夹路径将为<code>/root/conf</code>.<br>所以这需要在脚本上进行调整。</p>
<p>后面将对代码进行更改，将定时功能直接添加到脚本本身中。</p>
<p>目前脚本简单检测这三个项目的功能已经实现，后期只需要在进程模块包中进行添加模块，同是配置文件也需要更改<br>后面再写，慢慢维护。项目代码已经提交至github仓库中，<a href="https://github.com/cgstudios/createUtil-daily-me/tree/master/python/automatic_monitor/automatic_monitor-base" target="_blank" rel="external">这是里链接</a></p>
]]></content>
      
        <categories>
            
            <category> linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
            <tag> linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[柬埔寨笔记]]></title>
      <url>/2017/10/10/daily/2017-10-10-daily-cambodiaNote/</url>
      <content type="html"><![CDATA[<p>这是在柬埔寨时闲下来的时候记下的，用simplenote同步，想到一些就写了一些，慢慢积累着</p>
<p>先记今天的吧.<br>下午吃完饭回来，司机用手语问我是否可以去吃饭，我犹豫了会儿，那会儿我看了下时间是北京时间6点40多，我们下班时间是7点，我担心怕来不及，而且我也考虑到我没这个权利，但是我想我们或许可以晚点下班，只要我和新来这里的那个同事在位置上坐久点，负责人肯定也不会这么早走，然后我就跟他说yeah,yeah…ok,又说了一句七点半，自己没听懂后面一句，就那他的手机打开了计算器，我明白他的意思，然后我就在他手机上打出了7.30，说了句thankyou,就走了</p>
<a id="more"></a>
<div class="note default"><p>人为什么要有思想，要是没有思想多好，就不会胡思乱想了</p></div>
<div class="note default"><p>从毕业到现在，四个多月了。毕业之前，<br>现在的我也没啥大的抱负，做个无名小卒，平平淡淡的生活</p></div>
<div class="note default"><p>山高水长，天各一方，别来无恙</p></div>
<div class="note default"><p>我想，司机不干了的原因，应该是感觉到没有被在乎吧，<br>那些人，有谁会关心普通人的感受</p></div>
<div class="note default"><p>我实在想不通，为什么交不到永久在一起的朋友。</p></div>
<div class="note default"><p>我想去一个一过就都能过一辈子的地方，平平淡淡，无人知晓</p></div>
<div class="note default"><p>现在10月3号下午6点钟，今天一天都没吃东西，算是毕业以来第一次这么长时间。我不喜欢这样，毕业后我开始慢慢喜欢一个人住，跟同事住一起没什么意思，感觉就是多了个机器人，不仅吵还浪费空间</p></div>
<div class="note default"><p>有那么一个时候，突然发现其实上天是公平的，你抱怨自己的不幸说社会不公平，其实这只是你生活的那个社会不公平罢了，跳出这个社会，去进入另一个社会生活，然后你就会发现，有一些能力很强的人生活竟然是那么不容易……</p></div>
<div class="note default"><p>都说，你要有一个好听动人的故事才能被人们所记住</p></div>
<div class="note default"><p>有的时候其实也觉得人生挺有意思的，没钱就去挣钱，有点钱了就好好待自己和家人朋友，人生就是要来个经历。就比如那些有钱人，他们有钱，下半辈子都不用愁了，但还是会去挣钱，他们有点只是去经历，有的只是去尝试证明自己，都是为了经历</p></div>
<div class="note default"><p>真不能把钱看太重，看太重了人都会变</p></div>
<div class="note default"><p>自由民主   Freedom and democracy</p></div>
<div class="note default"><p>如果更能在意生活，诗和远方还是有的，主要是取决你自己对生活的理解</p></div>
<div class="note default"><p>人 生而孤独</p></div>
<div class="note default"><p>希望这世间所有的生命都能被温柔以待</p></div>
<p>10月9号。今天来了个司机，这里的负责人带司机来我这栋别墅，说让司机睡沙发，我觉得这很不仁义，都还有床位，还不让睡，况且司机要是睡眠不够，开车也不安全。上下铺，为什么不让司机睡床，让后我就跟负责人说了这些，但他的回话很让人无语，说是这边的司机都是这样，都睡沙发…..沃日，真特么可笑，然后用中文跟司机说，让司机待会儿2点30起来去公司接人..。负责人走后，我带司机给他介绍了下这边，用英语，司机懂一些英语，不过我英语很烂，说两句就得用翻译….聊完之后司机就去洗澡，然后我就去那栋还有床位的别墅里问，那会儿他们在喝酒，有两间是上下铺，上铺都空着，他俩一人一间…..去的时候负责人也在，我把想法睡了一通，负责人一点也不做声，就在那喝酒，其他人就敷衍了事的回绝了。停下来想想我也没那个权利，他们也没理由听我的建议，我进公司三个月，跟他们比，我只是新人。<br>实在是好笑，<br>最终还是没用，司机还是被安排睡沙发。<br>晚上跟司机聊了会儿天，很拘束，提行李过来那会儿，我帮忙开门，他以为我要出去就靠边站开来了，我就比了个双手在胸前合拢的手势，然后他把行李放下来也比了个这样的手势，我不知道这是不是这个国家的礼仪方式，这我只是因为看过boss做这个手势…<br>后面跟司机自我介绍后了解到，司机今年20岁，名字叫D，很简单的一个名字，我刚开始一直不能确定是不是，然后司机用手机打出了这个字符D。司机比我小一岁，还很年轻啊.上一个司机30岁左右，有个小女儿，上一次司机送我们回去的时候去拿午饭，他妻子撑着伞抱着他女儿，给司机送饭，递过饭后感觉还在叮嘱司机什么，司机一直点头。<br>感觉越卑微的人越不被别人所在意，上一个司机就是这么走的，不知道这个司机会不会这样.</p>
<p>10月14号我就可以走了</p>
]]></content>
      
        <categories>
            
            <category> daily </category>
            
        </categories>
        
        
        <tags>
            
            <tag> daily </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[centos搭建redis集群]]></title>
      <url>/2017/09/19/linux/2017-09-19-linux-redis-colony/</url>
      <content type="html"><![CDATA[<p>为一台服务器搭建redis集群，存在ssh外网ip与服务器内网ip。<br>redis集群最少需要6个节点，而我这只有一台服务器，所以6个节点都在这服务器上</p>
<a id="more"></a>
<p>这里就撤步骤，完整下来分这么几步<br>1.检查防火墙和端口<br>2.安装最基本的当个redis环境<br>3.集群配置</p>
<h3 id="检查防火墙和端口"><a href="#检查防火墙和端口" class="headerlink" title="检查防火墙和端口"></a>检查防火墙和端口</h3><p>系统是centos7,centos原本使用的防火墙是iptables，但在centos7版本以后就已经废弃了iptables,改用firewall-cmd了。由于公司前辈要求使用iptables，所以没办法只能跟着来</p>
<h4 id="iptables操作"><a href="#iptables操作" class="headerlink" title="iptables操作"></a>iptables操作</h4><p>安装iptables之前需要检查firewall-cmd的运行状况，如若firewall-cmd在运行，则需将其关闭<br>停止firewall命令<code>systemctl stop firewalld</code><br>禁止firewall开机启动<code>systemctl disable firewalld</code><br>安装iptables<br><code>yum -y install iptables-services</code></p>
<p>开发端口则输入下面命令来修改该文件<br><code>vim /etc/sysconfig/iptables</code><br>如开发8080端口，则在该文件中添加如下代码<br><code>-A INPUT -m state –state NEW -m tcp -p tcp –dport 8080 -j ACCEPT</code></p>
<p>之后重启iptables<br><code>systemctl restart iptables</code><br>并设置防火墙开机启动<br><code>systemctl enable iptables</code><br>同样查看iptables状态<br><code>service iptables status</code>或<code>systemctl status iptables</code></p>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>关闭防火墙<code>service iptables stop</code><br>启动防火墙<code>service iptables start</code><br>重启防火墙<code>service iptables restart</code><br>查看防火墙状态<code>service iptables status</code><br>永久关闭防火墙<code>chkconfig iptables off</code><br>永久关闭后启用<code>chkconfig iptables on</code></p>
<h3 id="安装基本的redis环境"><a href="#安装基本的redis环境" class="headerlink" title="安装基本的redis环境"></a>安装基本的redis环境</h3><p>安装redis之前文章提过，详情看这篇文章<a href="http://cgspace.date/2017/08/07/linux/2017-08-07-install-centos-server/" target="_blank" rel="external">搭建centos服务器</a></p>
<h3 id="集群配置"><a href="#集群配置" class="headerlink" title="集群配置"></a>集群配置</h3><h4 id="增添修改配置文件"><a href="#增添修改配置文件" class="headerlink" title="增添修改配置文件"></a>增添修改配置文件</h4><p>集群至少需要6个节点，所以就需要6个端口，<br>安装完redis后，在/home/xm6f/dev/目录下新建<code>redis_cluster</code>文件夹，之后在该文件夹中创建7000~70056个文件夹，并每个文件夹包含子文件夹logs<br>命令如下</p>
<pre><code>mkdir redis_cluster
mkdir -p 7000/logs 7001/logs 7002/logs 7003/logs 7004/logs 7005/logs
</code></pre><p>之后再将redis安装目录下的<code>redis.conf</code>这个文件分别拷贝到7000等文件夹下，之后为每个节点修改<code>redis.conf</code>这个文件<br>从上到下依次需要求改的内容如下</p>
<pre><code>bind 机器ip            #使用ifconfig命令获得的ip,有可能处于局域网
port 7000            #而后依次增加7001,7002....
daemonize yes        #后台运行
pidfile /var/run/redis_7000.pid        #而后依次增加7001,7002....
logfile &quot;/root/dev/redis_cluster/7000/logs/redis.log&quot;        #而后依次增加7001,7002....
dbfilename dump_7000.rdb            #而后依次增加7001,7002....
dir &quot;/root/dev/redis-3.2.4/src&quot;        #redis安装目录下的src
requirepass &quot;123456&quot;                #配置密码
appendonly yes
appendfilename &quot;appendonly_7000.aof&quot;
cluster-enabled yes                    #开启集群
cluster-config-file nodes-7000.conf
cluster-node-timeout 5000
</code></pre><p>修改完上面之后，还需在该文件末尾添加一行</p>
<pre><code>masterauth &quot;123456&quot;                #集群密码，与requirepass一样
</code></pre><p>这里需要注意的问题就是bind的值，bind的值最好是本机ip，使用icfonfig命令得到的ip。千万不要相信手头的ip，即用ssh连接linux的ip，有可能ssh连接的ip是外网ip，而此服务器有一个内网ip…..我今天配置的就是，一直启动不了。bing使用外网ip是，命令启动redis没反应，启动不了。浪费一天了一上午的时间…..</p>
<p>写个脚本来一次性启动6个节点的redis</p>
<h4 id="启动redis"><a href="#启动redis" class="headerlink" title="启动redis"></a>启动redis</h4><p>脚本代码</p>
<pre><code>cd /root/dev/redis-3.2.4/src
./redis-server ../../redis_cluster/7000/redis.conf &amp;
./redis-server ../../redis_cluster/7001/redis.conf &amp;
./redis-server ../../redis_cluster/7002/redis.conf &amp;
./redis-server ../../redis_cluster/7003/redis.conf &amp;
./redis-server ../../redis_cluster/7004/redis.conf &amp;
./redis-server ../../redis_cluster/7005/redis.conf &amp;
</code></pre><p>然后看redis运行情况，使用命令<code>ps -ef | grep redis</code><br>若输出如下</p>
<pre><code>[root@VM_176_139_centos shell]# ps -ef | grep redis
root      8833     1  0 15:12 ?        00:00:00 ./redis-server 10.104.176.139:7000 [cluster]
root      8834     1  0 15:12 ?        00:00:00 ./redis-server 10.104.176.139:7001 [cluster]
root      8835     1  0 15:12 ?        00:00:00 ./redis-server 10.104.176.139:7005 [cluster]
root      8836     1  0 15:12 ?        00:00:00 ./redis-server 10.104.176.139:7002 [cluster]
root      8837     1  0 15:12 ?        00:00:00 ./redis-server 10.104.176.139:7004 [cluster]
root      8838     1  0 15:12 ?        00:00:00 ./redis-server 10.104.176.139:7003 [cluster]
root      8863  6015  0 15:12 pts/6    00:00:00 grep --color=auto redis
</code></pre><p>注意redis的url，url需要是本机ip地址<br>只要这样，就可以进行下一步</p>
<h4 id="关闭redis"><a href="#关闭redis" class="headerlink" title="关闭redis"></a>关闭redis</h4><p>命令<br><code>pkill -9 redis</code><br>即可同时关闭这6个redis</p>
<h4 id="集群连接操作"><a href="#集群连接操作" class="headerlink" title="集群连接操作"></a>集群连接操作</h4><p>此时需要使用到redis安装目录src下的<code>redis-trib.rb</code>这个文件，这个文件是用ruby语言写的，所以需要安装ruby环境<br>运行命令<br><code>yum -y install ruby ruby-devel rubygems rpm-build</code><br>之后再使用gem来安装redis接口<br><code>gem install redis</code></p>
<p>注意<br>如果在执行使用gem安装redis是报</p>
<pre><code>ERROR:Error installing redis:redis requires Ruby version &gt;= 2.2.2
</code></pre><p>这个异常的话，这报的是版本异常，要求gem安装redis最低的ruby版本为2.2.2,而yum仓库中提供的版本为2.0,其解决方法可以去看<a href="http://blog.csdn.net/fengye_yulu/article/details/77628094" target="_blank" rel="external">这篇文章</a>。<br>上述步骤完成之后，使用命令</p>
<pre><code>./redis-trib.rb create --replicas 1 10.104.176.139:7000 10.104.176.139:7001 10.104.176.139:7002 10.104.176.139:7003 10.104.176.139:7004 10.104.176.139:7005
</code></pre><p>正常输出如下</p>
<pre><code>[root@VM_176_139_centos src]# ./redis-trib.rb create --replicas 1 10.104.176.139:7000 10.104.176.139:7001 10.104.176.139:7002 10.104.176.139:7003 10.104.176.139:7004 10.104.176.139:7005
&gt;&gt;&gt; Creating cluster
&gt;&gt;&gt; Performing hash slots allocation on 6 nodes...
Using 3 masters:
10.104.176.139:7000
10.104.176.139:7001
10.104.176.139:7002
Adding replica 10.104.176.139:7003 to 10.104.176.139:7000
Adding replica 10.104.176.139:7004 to 10.104.176.139:7001
Adding replica 10.104.176.139:7005 to 10.104.176.139:7002
M: 7fed05243fa5e8d44b04b3ef5b4b2d246a20bf85 10.104.176.139:7000
   slots:0-5460 (5461 slots) master
M: 3cb3569fb1efec5cdb5ec11f4ac863279a702bd9 10.104.176.139:7001
   slots:5461-10922 (5462 slots) master
M: 26e7e5c215ff685a06908da9418bb0d6145d2eb2 10.104.176.139:7002
   slots:10923-16383 (5461 slots) master
S: a2ebe312b7dbab29aa60c404e347e8570f598273 10.104.176.139:7003
   replicates 7fed05243fa5e8d44b04b3ef5b4b2d246a20bf85
S: a346f606aa0a1f2bd96c95b1831582f30aae04e2 10.104.176.139:7004
   replicates 3cb3569fb1efec5cdb5ec11f4ac863279a702bd9
S: 54d3fc53cde48495dcf709c1be03b483001bd873 10.104.176.139:7005
   replicates 26e7e5c215ff685a06908da9418bb0d6145d2eb2
Can I set the above configuration? (type &apos;yes&apos; to accept): yes   
&gt;&gt;&gt; Nodes configuration updated
&gt;&gt;&gt; Assign a different config epoch to each node
&gt;&gt;&gt; Sending CLUSTER MEET messages to join the cluster
Waiting for the cluster to join...
&gt;&gt;&gt; Performing Cluster Check (using node 10.104.176.139:7000)
M: 7fed05243fa5e8d44b04b3ef5b4b2d246a20bf85 10.104.176.139:7000
   slots:0-5460 (5461 slots) master
   1 additional replica(s)
S: a346f606aa0a1f2bd96c95b1831582f30aae04e2 10.104.176.139:7004
   slots: (0 slots) slave
   replicates 3cb3569fb1efec5cdb5ec11f4ac863279a702bd9
S: 54d3fc53cde48495dcf709c1be03b483001bd873 10.104.176.139:7005
   slots: (0 slots) slave
   replicates 26e7e5c215ff685a06908da9418bb0d6145d2eb2
M: 26e7e5c215ff685a06908da9418bb0d6145d2eb2 10.104.176.139:7002
   slots:10923-16383 (5461 slots) master
   1 additional replica(s)
M: 3cb3569fb1efec5cdb5ec11f4ac863279a702bd9 10.104.176.139:7001
   slots:5461-10922 (5462 slots) master
   1 additional replica(s)
S: a2ebe312b7dbab29aa60c404e347e8570f598273 10.104.176.139:7003
   slots: (0 slots) slave
   replicates 7fed05243fa5e8d44b04b3ef5b4b2d246a20bf85
[OK] All nodes agree about slots configuration.
&gt;&gt;&gt; Check for open slots...
&gt;&gt;&gt; Check slots coverage...
[OK] All 16384 slots covered.
[root@VM_176_139_centos src]# 
</code></pre><p>连接完成之后，就可以测试各个节点的连接情况了，这里先不撤…</p>
<h4 id="重新连接集群"><a href="#重新连接集群" class="headerlink" title="重新连接集群"></a>重新连接集群</h4><p>如果需要重新连接集群，那么就需要找到redis.conf配置文件中<br><code>dir &quot;/root/dev/redis-3.2.4/src&quot;</code><br>这个文件路径，并删除里面的带端口的文件，就是上面提到的配置方法中的文件<br>直接在该文件目录下运行命令</p>
<p><code>sudo rm appendonly_*.conf nodes-*.conf dump_*.rdb</code></p>
<p>引用: <a href="http://www.cnblogs.com/linjiqin/p/7451822.html" target="_blank" rel="external">Redis 3.2.4集群实战</a></p>
]]></content>
      
        <categories>
            
            <category> linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> linux </tag>
            
            <tag> redis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java使用Sunday算法来查找文件]]></title>
      <url>/2017/09/17/java/2017-09-17-java-SundayfindFile/</url>
      <content type="html"><![CDATA[<p>今天周末，出租屋无聊便来公司呆着。顺便看看Sunday算法<br>Sunday算法的查找匹配速率比KMP算法快，其匹配规则也简单易懂，其移动位数主要时参考与字符串中参加匹配的最末位字符的下一位字符，如果该字符并未在搜索串中出现，则将字符串指针移动到该字符的下一位字符，搜索串指针则归零，反之，如果参加匹配的最末位字符的下一位字符出现在搜索串中，则移动位数等于搜索串长度减去搜索串中第一次出现该字符的下标。</p>
<a id="more"></a>
<p>详情看末尾的引用，同样也谢谢这两篇文章的作者</p>
<h3 id="java实现代码"><a href="#java实现代码" class="headerlink" title="java实现代码"></a>java实现代码</h3><pre><code>public int sundaySearchStrByStr(String strTotal, String strSearch) {

    char charTotal [] = strTotal.toCharArray();
    char charSearch [] = strSearch.toCharArray();

    int t = 0;
    int s = 0;
    int existCount = 0;
    while(s &lt; charSearch.length &amp;&amp; t &lt; charTotal.length) {

        if(charSearch[s] == charTotal[t]) {

            if((s + 1) != charSearch.length) {
                s++;
                t++;
            }else {
                existCount++;
                if(charTotal.length - (t + 1) &gt;= charSearch.length) {
                    s = 0;
                    t++;
                }else {
                    break;
                }
            }
        }else {
            int num = t + charSearch.length;
            int index = -1;
            if(num &lt; charTotal.length) {

                for(int i = 0; i &lt; charSearch.length; i++) {
                    if(charTotal[num] == charSearch[i]) {
                        index = i;
                        break;
                    }
                }
                if(index != -1) {
                    t = t + (charSearch.length - index);
                    s = 0;

                }else {
                    t = num + 1;
                    s = 0;
                }
            }else {
                break;
            }
        }
        if(t &gt;= charTotal.length) {
            break;
        }
    }
    return existCount;

}
</code></pre><p>整个Sunday算法的核心代码即while循环里面的代码，这里主要需注意字符串指针移动时的溢出问题，添加的条件即代码中的<code>num &lt; charTotal.length</code>，满足此条件才能进行下一步，否则则跳出循环<br>另外，Sunday算法在while循环中多了一部for循环，其做的就是将那下一个字符与搜索串进行匹配，如果第一次就匹配成功，即break</p>
<h3 id="Sunday和KMP对比"><a href="#Sunday和KMP对比" class="headerlink" title="Sunday和KMP对比"></a>Sunday和KMP对比</h3><p>就拿之前写的KMP算法代码来对比</p>
<h4 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h4><p>如图<br><img src="/images/java/kmp-search.png" alt="java-KMP-searchFile"></p>
<h4 id="Sunday算法"><a href="#Sunday算法" class="headerlink" title="Sunday算法"></a>Sunday算法</h4><p>如图<br><img src="/images/java/sunday-search.png" alt="java-Sunday-searchFile"></p>
<p>所以总体来说，Sunday较KMP来说匹配速率更快，代码实现也更简单</p>
<p>引用:<br>1.<a href="http://wiki.jikexueyuan.com/project/kmp-algorithm/sunday.html" target="_blank" rel="external">扩展 2：Sunday 算法-从头到尾彻底理解 KMP-极客学院wiki</a><br>2.<a href="https://wenzhiquan.github.io/2016/05/28/java_pattern_string_match_sunday_algorithm/" target="_blank" rel="external">Sunday算法-温志泉博客</a></p>
]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> codeing </tag>
            
            <tag> java </tag>
            
            <tag> Sunday </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java使用KMP算法来查找文件]]></title>
      <url>/2017/09/15/java/2017-09-15-java-KMPfindFile/</url>
      <content type="html"><![CDATA[<p>接上一篇文章，依据字符串来查找文件。当时使用Python来实现的，没使用啥算法，也就算是暴力匹配，查找速率很是慢。所以这次是使用KMP算法来实现。<br>首先要先了解KMP算法，记得大学的时候老师有讲过这个算法，可惜自己没好好听…于是网上找资料，主要就是看末尾引用的那篇文章，想了解KMP的倒可以看这篇，谢谢这位博主</p>
<a id="more"></a>
<h3 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h3><p>KMP算法有两种实现<br>1.基于部分匹配值表的实现<br>2.基于next数组的实现</p>
<p>KMP算法的第一种实现方式需要基于部分匹配值表，其大部分时候匹配移动的位数就是根据这个部分匹配值表来操作的，所以部分匹配值表对于这种KMP算法来说是很重要的。<br>这里我只实现了第一种方式，另一种基于next的方式并没去折腾。<br>这两种实现所遵循原则都一样，即摆脱每次只移动一位的匹配规则。</p>
<h3 id="KMP算法移动位数情况"><a href="#KMP算法移动位数情况" class="headerlink" title="KMP算法移动位数情况"></a>KMP算法移动位数情况</h3><p>KMP算法的移动方式都是将字符串固定，移动搜索串<br>假设有两个数组，搜索串:<code>searchStr[]</code>和字符串:<code>totalStr[]</code>,分别用下表<code>s</code>和<code>t</code>表示<br>无论<code>t</code>的值是多少，在当<code>searchStr[0]</code>与<code>totalStr[t]</code>相等时，即意味着在totalStr中有一个字符与searchStr的第一个字符相同，此时就需要确认下一个字符是否与<code>searchStr[1]</code>相同，那么将此刻不移动位数，将指针<code>从totalStr[t]</code>移到<code>total[t+1]</code>,对比是否和<code>search[1]</code>是否相等，如果相同那就将指针继续往后移动，如果不相同就该移动位数了，即移动<code>searchStr[]</code>这个数组，对于具体需要移动多少位，我想，如果使用最死的方法就是一位一位的移，但这样太浪费时间和资源了，这个时候就需要用到部分匹配值表，其移动位数值的计算公式如下</p>
<p><code>移动位数 = 已经匹配的字符数 - 匹配不成功的字符数的上一位字符对应的部分匹配值</code></p>
<p>注意，这都是移动搜索串，使字符串的<code>t++</code><br>在前面的匹配都满足的时候，在当<code>searchStr[searchStr.length-1]</code>与<code>totalStr[t]</code>也相等时，即表示已经成功的在字符串中找着了搜索串，如果还需要继续匹配，即查找全部字符串，那么就需要将<code>searchStr[]</code>清零，<code>totalStr[]</code>下标<code>t+1</code>，继续匹配<br>当然，在继续匹配之前，可以判断下totalStr剩余的字符是否还够得完成一次匹配，如果不够，就可以直接跳出循环，结束匹配</p>
<h3 id="kmp算法代码实现"><a href="#kmp算法代码实现" class="headerlink" title="kmp算法代码实现"></a>kmp算法代码实现</h3><pre><code>while(s &lt; searchChar.length &amp;&amp; t &lt; totalChar.length) {
    if(searchChar[s] == totalChar[t]) {
        if((s + 1) != searchChar.length) {
            s++;                                //如果，且并为匹配完，即searchStr长度还有剩余
            t++;
        }else {
            existCount++;                        //如果searchStr已经全部匹配完成，则当前文件存在的总个数自加
            if((totalChar.length - (t + 1)) &gt;= searchChar.length) {
                s = 0;                            //如果totalStr剩余的字符个数比searchStr字符个数多，即足够还能再匹配
                t++;
            }else {
                break;                            //如果个数不够，不能完成一次匹配，则跳出循环
            }
        }
    }else if(s == 0){
        s = 0;                                    //如果是seasrchStr第一个字符成功匹配，则t自加,即searchStr移动一位。否则依据部分匹配表来移动位数
        t++;
    }else {
        s = s - (s - kmpTable[(s - 1)]);        //kmpTable是int类型的部分匹配值数组
    }
    if((t + 1) &gt;= totalChar.length) {            //如果totalStr下表达到了totalStr的总字符数，则跳出循环
        break;
    }
}
</code></pre><p>kmp算法大致类似，那么下面就需要知道部分匹配值表是如何通过代码得到的</p>
<h3 id="部分匹配值表代码"><a href="#部分匹配值表代码" class="headerlink" title="部分匹配值表代码"></a>部分匹配值表代码</h3><p>其规则是，首先进行第一次拆分，即将一个字符串拆分，从首部开始拆分。例如字符串<code>ABC</code>,将其拆分成<code>A</code>,<code>AB</code>,<code>ABC</code>三个字符串<br>之后再将这三个字符串分别进行前缀，后缀拆分，例如将<code>ABC</code>拆分得到的前缀为<code>A</code>,<code>AB</code>,拆分得到的后缀为<code>C</code>,<code>BC</code><br>然后就匹配<code>A</code>,<code>AB</code>和<code>C</code>,<code>BC</code>这四个字符串是否相等，如果有相等，则获取其字符串长度，如果有长度更待的字符串相等，则将前面获取的字符串长度替换成字符串长度更大的值<br>代码如下</p>
<pre><code>public int[] getKMPtable(String strInput) {

    /*
     * 获取kmp的部分匹配数值表
     * 但得先获取字符串所有可能长度的最大公告元素长度，将其存放到int数组中返回
     */

    int intTablesLength = strInput.length();
    int kmp_table [] = new int [intTablesLength];

    for(int i = 0; i &lt; strInput.length(); i++) {
        String strItem = strInput.substring(0, i + 1);
        int intMaxPublicNum = getMaxPublicNum(strItem);
        kmp_table [i] = intMaxPublicNum;
    }
    return kmp_table;

}


public int getMaxPublicNum(String strItem) {

    //获取前缀和后缀，并最终对比得到最大的公共元素长度,并返回

    int intMaxPublicNum = 0;
    int intItemLength = strItem.length();

    String strFront [] = new String [intItemLength - 1];
    String strBack [] = new String [intItemLength - 1];

    for(int i = 0; i &lt; intItemLength - 1; i++) {
        strFront[i] = strItem.substring(0, i + 1);
    }
    for(int i = intItemLength; i &gt; 1; i--) {
        strBack[intItemLength - i] = strItem.substring(i - 1, intItemLength);
    }

    int n = -1;
    for(int i = 0; i &lt; intItemLength - 1; i++) {
        if(strFront[i].equals(strBack[i])) {
            n = i;
        }
    }
    if(n != -1) {
        intMaxPublicNum = strFront[n].length();
    }
    return intMaxPublicNum;
}
</code></pre><p>上面代码中，方法<code>getKMPtable()</code>传入的参数即为搜索串，该方法将搜索串进行第一次拆分，将每一次拆分得到的字符串作为参数传入<code>getMaxPublicNum()</code>方法中，<code>getMaxPublicNum()</code>方法就是获取该字符串的最大公共字符串的长度，其做法就是将传入的字符串进行前缀后缀拆分，之后返回最大公共字符串长度，如果没有公共字符串则返回0<br>所有返回的最大公共字符串长度将被方法<code>getKMPtable()</code>操作存放到一个int类型的数组中，并最后返回这个数组<br>这个最大公共字符串长度对应的字符就是相同下表的搜索串的字符。</p>
<h3 id="java字符串搜索文件总体代码"><a href="#java字符串搜索文件总体代码" class="headerlink" title="java字符串搜索文件总体代码"></a>java字符串搜索文件总体代码</h3><pre><code>package com.cgtest.kmpsearch;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;
import java.util.Scanner;

/**
* @author cg
* time: 2017-09-15
* describe: use kmp algorithm to search files by string
*/

public class KMPsearchFile {

    public static void main(String [] args) {

        System.out.println(&quot;通过字符串来查找文件，使用全匹配的基于部分匹配表的KMP算法&quot;);
        Scanner scanner = new Scanner(System.in);
        while(true){
            System.out.println(&quot;请输入文件路径(&apos;q to exit&apos;) :&quot;);
            String strFilePath = scanner.nextLine();
            if(strFilePath.equals(&quot;q&quot;) || strFilePath.equals(&quot;Q&quot;)) {
                scanner.close();
                break;
            }else if(!strFilePath.equals(&quot;&quot;)){
                if(new File((strFilePath)).exists() &amp;&amp; true) {
                    System.out.println(&quot;请输入要查找的字符串 :&quot;);
                    String strSearch = scanner.nextLine();
                    if(strSearch.equals(&quot;q&quot;) || strSearch.equals(&quot;Q&quot;)) {
                        scanner.close();
                        break;
                    }else {

                        long startTime = System.currentTimeMillis();

                        KMPself kmpself = new KMPself();
                        int [] kmpTable = kmpself.getKMPtable(strSearch);

                        Map&lt;String, Object&gt; mapTotalFile = kmpself.kmpSearchFileByStr(strFilePath, strSearch, kmpTable);
                        double userTime = (System.currentTimeMillis() - startTime);
                        kmpself.showResult(mapTotalFile);
                        System.out.println(&quot;查找耗时:&quot; + (userTime)/1000 + &quot;s&quot;);
                        }

                    }
                }else {
                    System.out.println(&quot;文件路径&quot; + strFilePath + &quot;不存在&quot;);
                    continue;
                }
            }
        }

}


class KMPself{

    ArrayList&lt;File&gt; listFilesObj = null;

    @SuppressWarnings(&quot;unchecked&quot;)
    public void showResult(Map&lt;String, Object&gt; mapTotalFile) {

        ArrayList&lt;Object&gt; listMsg = (ArrayList&lt;Object&gt;) mapTotalFile.get(&quot;resultMsg&quot;);
        System.out.println(&quot;&lt;-----查找结果-----&gt;&quot;);
        System.out.println(&quot;查找路径为:&quot; + mapTotalFile.get(&quot;searchPath&quot;));
        System.out.println(&quot;查找的字符串为:&quot; + mapTotalFile.get(&quot;strSearch&quot;));
        if(listMsg == null || listMsg.size() == 0) {
            System.out.println(&quot;已扫描文件个数 :&quot; + mapTotalFile.get(&quot;fileNum&quot;));
            System.out.println(&quot;已扫描字符个数 :&quot; + mapTotalFile.get(&quot;totalCharNum&quot;));
            System.out.println(&quot;抱歉 , 未查找到相应文件&quot;);
        }else {
            System.out.println(&quot;包含该字符串的文件路径及详情如下 :&quot;);
            for(int i = 0; i &lt; listMsg.size(); i++) {
                Map&lt;String, Object&gt; mapItem = (Map&lt;String, Object&gt;) listMsg.get(i);
                System.out.println(&quot;文件&quot; + (i + 1) + &quot;路径 :&quot; + mapItem.get(&quot;filePath&quot;));
                System.out.println(&quot;出现该字符串的总数 :&quot; + mapItem.get(&quot;totalCount&quot;));
                System.out.println(&quot;出现该字符串的行数 :&quot; + mapItem.get(&quot;lineNum&quot;));
                System.out.println(&quot;行数对应的出现次数 :&quot; + mapItem.get(&quot;lineExistCount&quot;));
            }
            System.out.println(&quot;总查找文件个数 :&quot; + mapTotalFile.get(&quot;fileNum&quot;));
            System.out.println(&quot;总查找字符个数 :&quot; + mapTotalFile.get(&quot;totalCharNum&quot;));
            System.out.println(&quot;&lt;-----查找完成-----&gt;&quot;);
        }
    }


    public ArrayList&lt;File&gt; getFiles(String strFilePath) {

        if(listFilesObj == null) {
            listFilesObj = new ArrayList&lt;File&gt;();
        }

        File fileObj = new File(strFilePath);

        if(fileObj.isDirectory()) {
            File fileNextDir [] = fileObj.listFiles();
            for(File fileItem : fileNextDir) {
                if(fileItem.isDirectory()) {
                    getFiles(fileItem.getPath());
                }else {
                    listFilesObj.add(fileItem);
                }
            }
        }else {
            listFilesObj.add(fileObj);
        }
        return listFilesObj;
    }


    public Map&lt;String, Object&gt; kmpSearchFileByStr(String strFilePath, String strSearch, int kmpTable []) {

        /*
         * 使用kmp算法
         * 通过字符串搜索文件，将搜索到的结果封装到map，list混合集合中，并最终返回一个map集合
         */

        ArrayList&lt;File&gt; listFilesObj = getFiles(strFilePath);

        Map&lt;String, Object&gt; mapTotalFile = new HashMap&lt;String, Object&gt;();
        ArrayList&lt;Object&gt; listMsg = new ArrayList&lt;Object&gt;();
        int fileNum = 0;
        long totalCharNum = 0;

        for(File listItem : listFilesObj) {
            Map&lt;String, Object&gt; mapFile = new HashMap&lt;String, Object&gt;();
            ArrayList&lt;Integer&gt; listLineNum = new ArrayList&lt;Integer&gt;();
            ArrayList&lt;Integer&gt; listLineExistCount = new ArrayList&lt;Integer&gt;();
            int lineNum = 1;
            int existCount = 0;
            int totalCount = 0;
            try {
                BufferedReader buffererReader = new BufferedReader(new FileReader(listItem));
                String strLine = null;
                while((strLine = buffererReader.readLine()) != null) {
                    existCount = kmpSearchStrByStr(strLine, strSearch, kmpTable);
                    if(existCount != 0) {
                        listLineNum.add(lineNum);
                        listLineExistCount.add(existCount);
                    }
                    totalCharNum += strLine.length();
                    totalCount += existCount;

                    lineNum++;
                }
                buffererReader.close();
                if(totalCount != 0) {
                    mapFile.put(&quot;filePath&quot;, listItem);
                    mapFile.put(&quot;totalCount&quot;, totalCount);
                    mapFile.put(&quot;lineNum&quot;, listLineNum);
                    mapFile.put(&quot;lineExistCount&quot;, listLineExistCount);
                }
                if( mapFile.size() != 0) {
                    listMsg.add(mapFile);
                }

            } catch (FileNotFoundException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            } catch (IOException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
            fileNum++;
        }
        if(listMsg.size() != 0) {
            mapTotalFile.put(&quot;resultMsg&quot;, listMsg);
        }
        mapTotalFile.put(&quot;searchPath&quot;, strFilePath);
        mapTotalFile.put(&quot;strSearch&quot;, strSearch);
        mapTotalFile.put(&quot;fileNum&quot;, fileNum);
        mapTotalFile.put(&quot;totalCharNum&quot;, totalCharNum);

        return mapTotalFile;
    }


    public int kmpSearchStrByStr(String totalStr, String strSearch, int kmpTable []) {
        /*
         * 参数1为内容字符串
         * 参数2为输入的搜索字符串即搜索串
         * 参数3为输入的搜索字符串的部分匹配数值表，为int类型的一维数组
         * 全匹配的基于部分匹配表的KMP算法
         * 并不是基于next数组
         * 
         * 其返回值是当前字符串中有出现搜索串的个数
         * 此时并无下标
         * 
         */
        char searchChar [] = strSearch.toCharArray();
        char totalChar [] = totalStr.toCharArray();

        int s = 0;
        int t = 0;
        //int index = -1;
        int existCount = 0;
        while(s &lt; searchChar.length &amp;&amp; t &lt; totalChar.length) {
            if(searchChar[s] == totalChar[t]) {
                if((s + 1) != searchChar.length) {
                    s++;
                    t++;
                }else {
                    existCount++;
                    if((totalChar.length - (t + 1)) &gt;= searchChar.length) {
                        s = 0;
                        t++;
                    }else {
                        break;
                    }
                }
            }else if(s == 0){
                s = 0;
                t++;
            }else {
                s = s - (s - kmpTable[(s - 1)]);
            }
            if((t + 1) &gt;= totalChar.length) {
                break;
            }
        }
        return existCount;

    }



    public int[] getKMPtable(String strInput) {

        /*
         * 获取kmp的部分匹配数值表
         * 但得先获取字符串所有可能长度的最大公告元素长度，将其存放到int数组中返回
         */

        int intTablesLength = strInput.length();
        int kmp_table [] = new int [intTablesLength];

        for(int i = 0; i &lt; strInput.length(); i++) {
            String strItem = strInput.substring(0, i + 1);
            int intMaxPublicNum = getMaxPublicNum(strItem);
            kmp_table [i] = intMaxPublicNum;
        }
        return kmp_table;

    }


    public int getMaxPublicNum(String strItem) {

        //获取前缀和后缀，并最终对比得到最大的公共元素长度,并返回

        int intMaxPublicNum = 0;
        int intItemLength = strItem.length();

        String strFront [] = new String [intItemLength - 1];
        String strBack [] = new String [intItemLength - 1];

        for(int i = 0; i &lt; intItemLength - 1; i++) {
            strFront[i] = strItem.substring(0, i + 1);
        }
        for(int i = intItemLength; i &gt; 1; i--) {
            strBack[intItemLength - i] = strItem.substring(i - 1, intItemLength);
        }

        int n = -1;
        for(int i = 0; i &lt; intItemLength - 1; i++) {
            if(strFront[i].equals(strBack[i])) {
                n = i;
            }
        }
        if(n != -1) {
            intMaxPublicNum = strFront[n].length();
        }
        return intMaxPublicNum;
    }


}
</code></pre><p>同时，我也对原先写的python代码进行了修改，使用KMP算法</p>
<h3 id="python实现KMP算法代码"><a href="#python实现KMP算法代码" class="headerlink" title="python实现KMP算法代码"></a>python实现KMP算法代码</h3><p>其python实现的KMP算法核心代码如下</p>
<pre><code>def kmpSearchStrByStr(totalStr, strSearch, kmpTable):

    #kmp算法查找
    #返回字符串中包含搜索串的个数

    listSearch = list(strSearch)
    listTotal = list(totalStr)

    s = 0
    t = 0
    existCount = 0
    while((s &lt; len(listSearch)) &amp; (t &lt; len(listTotal))):
        if(listSearch[s] == listTotal[t]):
            if((s + 1) != len(listSearch)):
                s+=1
                t+=1
            else:
                existCount+=1
                if((len(listTotal) - (t + 1)) &gt;= len(listSearch)):
                    s = 0
                    t+=1
                else:
                    break;
        elif(s == 0):
            s = 0
            t+=1
        else:
            s = s - (s - kmpTable[(s - 1)])
        if((t + 1) &gt;= len(listTotal)):
            break
    #print(existCount)
    return existCount



def getKMPtable(strSearch):

    #获取kmp的部分匹配数值表
    #但得先获取字符串所有可能长度的最大公告元素长度，将其存放到int数组中返回

    intTablesLength = len(strSearch)
    kmpTable = []

    for i in range(intTablesLength):
        strItem = strSearch[0 : i + 1]
        intMaxPublicNum = getMaxPublicNum(strItem)
        kmpTable.append(intMaxPublicNum)

    #print(kmpTable)
    return kmpTable


def getMaxPublicNum(strItem):

    #获取前缀和后缀，并最终对比得到最大的公共元素长度,并返回

    intMaxPublicNum = 0
    intItemLength = len(strItem)

    listFront = []
    listBack = []

    for i in range(intItemLength - 1):
        listFront.append(strItem[0 : i + 1])

    for i in range(intItemLength, 1, -1):
        listBack.append(strItem[i - 1 : intItemLength])

    n = -1
    for i in range(intItemLength - 1):
        if(listFront[i] == listBack[i]):
            n = i
    if(n != -1):
        intMaxPublicNum = len(listFront[n])

    #print(intMaxPublicNum)
    return intMaxPublicNum
</code></pre><h3 id="python和java搜索对比"><a href="#python和java搜索对比" class="headerlink" title="python和java搜索对比"></a>python和java搜索对比</h3><p>python实现的字符串搜索文件和java实现的字符串搜索文件，其运行速率对比还是很明显，估计问题就在python对文件编码格式上面，如图</p>
<p><img src="/images/java/python-java-kmp-searchFile.png" alt="java-python-KMP-searchFile"></p>
<p>速率相差太大，估计就是代码的问题<br>java代码同样也是臃肿…..</p>
<p>引用: <a href="http://blog.csdn.net/sunnyyoona/article/details/44004563" target="_blank" rel="external">算法系列之二十六–字符串匹配之KMP算法</a></p>
]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> codeing </tag>
            
            <tag> java </tag>
            
            <tag> python </tag>
            
            <tag> KMP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python通过字符串查找包含该字符串的文件]]></title>
      <url>/2017/09/12/python/2017-09-12-python-findFilesByStr/</url>
      <content type="html"><![CDATA[<p>无聊很可怕，上班无聊也是一样。今天上班无聊翻自己做的笔记看，但是笔记太多，所以我就只想看包含一些已知内容的笔记，但又不知道存放在哪里，苦逼实在系统windows，要是linux直接用命令很快就找出来了，于是就打算用python写个脚本，顺便回顾一下python,好久没用了</p>
<a id="more"></a>
<h3 id="实现描述"><a href="#实现描述" class="headerlink" title="实现描述"></a>实现描述</h3><p>根据字符串查找，使用的是re模块中的findall方法，属于精确匹配，这样使得查找很尴尬，需要输入很准确的字符才能查找到文件，模糊匹配并没有去做，现在做的只要是为了实现我这很简单的需求….，通过精确匹配，将匹配结果未true的进行存放到字典中，并最终存放到列表中进行返回，之后直接遍历得到的列表来显示查找得到的结果<br>其中有一点，就是文件编码问题，由于笔记包含了各种字符，存放的编码格式有utf-8,ascii,gb2312等，所以再open的时候不能统一编码，所以这里是用chardet先判断下编码格式，然后返回给open使用</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>这里贴代码</p>
<pre><code>import re
import os
import sys
import time
import chardet

#describe: find files by string
#author: cg

def main():
    print(&quot;查找出该路径下所有包含此字符串的文件路径&quot;)
    while True:
        print(&quot;请输入文件路径(&apos;q to exit&apos;) :&quot;)
        inputFilePath = input(&apos;&gt;&apos;)
        if (inputFilePath == &apos;q&apos;) or (inputFilePath == &apos;Q&apos;):
            break
        elif inputFilePath != &quot;&quot;:
            if os.path.exists(inputFilePath):
                print(&quot;请输入要查找的字符串 :&quot;)
                inputStr = input(&apos;&gt;&apos;)
                if (inputStr == &apos;q&apos;) or (inputStr == &apos;Q&apos;):
                    break
                startTime = time.time()
                resultList = searchStr(inputStr, inputFilePath)
                useTime = round((time.time() - startTime), 4)
                showResult(resultList)
                print(&quot;查找所耗时间 %s s&quot; %useTime)
                print(&quot;&lt;-----查找完成-----&gt;&quot;)
                print(&apos;&apos;)
            else:
                print(&quot;文件路径[%s]不存在&quot; %(inputFilePath))
                continue

def searchStr(str1, path):
    listTotalFile = []
    dictTotalMsg = {}
    totalFile = 0
    for rootPathStr, dirNameLists, fileNameLists in os.walk(path, True):
        for fileName in fileNameLists:
            filePath = os.path.join(rootPathStr, fileName)
            fileEncoding = getFileEncode(filePath)
            with open(filePath, &apos;r&apos;, encoding=fileEncoding) as fileObj:
                totalNum = 0
                lineNum = 0
                dictTotal = {}
                listItemLine = []
                listItemCount = []
                while True:
                    try:
                        line = fileObj.readline()
                        lineNum += 1
                        if line:
                            resultList = re.findall(str1, line)
                            if len(resultList) &gt; 0:
                                totalNum += len(resultList)
                                listItemLine.append(lineNum)
                                listItemCount.append(len(resultList))
                        else:
                            break
                    except Exception:
                        print(&quot;error:&quot;)
                        print(&quot;&lt;&lt;&quot; + filePath + &quot;读取失败 &gt;&gt;&quot;)
                        continue

                if totalNum &gt; 0:
                    dictTotal[&apos;filePath&apos;] = filePath
                    dictTotal[&apos;totalCount&apos;] = totalNum
                    dictTotal[&apos;detailLine&apos;] = listItemLine
                    dictTotal[&apos;detailCount&apos;] = listItemCount
                    listTotalFile.append(dictTotal)
        totalFile += (len(fileNameLists))
    dictTotalMsg[&apos;findPath&apos;] = path
    dictTotalMsg[&apos;findStr&apos;] = str1
    dictTotalMsg[&apos;totalFileNum&apos;] = totalFile
    dictTotalMsg[&apos;msg&apos;] = listTotalFile
    return dictTotalMsg

def getFileEncode(filePath):
    with open(filePath, &apos;rb&apos;) as fileObj:
        data = fileObj.read()
        fileDataDict = chardet.detect(data)
        return fileDataDict.get(&apos;encoding&apos;)

def showResult(dictTotalMsg):
    listMsg = dictTotalMsg.get(&apos;msg&apos;)
    print(&quot;&lt;-----查找结果-----&gt;&quot;)
    print(&quot;查找路径为: %s&quot; %(dictTotalMsg.get(&apos;findPath&apos;)))
    print(&quot;查找的字符串为: %s&quot; %(dictTotalMsg.get(&apos;findStr&apos;)))
    if len(listMsg) &gt; 0:
        print(&quot;包含该字符串的文件路径及详情如下 :&quot;)
    else:
        print(&quot;抱歉 , 未查找到相应文件&quot;)
    for i in range(len(listMsg)):
        print(&quot;文件%s路径 : %s&quot; %((i + 1), listMsg[i].get(&apos;filePath&apos;)))
        print(&quot;出现该字符串的总数 : %s&quot; %(listMsg[i].get(&apos;totalCount&apos;)))
        print(&quot;出现该字符串的行数 : %s&quot; %(listMsg[i].get(&apos;detailLine&apos;)))
        print(&quot;行数对应的出现次数 : %s&quot; %(listMsg[i].get(&apos;detailCount&apos;)))
    print(&quot;总查找文件个数 : %s&quot; %(dictTotalMsg.get(&apos;totalFileNum&apos;)))


if __name__ == &apos;__main__&apos;:
    main()
</code></pre><p>代码不多，也就100行，当然，功能也非常简单。</p>
<h3 id="运行示例"><a href="#运行示例" class="headerlink" title="运行示例"></a>运行示例</h3><p><img src="/images/python/python-searchByStr.png" alt="python-hwEncryption"></p>
<p>看上面输出，还是有编码问题…..</p>
]]></content>
      
        <categories>
            
            <category> python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> codeing </tag>
            
            <tag> python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用shell脚本监控服务器项目运行]]></title>
      <url>/2017/09/01/linux/2017-09-01-linux-shell-monitor/</url>
      <content type="html"><![CDATA[<p>之前写过一个每天定时对nginx日志文件进行切割的脚本，并在切割之后通过发送邮件来告知脚本执行是否成功。实现起来很简单，本来不想写，但前辈让一定要写，写就写吧，反正无聊。就是写完脚本后就更无聊了…<br>这次也还是一样的，需要写一个脚本来监控服务器中的各种服务，tomcat,redis,nginx,磁盘空间，jdk…没错，还说要监控jdk…..</p>
<a id="more"></a>
<p>不多说了，本来语文就差，组词这么粗糙。</p>
<p>先说下，现在这个脚本应该算是还有两个bug,后面慢慢解决。</p>
<p>正文</p>
<h3 id="脚本大致功能"><a href="#脚本大致功能" class="headerlink" title="脚本大致功能"></a>脚本大致功能</h3><p>1.脚本每间隔5分钟运行一次，检测各个系统模块运行是否正常，如若运行不正常，脚本先自行处理一次，如果处理后该服务仍然未正常运行，则发邮件提醒。正常则无提醒<br>2.在脚本没5分钟运行的情况下，每间隔1个小时(24h)，脚本会对服务器中的所有已经监控的模块状态进行汇总，并发邮件通知</p>
<p>脚本已经提供监控代码的服务就这三项，tomcat,redis和nginx，外加个磁盘根目录信息(无自动清理功能)</p>
<h3 id="脚本大致流程"><a href="#脚本大致流程" class="headerlink" title="脚本大致流程"></a>脚本大致流程</h3><h4 id="匹配项目是否运行"><a href="#匹配项目是否运行" class="headerlink" title="匹配项目是否运行"></a>匹配项目是否运行</h4><p>就拿tomcat来说，脚本通过命令<br>‘ps -ef | grep tomcat’<br>来查看进程中运行的tomcat，将输出结果进行模糊匹配，这里的模糊匹配只是匹配对应tomcat安装目录的文件夹名称<br>例如运行该命令的输出如下</p>
<pre><code>[xm6f@localhost automatic]$ ps -ef | grep tomcat
root      1503     1  0 8月29 ?       00:11:29 //bin/java -Djava.util.logging.config.file=/usr/local/tomcat/tomcat-8082/conf/logging.properties -Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager -server -Xms512m -Xmx4096m -Djdk.tls.ephemeralDHKeySize=2048 -Djava.endorsed.dirs=/usr/local/tomcat/tomcat-8082/endorsed -classpath /usr/local/tomcat/tomcat-8082/bin/bootstrap.jar:/usr/local/tomcat/tomcat-8082/bin/tomcat-juli.jar -Dcatalina.base=/usr/local/tomcat/tomcat-8082 -Dcatalina.home=/usr/local/tomcat/tomcat-8082 -Djava.io.tmpdir=/usr/local/tomcat/tomcat-8082/temp org.apache.catalina.startup.Bootstrap start
xm6f     10126     1  0 12:59 pts/5    00:01:34 /usr/local/java/jdk1.8.0_144/bin/java -Djava.util.logging.config.file=/usr/local/tomcat/lotmall-8080/conf/logging.properties -Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager -server -Xms512m -Xmx4096m -Djdk.tls.ephemeralDHKeySize=2048 -Djava.endorsed.dirs=/usr/local/tomcat/lotmall-8080/endorsed -classpath /usr/local/tomcat/lotmall-8080/bin/bootstrap.jar:/usr/local/tomcat/lotmall-8080/bin/tomcat-juli.jar -Dcatalina.base=/usr/local/tomcat/lotmall-8080 -Dcatalina.home=/usr/local/tomcat/lotmall-8080 -Djava.io.tmpdir=/usr/local/tomcat/lotmall-8080/temp org.apache.catalina.startup.Bootstrap start
xm6f     12173     1  1 14:26 pts/7    00:00:54 /usr/local/java/jdk1.8.0_144/bin/java -Djava.util.logging.config.file=/usr/local/tomcat/mango-8081/conf/logging.properties -Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager -server -Xms512m -Xmx4096m -Djdk.tls.ephemeralDHKeySize=2048 -Djava.endorsed.dirs=/usr/local/tomcat/mango-8081/endorsed -classpath /usr/local/tomcat/mango-8081/bin/bootstrap.jar:/usr/local/tomcat/mango-8081/bin/tomcat-juli.jar -Dcatalina.base=/usr/local/tomcat/mango-8081 -Dcatalina.home=/usr/local/tomcat/mango-8081 -Djava.io.tmpdir=/usr/local/tomcat/mango-8081/temp org.apache.catalina.startup.Bootstrap start
xm6f     13681  7589  0 15:39 pts/7    00:00:00 grep --color=auto tomcat
</code></pre><p>根据上面的输出，可以看到运行了三台tomcat,三台tomcat分别对应的安装目录的路径即上面输出中的<code>Dcatalina.base</code>这个变量的值，对比这三台tomcat的<code>Dcatalina.base</code>的值，可以知道这三台tomcat的安装文件都是存放在<code>/usr/local/tomcat/</code>这个路径下的，虽然这是安装时刻意弄的，但这样毕竟更好管理，对应写脚本也更方便。在这个路径下，存放的三个文件夹就是对应的三台tomcat安装文件，所以根据这些输出，可以进行模糊匹配来辨别当个tomcat是否运行<br>主要实现代码如下</p>
<pre><code>TOMCAT_STATUS=$(ps -ef | grep tomcat)
if [[ $TOMCAT_STATUS =~ &quot;8080&quot; ]]
then
    createEmail_content &quot;* tomcat8080---已在运行&quot; -h 1
    TOMCAT_1_LOG=$(tail -n 150 /usr/local/tomcat/tomcat-8080}/logs/catalina.out)
    if [[ $TOMCAT_1_LOG =~ &quot;exception&quot; ]]
    then
        createEmail_content &quot;---日志输出异常&quot; -h
        createEmail_errContent &quot;===============149-8080-输出日志===============&quot; -h
        createEmail_errContent &quot;$TOMCAT_1_LOG&quot; -h
    else
        createEmail_content &quot;---日志输出正常&quot; -h
    fi
else
    createEmail_content &quot;* tomcat$8080---未运行&quot; -h
fi
</code></pre><p>在知道tomcat是否运行之后，就可以对日志的输出进行解析了，以此来判断该tomcat运行时的日志输出是否正常，当然，如果tomcat未运行就不必对日志文件进行分析了。<br>判断日志输出是否正常的方式和判断tomcat是否运行的方式其理念是一样的，如上面的代码，获取8080端口的那台tomcat的文件末尾的150行，150行足够了，全屏下来也就50+行，获取这些输出之后同样拿来进行模糊匹配，观察之前的日志报错输出，里面都会有<code>exception</code>这个字段，匹配它就可以了，如果为结果为<code>true</code>，则说明日志报错了。<br>在知道tomcat是否正常运行及日志输出是否正常之后，将结果写入到txt文件，方便后面发送邮件，也方便记录<br>相对应的，判断nginx和redis是否运行也是通过这样的方式，这里就不说了</p>
<h4 id="查看磁盘空间"><a href="#查看磁盘空间" class="headerlink" title="查看磁盘空间"></a>查看磁盘空间</h4><p>查看磁盘使用空间最简单的命令就是<code>df</code>命令，使用<code>df -h</code>就可以知道所有挂载点的空间使用量，获取根目录挂载点命令就如<code>df -h /</code>,其输出有6列，拿要获取第5列就用命令<br><code>df -h / | awk &#39;{print $5}&#39;</code><br>其输出如下</p>
<pre><code>[xm6f@localhost automatic]$ df -h / | awk &apos;{print $5}&apos;
已用%
1%
[xm6f@localhost automatic]$ 
</code></pre><p>1%不大好对比，我想得到的是单纯的数字，但这个也不好截取，那就网上搜，例如我这里搜索得到的例如<br><code>df -h | grep /dev/mapper/cl-root | awk &#39;{print $5}&#39; | cut -f 1 -d &quot;%&quot;</code><br>这里的<code>/dev/mapper/cl-root</code>是根挂载点对应的文件系统的输出<br>整个命令运行输出如下</p>
<pre><code>[xm6f@localhost automatic]$ df -h | grep /dev/mapper/cl-root | awk &apos;{print $5}&apos; | cut -f 1 -d &quot;%&quot;
1
[xm6f@localhost automatic]$
</code></pre><p>这就ok了，这样运行得到结果之后直接放到if语句中进行对比，大于50%就发邮件提醒，就行了</p>
<h3 id="脚本函数介绍"><a href="#脚本函数介绍" class="headerlink" title="脚本函数介绍"></a>脚本函数介绍</h3><h4 id="写入内容到txt文件函数"><a href="#写入内容到txt文件函数" class="headerlink" title="写入内容到txt文件函数"></a>写入内容到txt文件函数</h4><p>因为总是需要写入内容到文件，总是一味的使用<code>echo</code>命令感觉太麻烦了，索性就封装成方法，后面调用即可<br>就如下面的代码，定义了两个函数，一个用来写记录执行错误输出的文件，一个用来写反馈结果到文件的方法<br>代码如下</p>
<pre><code>function createEmail_content() {
    if [[ $2 = -h ]]
    then
        if [[ $3 -eq 0 ]]
        then
            echo &quot;$1&quot; &gt;&gt; email_content-${TODAY_H}.txt
        else
            echo -e &quot;$1\c&quot; &gt;&gt; email_content-${TODAY_H}.txt
        fi
    else
        if [[ $3 -eq 0 ]]
        then
            echo &quot;$1&quot; &gt;&gt; email_content-${TODAY_HMS}.txt
        else
            echo -e &quot;$1\c&quot; &gt;&gt; email_content-${TODAY_HMS}.txt
        fi
    fi
}

function createEmail_errContent() {
        if [[ $2 = -h ]]
        then
                if [[ $3 -eq 0 ]]
                then
                        echo &quot;$1&quot; &gt;&gt; email_err-${TODAY_H}.txt
                else
                        echo -e &quot;$1\c&quot; &gt;&gt; email_err-${TODAY_H}.txt
                fi
        else
                if [[ $3 -eq 0 ]]
                then
                        echo &quot;$1&quot; &gt;&gt; email_err-${TODAY_HMS}.txt
                else
                        echo -e &quot;$1\c&quot; &gt;&gt; email_err-${TODAY_HMS}.txt
                fi
        fi
}
</code></pre><p>简单的介绍下上面代码，总共可以输入三个参数</p>
<ul>
<li>$1:文本内容</li>
<li>$2:写入到隔1小时执行结果的文件还是写入到隔5分钟执行结果的文件</li>
<li>$3:写入是否换行</li>
</ul>
<h4 id="重启函数"><a href="#重启函数" class="headerlink" title="重启函数"></a>重启函数</h4><p>不多说了</p>
<pre><code>function startTomcat() {
    ${1}/bin/./catalina.sh start
    if [[ $? -eq 0 ]]
    then
        createEmail_content &quot;**--&gt;脚本已对tomcat${2}执行启动命令&quot;
    else
        createEmail_content &quot;**--&gt;脚本未成功对tomcat${2}执行命令&quot;
    fi
    START_TOM_RESULT=$(ps -ef | grep tomcat)
    if [[ $START_TOM_RESULT =~ &quot;$2&quot; ]]
    then
        createEmail_content &quot;**--&gt;tomcat${2}已成功启动&quot;
    else
        createEmail_content &quot;**--&gt;tomcat${2}启动未成功，请手动启动&quot;
    fi    
}
</code></pre><h4 id="1小时执行函数"><a href="#1小时执行函数" class="headerlink" title="1小时执行函数"></a>1小时执行函数</h4><p>其中包括检测tomcat，redis，nginx和磁盘根目录使用情况<br>后面打算把这个方法拆分开了，代码太臃肿了</p>
<pre><code>function automatic_h() {

    echo &quot;&quot; &gt; email_content-${TODAY_H}.txt

    createEmail_content &quot;${COMPUTER_NAME}今日${HOUR}时脚本自动执行结果&quot; -h
    createEmail_content &quot;======================================&quot; -h

    TOMCAT_STATUS=$(ps -ef | grep tomcat)

    if [[ $TOMCAT_STATUS =~ &quot;$PORT_1&quot; ]]
    then
        createEmail_content &quot;* tomcat${PORT_1}---已在运行&quot; -h 1
        TOMCAT_1_LOG=$(tail -n 150 ${TOMCAT_DIR}/${PORT_1_FILENAME}/logs/catalina.out)
        if [[ $TOMCAT_1_LOG =~ &quot;exception&quot; ]]
        then
            createEmail_content &quot;---日志输出异常&quot; -h
            createEmail_errContent &quot;===============${COMPUTER_NAME}-${PORT_1}-输出日志===============&quot; -h
            createEmail_errContent &quot;$TOMCAT_1_LOG&quot; -h
        else
            createEmail_content &quot;---日志输出正常&quot; -h
        fi
    else
        createEmail_content &quot;* tomcat${PORT_1}---未运行&quot; -h

    fi

    if [[ $TOMCAT_STATUS =~ &quot;$PORT_2&quot; ]]
    then
            createEmail_content &quot;* tomcat${PORT_2}---已在运行&quot; -h 1
            TOMCAT_2_LOG=$(tail -n 150 ${TOMCAT_DIR}/${PORT_2_FILENAME}/logs/catalina.out)
            if [[ $TOMCAT_2_LOG =~ &quot;exception&quot; ]]
            then
                    createEmail_content &quot;---日志输出异常&quot; -h
                    createEmail_errContent &quot;===============${COMPUTER_NAME}-${PORT_2}-输出日志===============&quot; -h
                    createEmail_errContent &quot;$TOMCAT_2_LOG&quot; -h
            else
                    createEmail_content &quot;---日志输出正常&quot; -h
            fi
    else
            createEmail_content &quot;* tomcat${PORT_2}---未运行&quot; -h

    fi

    if [[ $TOMCAT_STATUS =~ &quot;$PORT_3&quot; ]]
    then
            createEmail_content &quot;* tomcat${PORT_3}---已在运行&quot; -h 1
            TOMCAT_3_LOG=$(tail -n 150 ${TOMCAT_DIR}/${PORT_3_FILENAME}/logs/catalina.out)
            if [[ $TOMCAT_3_LOG =~ &quot;exception&quot; ]]
            then
                    createEmail_content &quot;---日志输出异常&quot; -h
                    createEmail_errContent &quot;===============${COMPUTER_NAME}-${PORT_3}-输出日志===============&quot; -h
                    createEmail_errContent &quot;$TOMCAT_3_LOG&quot; -h
            else
                    createEmail_content &quot;---日志输出正常&quot; -h
            fi
    else
            createEmail_content &quot;* tomcat${PORT_3}---未运行&quot; -h
    fi

    REDIS_STATUS=$(ps -ef | grep 6379)
    if [[ $REDIS_STATUS =~ &quot;redis-server&quot; ]]
    then
        createEmail_content &quot;* redis已在运行&quot; -h
    else
        createEmail_content &quot;* redis未运行&quot; -h
    fi

    NGINX_STATUS=$(ps -ef | grep nginx)
    if [[ $NGINX_STATUS =~ &quot;nginx:&quot; ]]
    then
        createEmail_content &quot;* nginx已在运行&quot; -h
    else
        createEmail_content &quot;* nginx未运行&quot; -h
    fi

    #DISK_GEN_STATUS=$(df -h | grep /dev/m | awk &apos;{print $5}&apos;)
    #createEmail_content &quot;根目录使用量为$DISK_GEN_STATUS&quot;

    DISK_GEN_STATUS=$(df -h | grep $GEN_FILE_TYPE | awk &apos;{print $5}&apos; | cut -f 1 -d &quot;%&quot;)
    if [[ $DISK_GEN_STATUS -lt 50 ]]
    then
        createEmail_content &quot;* 根目录使用量较小---已使用${DISK_GEN_STATUS}%&quot; -h
    else
        createEmail_content &quot;* 根目录使用量较大---已使用${DISK_GEN_STATUS}%&quot; -h
    fi


    echo -e &quot;\n\n&quot; &gt;&gt; email_content-${TODAY_H}.txt

    createAll_tail -h
}
</code></pre><h4 id="5分钟执行函数"><a href="#5分钟执行函数" class="headerlink" title="5分钟执行函数"></a>5分钟执行函数</h4><p>这个方法和前面的方法大致一样，是上面方法的缩减版</p>
<pre><code>function automatic_hms() {

    TOMCAT_STATUS=$(ps -ef | grep tomcat)

    if [[ $TOMCAT_STATUS =~ &quot;$PORT_1&quot; ]]
    then
        TOMCAT_1_LOG=$(tail -n 150 ${TOMCAT_DIR}/${PORT_1_FILENAME}/logs/catalina.out)
        TOMCAT_1_DIR=${TOMCAT_DIR}/${PORT_1_FILENAME}
        if [[ $TOMCAT_1_LOG =~ &quot;exception&quot; ]]
        then
            createEmail_content &quot;* tomcat${PORT_1}---已运行---但日志输出异常&quot;
            createEmail_errContent &quot;===============${COMPUTER_NAME}-${PORT_1}-输出日志===============&quot;
            createEmail_errContent &quot;$TOMCAT_1_LOG&quot;
        fi
    else
        createEmail_content &quot;* tomcat${PORT_1}---未运行&quot;
                createEmail_content &quot;**--&gt;脚本将尝试进行启动....&quot;
                if [[ -x &quot;${TOMCAT_DIR}/${PORT_1_FILENAME}&quot; ]]
                then
                        startTomcat ${TOMCAT_DIR}/${PORT_1_FILENAME} ${PORT_1}
                else
                        createEmail_content &quot;**--&gt;tomcat${PORT_1}路径不存在&quot;
                        createEmail_content &quot;**--&gt;脚本启动tomcat${PORT_1}失败&quot;
                fi
    fi

    if [[ $TOMCAT_STATUS =~ &quot;$PORT_2&quot; ]]
    then
            TOMCAT_2_LOG=$(tail -n 150 ${TOMCAT_DIR}/${PORT_2_FILENAME}/logs/catalina.out)
            if [[ $TOMCAT_2_LOG =~ &quot;exception&quot; ]]
            then
                    createEmail_content &quot;tomcat${PORT_2}---已运行---但日志输出异常&quot;
                    createEmail_errContent &quot;===============${COMPUTER_NAME}-${PORT_2}-输出日志===============&quot;
                    createEmail_errContent &quot;$TOMCAT_2_LOG&quot;
            fi
    else
            createEmail_content &quot;* tomcat${PORT_2}---未运行&quot;
                createEmail_content &quot;**--&gt;脚本将尝试进行启动....&quot;
                if [[ -x &quot;${TOMCAT_DIR}/${PORT_2_FILENAME}&quot; ]]
                then
                        startTomcat ${TOMCAT_DIR}/${PORT_2_FILENAME} ${PORT_2}
                else
                        createEmail_content &quot;**--&gt;tomcat${PORT_2}路径不存在&quot;
                        createEmail_content &quot;**--&gt;脚本启动tomcat${PORT_2}失败&quot;
                fi
    fi

    if [[ $TOMCAT_STATUS =~ &quot;$PORT_3&quot; ]]
    then
            TOMCAT_3_LOG=$(tail -n 150 ${TOMCAT_DIR}/${PORT_2_FILENAME}/logs/catalina.out)
            if [[ $TOMCAT_3_LOG =~ &quot;exception&quot; ]]
            then
                    createEmail_content &quot;tomcat${PORT_3}---已运行---但日志输出异常&quot;
                    createEmail_errContent &quot;===============${COMPUTER_NAME}-${PORT_3}-输出日志===============&quot;
                    createEmail_errContent &quot;$TOMCAT_3_LOG&quot;
            fi
    else
            createEmail_content &quot;* tomcat${PORT_3}---未运行&quot;
                createEmail_content &quot;**--&gt;脚本将尝试进行启动....&quot;
                if [[ -x &quot;${TOMCAT_DIR}/${PORT_3_FILENAME}&quot; ]]
                then
                        startTomcat ${TOMCAT_DIR}/${PORT_3_FILENAME} ${PORT_3}
                else
                        createEmail_content &quot;**--&gt;tomcat${PORT_3}路径不存在&quot;
                        createEmail_content &quot;**--&gt;脚本启动tomcat${PORT_3}失败&quot;
                fi
    fi

    REDIS_STATUS=$(ps -ef | grep 6379)
    if [[ ! $REDIS_STATUS =~ &quot;redis-server&quot; ]]
    then
        createEmail_content &quot;* redis未运行&quot;
                createEmail_content &quot;**--&gt;脚本将尝试进行启动....&quot;
                if [[ -x &quot;$REDIS_DIR&quot; ]]
                then
                        startRedis $REDIS_DIR
                else
                        createEmail_content &quot;**--&gt;redis路径不存在&quot;
                        createEmail_content &quot;**--&gt;脚本启动redis失败&quot;
                fi
    fi

    NGINX_STATUS=$(ps -ef | grep nginx)
    if [[ ! $NGINX_STATUS =~ &quot;nginx:&quot; ]]
    then
        createEmail_content &quot;* nginx未运行&quot;
                createEmail_content &quot;**--&gt;脚本将尝试进行启动....&quot;
                if [[ -x &quot;$NGINX_DIR&quot; ]]
                then
                        startNginx $NGINX_DIR
                else
                        createEmail_content &quot;**--&gt;nginx路径不存在&quot;
                        createEmail_content &quot;**--&gt;脚本启动nginx失败&quot;
                fi
    fi

    #DISK_GEN_STATUS=$(df -h | grep /dev/m | awk &apos;{print $5}&apos;)
    #createEmail_content &quot;根目录使用量为$DISK_GEN_STATUS&quot;

    DISK_GEN_STATUS=$(df -h | grep $GEN_FILE_TYPE | awk &apos;{print $5}&apos; | cut -f 1 -d &quot;%&quot;)
    if [[ $DISK_GEN_STATUS -gt 50 ]]
    then
        createEmail_content &quot;* 根目录使用量较大---已使用${DISK_GEN_STATUS}%&quot;
    fi

    if [[ -e &quot;email_content-${TODAY_HMS}.txt&quot; ]]
    then
        echo -e &quot;\n\n&quot; &gt;&gt; email_content-${TODAY_HMS}.txt
        createAll_tail
    fi
}
</code></pre><h4 id="选择执行并发送邮件"><a href="#选择执行并发送邮件" class="headerlink" title="选择执行并发送邮件"></a>选择执行并发送邮件</h4><pre><code>if [[ $MIN = 30 ]]
then
    automatic_h
    if [[ -e &quot;email_err-${TODAY_H}.txt&quot; ]]
    then
            mail -s &quot;${COMPUTER_NAME}检测结果&quot; -a email_err-${TODAY_H}.txt -c $EMAIL_ADDR_1 $EMAIL_ADDR_2 &lt; email_content-${TODAY_H}.txt
    else
            mail -s &quot;${COMPUTER_NAME}检测结果&quot; -c $EMAIL_ADDR_1 $EMAIL_ADDR_2 &lt; email_content-${TODAY_H}.txt
    fi
else
    automatic_hms
    if [[ -e &quot;email_content-${TODAY_HMS}.txt&quot; ]]
    then
        if [[ -e &quot;email_err-${TODAY_HMS}.txt&quot; ]]
        then
            mail -s &quot;${COMPUTER_NAME}有服务未运行&quot; -a email_err-${TODAY_HMS}.txt -c $EMAIL_ADDR_1 $EMAIL_ADDR_2 &lt; email_content-${TODAY_HMS}.txt
        else
            mail -s &quot;${COMPUTER_NAME}有服务未运行&quot; -c $EMAIL_ADDR_1 $EMAIL_ADDR_2 &lt; email_content-${TODAY_HMS}.txt
        fi
    fi
fi
</code></pre><p>代码中主要的功能就在这隔1小时执行的方法</p>
<h4 id="总共代码如下"><a href="#总共代码如下" class="headerlink" title="总共代码如下"></a>总共代码如下</h4><pre><code>#!/bin/bash

#Describe: Monitor Control System.
# tomcat, nginx, redis
#Author: cg
#Time: 2017-08-31

#----------USER CONFIG----------#

##电脑服务器别称，这里用ip的最后一个字段
COMPUTER_NAME=149

##tomcat路径，该路径为tomcat的父级路径
#前提是在此路径文件夹下包含有3个或多个子tomcat的安装文件夹
#例如:
#    /usr/local/tomcat---&gt;lotmall-8080
#                     ---&gt;mango-8081
#                     ---&gt;tomcat-8082
TOMCAT_DIR=/usr/local/tomcat

##redis的可运行文件所在文件夹的路径
#前提是redis的配置文件redis.conf和redis.server....都在该文件路径下
REDIS_DIR=/home/xm6f/dev/redis

##nginx安装文件路径
NGINX_DIR=/usr/local/nginx


##多个tomcat对应的ip
PORT_1=8080
PORT_2=8081
PORT_3=8082

##父级tomcat路径下存放的3个tomcat安装文件的文件夹名称
PORT_1_FILENAME=lotmall-8080
PORT_2_FILENAME=mango-8081
PORT_3_FILENAME=tomcat-8082

##redis端口，这里默认使用6379
#REDIS_PORT=6379

##根节点对应的文件系统
#可以使用`df -Th /` 命令查看获得
GEN_FILE_TYPE=/dev/mapper/cl-root

##要发送的邮箱地址
#如果有需要发送更多个，则在下面按照格式添加，之后在此脚本末尾的if语句块中添加，注意空格
EMAIL_ADDR_1=1542723438@qq.com
EMAIL_ADDR_2=1679055895@qq.com

#-------------------------------#

TODAY_HMS=$(date +%y%m%d%H%M%S)
TODAY_H=$(date +%y%m%d%H)
YESTERDAY=$(date -d &quot;yesterday&quot; +%y%m%d)
TIME=$(date +%Y-%m-%d-%T)
HOUR=$(date +%H)
MIN=$(date +%M)


function createEmail_content() {
    if [[ $2 = -h ]]
    then
        if [[ $3 -eq 0 ]]
        then
            echo &quot;$1&quot; &gt;&gt; email_content-${TODAY_H}.txt
        else
            echo -e &quot;$1\c&quot; &gt;&gt; email_content-${TODAY_H}.txt
        fi
    else
        if [[ $3 -eq 0 ]]
        then
            echo &quot;$1&quot; &gt;&gt; email_content-${TODAY_HMS}.txt
        else
            echo -e &quot;$1\c&quot; &gt;&gt; email_content-${TODAY_HMS}.txt
        fi
    fi
}

function createEmail_errContent() {
        if [[ $2 = -h ]]
        then
                if [[ $3 -eq 0 ]]
                then
                        echo &quot;$1&quot; &gt;&gt; email_err-${TODAY_H}.txt
                else
                        echo -e &quot;$1\c&quot; &gt;&gt; email_err-${TODAY_H}.txt
                fi
        else
                if [[ $3 -eq 0 ]]
                then
                        echo &quot;$1&quot; &gt;&gt; email_err-${TODAY_HMS}.txt
                else
                        echo -e &quot;$1\c&quot; &gt;&gt; email_err-${TODAY_HMS}.txt
                fi
        fi
}


function startTomcat() {
    ${1}/bin/./catalina.sh start
    if [[ $? -eq 0 ]]
    then
        createEmail_content &quot;**--&gt;脚本已对tomcat${2}执行启动命令&quot;
    else
        createEmail_content &quot;**--&gt;脚本未成功对tomcat${2}执行命令&quot;
    fi
    START_TOM_RESULT=$(ps -ef | grep tomcat)
    if [[ $START_TOM_RESULT =~ &quot;$2&quot; ]]
    then
        createEmail_content &quot;**--&gt;tomcat${2}已成功启动&quot;
    else
        createEmail_content &quot;**--&gt;tomcat${2}启动未成功，请手动启动&quot;
    fi    
}

function startRedis() {
    ${1}/./redis-server redis.conf
    if [[ $? -eq 0 ]]
    then
        createEmail_content &quot;**--&gt;脚本已对redis执行启动命令&quot;
    else
        createEmail_content &quot;**--&gt;脚本未成功对reids执行命令&quot;
    fi
    START_RED_RESULT=$(ps -ef | grep 6379)
    if [[ $START_RED_RESULT =~ &quot;6379&quot; ]]
    then
        createEmail_content &quot;**--&gt;redis已成功启动&quot;
    else
        createEmail_content &quot;**--&gt;redis启动未成功，请手动启动&quot;
    fi
}


function startNginx() {
    ${1}/sbin/./nginx
    if [[ $? -eq 0 ]]
    then
        createEmail_content &quot;**--&gt;脚本已对nginx执行启动命令&quot;
    else
        createEmail_content &quot;**--&gt;脚本未成功对nginx执行命令&quot;
    fi
    START_NGINX_RESULT=$(ps -ef | grep nginx)
    if [[ $START_NGINX_RESULT =~ &quot;nginx:&quot; ]]
    then
        createEmail_content &quot;**--&gt;nginx已成功启动&quot;
    else
        createEmail_content &quot;**--&gt;nginx启动未成功，请手动启动&quot;
    fi
}


function createAll_tail() {

createEmail_content &quot;======================================&quot; $1
createEmail_content &quot;---林繁&quot; $1
createEmail_content &quot;---$TIME&quot; $1

}

function automatic_h() {

    echo &quot;&quot; &gt; email_content-${TODAY_H}.txt

    createEmail_content &quot;${COMPUTER_NAME}今日${HOUR}时脚本自动执行结果&quot; -h
    createEmail_content &quot;======================================&quot; -h

    TOMCAT_STATUS=$(ps -ef | grep tomcat)

    if [[ $TOMCAT_STATUS =~ &quot;$PORT_1&quot; ]]
    then
        createEmail_content &quot;* tomcat${PORT_1}---已在运行&quot; -h 1
        TOMCAT_1_LOG=$(tail -n 150 ${TOMCAT_DIR}/${PORT_1_FILENAME}/logs/catalina.out)
        if [[ $TOMCAT_1_LOG =~ &quot;exception&quot; ]]
        then
            createEmail_content &quot;---日志输出异常&quot; -h
            createEmail_errContent &quot;===============${COMPUTER_NAME}-${PORT_1}-输出日志===============&quot; -h
            createEmail_errContent &quot;$TOMCAT_1_LOG&quot; -h
        else
            createEmail_content &quot;---日志输出正常&quot; -h
        fi
    else
        createEmail_content &quot;* tomcat${PORT_1}---未运行&quot; -h

    fi

    if [[ $TOMCAT_STATUS =~ &quot;$PORT_2&quot; ]]
    then
            createEmail_content &quot;* tomcat${PORT_2}---已在运行&quot; -h 1
            TOMCAT_2_LOG=$(tail -n 150 ${TOMCAT_DIR}/${PORT_2_FILENAME}/logs/catalina.out)
            if [[ $TOMCAT_2_LOG =~ &quot;exception&quot; ]]
            then
                    createEmail_content &quot;---日志输出异常&quot; -h
                    createEmail_errContent &quot;===============${COMPUTER_NAME}-${PORT_2}-输出日志===============&quot; -h
                    createEmail_errContent &quot;$TOMCAT_2_LOG&quot; -h
            else
                    createEmail_content &quot;---日志输出正常&quot; -h
            fi
    else
            createEmail_content &quot;* tomcat${PORT_2}---未运行&quot; -h

    fi

    if [[ $TOMCAT_STATUS =~ &quot;$PORT_3&quot; ]]
    then
            createEmail_content &quot;* tomcat${PORT_3}---已在运行&quot; -h 1
            TOMCAT_3_LOG=$(tail -n 150 ${TOMCAT_DIR}/${PORT_3_FILENAME}/logs/catalina.out)
            if [[ $TOMCAT_3_LOG =~ &quot;exception&quot; ]]
            then
                    createEmail_content &quot;---日志输出异常&quot; -h
                    createEmail_errContent &quot;===============${COMPUTER_NAME}-${PORT_3}-输出日志===============&quot; -h
                    createEmail_errContent &quot;$TOMCAT_3_LOG&quot; -h
            else
                    createEmail_content &quot;---日志输出正常&quot; -h
            fi
    else
            createEmail_content &quot;* tomcat${PORT_3}---未运行&quot; -h
    fi

    REDIS_STATUS=$(ps -ef | grep 6379)
    if [[ $REDIS_STATUS =~ &quot;redis-server&quot; ]]
    then
        createEmail_content &quot;* redis已在运行&quot; -h
    else
        createEmail_content &quot;* redis未运行&quot; -h
    fi

    NGINX_STATUS=$(ps -ef | grep nginx)
    if [[ $NGINX_STATUS =~ &quot;nginx:&quot; ]]
    then
        createEmail_content &quot;* nginx已在运行&quot; -h
    else
        createEmail_content &quot;* nginx未运行&quot; -h
    fi

    #DISK_GEN_STATUS=$(df -h | grep /dev/m | awk &apos;{print $5}&apos;)
    #createEmail_content &quot;根目录使用量为$DISK_GEN_STATUS&quot;

    DISK_GEN_STATUS=$(df -h | grep $GEN_FILE_TYPE | awk &apos;{print $5}&apos; | cut -f 1 -d &quot;%&quot;)
    if [[ $DISK_GEN_STATUS -lt 50 ]]
    then
        createEmail_content &quot;* 根目录使用量较小---已使用${DISK_GEN_STATUS}%&quot; -h
    else
        createEmail_content &quot;* 根目录使用量较大---已使用${DISK_GEN_STATUS}%&quot; -h
    fi


    echo -e &quot;\n\n&quot; &gt;&gt; email_content-${TODAY_H}.txt

    createAll_tail -h
}


function automatic_hms() {

    TOMCAT_STATUS=$(ps -ef | grep tomcat)

    if [[ $TOMCAT_STATUS =~ &quot;$PORT_1&quot; ]]
    then
        TOMCAT_1_LOG=$(tail -n 150 ${TOMCAT_DIR}/${PORT_1_FILENAME}/logs/catalina.out)
        TOMCAT_1_DIR=${TOMCAT_DIR}/${PORT_1_FILENAME}
        if [[ $TOMCAT_1_LOG =~ &quot;exception&quot; ]]
        then
            createEmail_content &quot;* tomcat${PORT_1}---已运行---但日志输出异常&quot;
            createEmail_errContent &quot;===============${COMPUTER_NAME}-${PORT_1}-输出日志===============&quot;
            createEmail_errContent &quot;$TOMCAT_1_LOG&quot;
        fi
    else
        createEmail_content &quot;* tomcat${PORT_1}---未运行&quot;
                createEmail_content &quot;**--&gt;脚本将尝试进行启动....&quot;
                if [[ -x &quot;${TOMCAT_DIR}/${PORT_1_FILENAME}&quot; ]]
                then
                        startTomcat ${TOMCAT_DIR}/${PORT_1_FILENAME} ${PORT_1}
                else
                        createEmail_content &quot;**--&gt;tomcat${PORT_1}路径不存在&quot;
                        createEmail_content &quot;**--&gt;脚本启动tomcat${PORT_1}失败&quot;
                fi
    fi

    if [[ $TOMCAT_STATUS =~ &quot;$PORT_2&quot; ]]
    then
            TOMCAT_2_LOG=$(tail -n 150 ${TOMCAT_DIR}/${PORT_2_FILENAME}/logs/catalina.out)
            if [[ $TOMCAT_2_LOG =~ &quot;exception&quot; ]]
            then
                    createEmail_content &quot;tomcat${PORT_2}---已运行---但日志输出异常&quot;
                    createEmail_errContent &quot;===============${COMPUTER_NAME}-${PORT_2}-输出日志===============&quot;
                    createEmail_errContent &quot;$TOMCAT_2_LOG&quot;
            fi
    else
            createEmail_content &quot;* tomcat${PORT_2}---未运行&quot;
                createEmail_content &quot;**--&gt;脚本将尝试进行启动....&quot;
                if [[ -x &quot;${TOMCAT_DIR}/${PORT_2_FILENAME}&quot; ]]
                then
                        startTomcat ${TOMCAT_DIR}/${PORT_2_FILENAME} ${PORT_2}
                else
                        createEmail_content &quot;**--&gt;tomcat${PORT_2}路径不存在&quot;
                        createEmail_content &quot;**--&gt;脚本启动tomcat${PORT_2}失败&quot;
                fi
    fi

    if [[ $TOMCAT_STATUS =~ &quot;$PORT_3&quot; ]]
    then
            TOMCAT_3_LOG=$(tail -n 150 ${TOMCAT_DIR}/${PORT_2_FILENAME}/logs/catalina.out)
            if [[ $TOMCAT_3_LOG =~ &quot;exception&quot; ]]
            then
                    createEmail_content &quot;tomcat${PORT_3}---已运行---但日志输出异常&quot;
                    createEmail_errContent &quot;===============${COMPUTER_NAME}-${PORT_3}-输出日志===============&quot;
                    createEmail_errContent &quot;$TOMCAT_3_LOG&quot;
            fi
    else
            createEmail_content &quot;* tomcat${PORT_3}---未运行&quot;
                createEmail_content &quot;**--&gt;脚本将尝试进行启动....&quot;
                if [[ -x &quot;${TOMCAT_DIR}/${PORT_3_FILENAME}&quot; ]]
                then
                        startTomcat ${TOMCAT_DIR}/${PORT_3_FILENAME} ${PORT_3}
                else
                        createEmail_content &quot;**--&gt;tomcat${PORT_3}路径不存在&quot;
                        createEmail_content &quot;**--&gt;脚本启动tomcat${PORT_3}失败&quot;
                fi
    fi

    REDIS_STATUS=$(ps -ef | grep 6379)
    if [[ ! $REDIS_STATUS =~ &quot;redis-server&quot; ]]
    then
        createEmail_content &quot;* redis未运行&quot;
                createEmail_content &quot;**--&gt;脚本将尝试进行启动....&quot;
                if [[ -x &quot;$REDIS_DIR&quot; ]]
                then
                        startRedis $REDIS_DIR
                else
                        createEmail_content &quot;**--&gt;redis路径不存在&quot;
                        createEmail_content &quot;**--&gt;脚本启动redis失败&quot;
                fi
    fi

    NGINX_STATUS=$(ps -ef | grep nginx)
    if [[ ! $NGINX_STATUS =~ &quot;nginx:&quot; ]]
    then
        createEmail_content &quot;* nginx未运行&quot;
                createEmail_content &quot;**--&gt;脚本将尝试进行启动....&quot;
                if [[ -x &quot;$NGINX_DIR&quot; ]]
                then
                        startNginx $NGINX_DIR
                else
                        createEmail_content &quot;**--&gt;nginx路径不存在&quot;
                        createEmail_content &quot;**--&gt;脚本启动nginx失败&quot;
                fi
    fi

    #DISK_GEN_STATUS=$(df -h | grep /dev/m | awk &apos;{print $5}&apos;)
    #createEmail_content &quot;根目录使用量为$DISK_GEN_STATUS&quot;

    DISK_GEN_STATUS=$(df -h | grep $GEN_FILE_TYPE | awk &apos;{print $5}&apos; | cut -f 1 -d &quot;%&quot;)
    if [[ $DISK_GEN_STATUS -gt 50 ]]
    then
        createEmail_content &quot;* 根目录使用量较大---已使用${DISK_GEN_STATUS}%&quot;
    fi

    if [[ -e &quot;email_content-${TODAY_HMS}.txt&quot; ]]
    then
        echo -e &quot;\n\n&quot; &gt;&gt; email_content-${TODAY_HMS}.txt
        createAll_tail
    fi
}


#$HOUR_INT=$(echo $HOUR | sed -r &apos;s/\&lt;0+([1-9]+)/\1/g&apos;)

if [[ $MIN = 30 ]]
then
    automatic_h
    if [[ -e &quot;email_err-${TODAY_H}.txt&quot; ]]
    then
            mail -s &quot;${COMPUTER_NAME}检测结果&quot; -a email_err-${TODAY_H}.txt -c $EMAIL_ADDR_1 $EMAIL_ADDR_2 &lt; email_content-${TODAY_H}.txt
    else
            mail -s &quot;${COMPUTER_NAME}检测结果&quot; -c $EMAIL_ADDR_1 $EMAIL_ADDR_2 &lt; email_content-${TODAY_H}.txt
    fi
else
    automatic_hms
    if [[ -e &quot;email_content-${TODAY_HMS}.txt&quot; ]]
    then
        if [[ -e &quot;email_err-${TODAY_HMS}.txt&quot; ]]
        then
            mail -s &quot;${COMPUTER_NAME}有服务未运行&quot; -a email_err-${TODAY_HMS}.txt -c $EMAIL_ADDR_1 $EMAIL_ADDR_2 &lt; email_content-${TODAY_HMS}.txt
        else
            mail -s &quot;${COMPUTER_NAME}有服务未运行&quot; -c $EMAIL_ADDR_1 $EMAIL_ADDR_2 &lt; email_content-${TODAY_HMS}.txt
        fi
    fi
fi
</code></pre><p>jdk就不监控了，根本不需要有…</p>
<h3 id="代码更新-170918"><a href="#代码更新-170918" class="headerlink" title="代码更新-170918"></a>代码更新-170918</h3><pre><code>#!/bin/bash

#Describe: Monitor Control System.
# tomcat, nginx, redis
#Author: cg
#Time: 2017-08-31

#----------USER CONFIG----------#

COMPUTER_NAME=105
TOMCAT_DIR=/home/xm6f/dev/tomcat-7.0.79
REDIS_DIR=/home/xm6f/dev/redis-3.2.4
REDIS_START_SHELL_CL=/home/xm6f/dev/shell/./redis_start_all.sh
#NGINX_DIR=/usr/local/nginx

TOMCAT_NUM=4

PORT_1=8080
PORT_2=8081
PORT_3=8088
PORT_4=8098

PORT_1_FILENAME=tomcat-8080
PORT_2_FILENAME=tomcat-8081
PORT_3_FILENAME=tomcat-8088
PORT_4_FILENAME=tomcat-8098

#REDIS_PORT=6379

#
GEN_FILE_TYPE=/dev/mapper/cl-root

EMAIL_LOG=/usr/scripts/automatic/monitor_log

EMAIL_ADDR_1=1542723438@qq.com
#EMAIL_ADDR_2=1679055895@qq.com

#-------------------------------#

TODAY_HMS=$(date +%y%m%d%H%M%S)
TODAY_H=$(date +%y%m%d%H)
YESTERDAY=$(date -d &quot;yesterday&quot; +%y%m%d)
TIME=$(date +%Y-%m-%d-%T)
HOUR=$(date +%H)
MIN=$(date +%M)


function createEmail_content() {
    if [[ $2 = -h ]]
    then
        if [[ $3 -eq 0 ]]
        then
            echo &quot;$1&quot; &gt;&gt; ${EMAIL_LOG}/email_content-${TODAY_H}.txt
        else
            echo -e &quot;$1\c&quot; &gt;&gt; ${EMAIL_LOG}/email_content-${TODAY_H}.txt
        fi
    else
        if [[ $3 -eq 0 ]]
        then
            echo &quot;$1&quot; &gt;&gt; ${EMAIL_LOG}/email_content-${TODAY_HMS}.txt
        else
            echo -e &quot;$1\c&quot; &gt;&gt; ${EMAIL_LOG}/email_content-${TODAY_HMS}.txt
        fi
    fi
}

function createEmail_errContent() {
        if [[ $2 = -h ]]
        then
                if [[ $3 -eq 0 ]]
                then
                        echo &quot;$1&quot; &gt;&gt; ${EMAIL_LOG}/email_err-${TODAY_H}.txt
                else
                        echo -e &quot;$1\c&quot; &gt;&gt; ${EMAIL_LOG}/email_err-${TODAY_H}.txt
                fi
        else
                if [[ $3 -eq 0 ]]
                then
                        echo &quot;$1&quot; &gt;&gt; ${EMAIL_LOG}/email_err-${TODAY_HMS}.txt
                else
                        echo -e &quot;$1\c&quot; &gt;&gt; ${EMAIL_LOG}/email_err-${TODAY_HMS}.txt
                fi
        fi
}


function startTomcat() {
    ${1}/bin/./catalina.sh start
    if [[ $? -eq 0 ]]
    then
        createEmail_content &quot;**--&gt;脚本已对tomcat${2}执行启动命令&quot;
    else
        createEmail_content &quot;**--&gt;脚本未成功对tomcat${2}执行命令&quot;
    fi
    START_TOM_RESULT=$(ps -ef | grep tomcat)
    if [[ $START_TOM_RESULT =~ &quot;$2&quot; ]]
    then
        createEmail_content &quot;**--&gt;tomcat${2}已成功启动&quot;
    else
        createEmail_content &quot;**--&gt;tomcat${2}启动未成功，请手动启动&quot;
    fi    
}

function startRedis() {
    ${REDIS_DIR}/./redis-server redis.conf
    if [[ $? -eq 0 ]]
    then
        createEmail_content &quot;**--&gt;脚本已对redis执行启动命令&quot;
    else
        createEmail_content &quot;**--&gt;脚本未成功对reids执行命令&quot;
    fi
    START_RED_RESULT=$(ps -ef | grep redis)
    if [[ $START_RED_RESULT =~ &quot;redis-server&quot; ]]
    then
        createEmail_content &quot;**--&gt;redis已成功启动&quot;
    else
        createEmail_content &quot;**--&gt;redis启动未成功，请手动启动&quot;
    fi
}

function startRedis_byShell() {
    ${REDIS_START_SHELL_CL}
    if [[ $? -eq 0 ]]
    then
                createEmail_content &quot;**--&gt;脚本已对redis执行启动命令&quot;
        else
                createEmail_content &quot;**--&gt;脚本未成功对reids执行命令&quot;
        fi
        START_RED_RESULT=$(ps -ef | grep redis)
        if [[ $START_RED_RESULT =~ &quot;redis-server&quot; ]]
        then
                createEmail_content &quot;**--&gt;redis已成功启动&quot;
        else
                createEmail_content &quot;**--&gt;redis启动未成功，请手动启动&quot;
        fi


}


function startNginx() {
    ${NGINX_DIR}/sbin/./nginx
    if [[ $? -eq 0 ]]
    then
        createEmail_content &quot;**--&gt;脚本已对nginx执行启动命令&quot;
    else
        createEmail_content &quot;**--&gt;脚本未成功对nginx执行命令&quot;
    fi
    START_NGINX_RESULT=$(ps -ef | grep nginx)
    if [[ $START_NGINX_RESULT =~ &quot;nginx:&quot; ]]
    then
        createEmail_content &quot;**--&gt;nginx已成功启动&quot;
    else
        createEmail_content &quot;**--&gt;nginx启动未成功，请手动启动&quot;
    fi
}

function try_start() {
        createEmail_content &quot;* ${1}未运行&quot;
        createEmail_content &quot;**--&gt;脚本将尝试进行启动....&quot;
        if [[ -x &quot;$2&quot; ]]
        then
                if [[ ${1} -eq &quot;redis&quot; ]]
                then
                        startRedis_byShell
                else
                        startNginx
                fi
        else
                createEmail_content &quot;**--&gt;${1}路径不存在&quot;
                createEmail_content &quot;**--&gt;脚本启动${1}失败&quot;
        fi
}



function createAll_tail() {

createEmail_content &quot;======================================&quot; $1
createEmail_content &quot;---林繁&quot; $1
createEmail_content &quot;---$TIME&quot; $1

}


function tomcat_h() {

        if [[ $TOMCAT_STATUS =~ &quot;$1&quot; ]]
        then
            createEmail_content &quot;* tomcat${1}---已在运行&quot; -h 1
                TOMCAT_LOG=$(tail -n 150 ${TOMCAT_DIR}/${2}/logs/catalina.out)
                if [[ $TOMCAT_LOG =~ &quot;exception&quot; ]]
                then
                        createEmail_content &quot;---日志输出异常&quot; -h
                        createEmail_errContent &quot;===============${COMPUTER_NAME}-${1}-输出日志===============&quot; -h
                        createEmail_errContent &quot;$TOMCAT_LOG&quot; -h
                else
                        createEmail_content &quot;---日志输出正常&quot; -h
                fi
        else
                createEmail_content &quot;* tomcat${1}---未运行&quot; -h

        fi
}


function tomcat_hms() {

    if [[ $TOMCAT_STATUS =~ &quot;$1&quot; ]]
    then
        TOMCAT_LOG=$(tail -n 150 ${TOMCAT_DIR}/${2}/logs/catalina.out)
        if [[ $TOMCAT_1_LOG =~ &quot;exception&quot; ]]
        then
            createEmail_content &quot;* tomcat${1}---已运行---但日志输出异常&quot;
            createEmail_errContent &quot;===============${COMPUTER_NAME}-${1}-输出日志===============&quot;
            createEmail_errContent &quot;$TOMCAT_LOG&quot;
        fi
    else
        createEmail_content &quot;* tomcat${1}---未运行&quot;
                createEmail_content &quot;**--&gt;脚本将尝试进行启动....&quot;
                if [[ -x &quot;${TOMCAT_DIR}/${2}&quot; ]]
                then
                        startTomcat ${TOMCAT_DIR}/${2} ${1}
                else
                        createEmail_content &quot;**--&gt;tomcat${1}路径不存在&quot;
                        createEmail_content &quot;**--&gt;脚本启动tomcat${1}失败&quot;
                fi
    fi
}


function for_tomcat_h() {

    TOMCAT_STATUS=$(ps -ef | grep tomcat)
        for(( i=1; i&lt;=${TOMCAT_NUM}; i++ )) {
                PORT=PORT_$i
        FILENAME=PORT_${i}_FILENAME
                eval TOMCAT_PORT=&quot;$&quot;$PORT
        eval TOMCAT_FILENAME=&quot;$&quot;$FILENAME
                tomcat_h $TOMCAT_PORT $TOMCAT_FILENAME
        }
}

function for_tomcat_hms() {

        TOMCAT_STATUS=$(ps -ef | grep tomcat)
        for(( i=1; i&lt;=${TOMCAT_NUM}; i++ )) {
                PORT=PORT_$i
                FILENAME=PORT_${i}_FILENAME
                eval TOMCAT_PORT=&quot;$&quot;$PORT
                eval TOMCAT_FILENAME=&quot;$&quot;$FILENAME
                tomcat_hms $TOMCAT_PORT $TOMCAT_FILENAME
        }
}



function redis_state() {

        REDIS_STATUS=$(ps -ef | grep redis)
        if [[ $REDIS_STATUS =~ &quot;redis-server&quot; ]]
        then
                createEmail_content &quot;* redis已在运行&quot; -h
        else
                createEmail_content &quot;* redis未运行&quot; -h
        fi
}


function nginx_state() {

        NGINX_STATUS=$(ps -ef | grep nginx)
        if [[ $NGINX_STATUS =~ &quot;nginx:&quot; ]]
        then
                createEmail_content &quot;* nginx已在运行&quot; -h
        else
                createEmail_content &quot;* nginx未运行&quot; -h
        fi
}

function gen_state() {

        DISK_GEN_STATUS=$(df -h | grep $GEN_FILE_TYPE | awk &apos;{print $5}&apos; | cut -f 1 -d &quot;%&quot;)
        if [[ $DISK_GEN_STATUS -lt 50 ]]
        then
                createEmail_content &quot;* 根目录使用量较小---已使用${DISK_GEN_STATUS}%&quot; -h
        else
                createEmail_content &quot;* 根目录使用量较大---已使用${DISK_GEN_STATUS}%&quot; -h
        fi
}


function redis_stats_hms() {

        REDIS_STATUS=$(ps -ef | grep redis)
        if [[ ! $REDIS_STATUS =~ &quot;redis-server&quot; ]]
    then
        try_start &quot;redis&quot; $REDIS_DIR
    fi
}

function nginx_stats_hms() {

        NGINX_STATUS=$(ps -ef | grep nginx)
        if [[ ! $NGINX_STATUS =~ &quot;nginx:&quot; ]]
    then
        try_start &quot;nginx&quot; $NGINX_DIR
    fi
}

function gen_stats_hms() {

        DISK_GEN_STATUS=$(df -h | grep $GEN_FILE_TYPE | awk &apos;{print $5}&apos; | cut -f 1 -d &quot;%&quot;)
        if [[ $DISK_GEN_STATUS -gt 50 ]]
        then
                createEmail_content &quot;* 根目录使用量较大---已使用${DISK_GEN_STATUS}%&quot;
        fi
}

function rm_email_log() {

        rm ${EMAIL_LOG}/email_*-${YESTERDAY}*.txt
        if [[ $? -eq 0 ]]
        then
                createEmail_content &quot;昨天的邮件日志已经删除&quot; -h
        else
                createEmail_content &quot;昨天的邮件日志未成功删除&quot; -h
        fi
}


function automatic_h() {

        echo &quot;&quot; &gt; ${EMAIL_LOG}/email_content-${TODAY_H}.txt

        createEmail_content &quot;${COMPUTER_NAME}今日${HOUR}时脚本自动执行结果&quot; -h
        createEmail_content &quot;======================================&quot; -h

        for_tomcat_h
        redis_state
        #nginx_state
        gen_state

    if [[ $HOUR = 23 ]]
    then
            rm_email_log
    fi

        echo -e &quot;\n\n&quot; &gt;&gt; ${EMAIL_LOG}/email_content-${TODAY_H}.txt

        createAll_tail -h
}


function automatic_hms() {

    for_tomcat_hms
    redis_stats_hms
    #nginx_stats_hms
    gen_stats_hms

    if [[ -e &quot;${EMAIL_LOG}/email_content-${TODAY_HMS}.txt&quot; ]]
    then
        echo -e &quot;\n\n&quot; &gt;&gt; ${EMAIL_LOG}/email_content-${TODAY_HMS}.txt
        createAll_tail
    fi
}


#$HOUR_INT=$(echo $HOUR | sed -r &apos;s/\&lt;0+([1-9]+)/\1/g&apos;)

if [[ $MIN = 30 ]]
then
    automatic_h
    if [[ -e &quot;${EMAIL_LOG}/email_err-${TODAY_H}.txt&quot; ]]
    then
            mail -s &quot;${COMPUTER_NAME}检测结果&quot; -a ${EMAIL_LOG}/email_err-${TODAY_H}.txt $EMAIL_ADDR_1 &lt; ${EMAIL_LOG}/email_content-${TODAY_H}.txt
    else
            mail -s &quot;${COMPUTER_NAME}检测结果&quot; $EMAIL_ADDR_1 &lt; ${EMAIL_LOG}/email_content-${TODAY_H}.txt
    fi
else
    automatic_hms
    if [[ -e &quot;${EMAIL_LOG}/email_content-${TODAY_HMS}.txt&quot; ]]
    then
        if [[ -e &quot;${EMAIL_LOG}/email_err-${TODAY_HMS}.txt&quot; ]]
        then
            mail -s &quot;${COMPUTER_NAME}有服务未运行&quot; -a ${EMAIL_LOG}/email_err-${TODAY_HMS}.txt $EMAIL_ADDR_1 &lt; ${EMAIL_LOG}/email_content-${TODAY_HMS}.txt
        else
            mail -s &quot;${COMPUTER_NAME}有服务未运行&quot; $EMAIL_ADDR_1 &lt; ${EMAIL_LOG}/email_content-${TODAY_HMS}.txt
        fi
    fi
fi
</code></pre><p>优化了代码，使其模块化，同时解决了之前提到的一些bug</p>
]]></content>
      
        <categories>
            
            <category> linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> linux </tag>
            
            <tag> email </tag>
            
            <tag> mail </tag>
            
            <tag> shell </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用shell发送qq邮件]]></title>
      <url>/2017/08/30/linux/2017-08-30-linux-sendEmail/</url>
      <content type="html"><![CDATA[<p>前些天折腾了下在linux系统上发送qq邮件，发现使用shell命令来实现这个很简单，于是就弄了。弄这个的主要目的是为了将脚本监控或者操作系统后得到的结果以邮件的方式反馈给我，这样我也就能及时知道自己写的脚本执行情况怎么样。</p>
<a id="more"></a>
<h3 id="安装mail"><a href="#安装mail" class="headerlink" title="安装mail"></a>安装mail</h3><p>首先，查看系统中是否又mail和mailx，运行命令<br><code>mail -V</code><br>或者<br><code>mailx -V</code><br>有输出即表示系统中已经存在,如下</p>
<pre><code>[xm6f@localhost cut_nginx_log]$ mail -V
12.5 7/5/10
[xm6f@localhost cut_nginx_log]$ mailx -V
12.5 7/5/10
</code></pre><p>centos一般自带了这个命令，如果别的系统如ubuntu，要没有则运行命令<br><code>sudo apt-get install heirloom-mailx</code><br>来安装</p>
<h3 id="mail配置"><a href="#mail配置" class="headerlink" title="mail配置"></a>mail配置</h3><p>之后就是需要对mail进行配置，修改其配置文件，配置好用来发送邮件的邮件地址和密码，密码都是stmp授权码<br>ubuntu下的配置文件为/etc/s-nail.rc<br>centos下的配置文件为/etc/mail.rc<br>在该文件末尾添加如下代码</p>
<pre><code>set from=1732821152@qq.com(cg)                 #设置发送邮件的邮箱和发邮件名称为cg
set smtp=smtp.qq.com                        #设置smtp服务器地址
set smtp-auth-user=1732821152@qq.com        #设置邮箱账户
set smtp-auth-password=xxx                    #设置密码，为授权码
set smtp-auth=login                            #SSL验证信息
set smtp-use-starttls
set ssl-verify=ignore
set nss-config-dir=/etc/pki/nssdb/            #设置证书存放路径
</code></pre><p>将其保存，之后就可以使用mail命令来发送邮件了，发送方就是上面填写的邮件地址</p>
<h3 id="发送测试"><a href="#发送测试" class="headerlink" title="发送测试"></a>发送测试</h3><p>例如</p>
<h4 id="读取文件内容发送"><a href="#读取文件内容发送" class="headerlink" title="读取文件内容发送"></a>读取文件内容发送</h4><p><code>mail -v -s &quot;定时任务&quot; 1542723438@qq.com &lt; mail_content.txt</code><br>上述命令表示，将名为mail_content.txt的文件中的内容作为邮件内容发送到<code>1542723438@qq.com</code>这个邮箱地址,<br><code>-v</code>是显示输出日志，<code>-s</code>表示邮件主题名称,详情使用<br><code>man mail</code><br>或者<br><code>mail --help</code><br>来查看如何使用</p>
<h4 id="管道发送"><a href="#管道发送" class="headerlink" title="管道发送"></a>管道发送</h4><p><code>echo &quot;hey,how are you &quot; | mail -v -s &quot;test&quot; 1542723438@qq.com</code><br>使用管道命令，将<code>echo</code>输出的内容作为邮件内容发送出去</p>
<h4 id="发送附件"><a href="#发送附件" class="headerlink" title="发送附件"></a>发送附件</h4><p><code>mail -s &quot;测试&quot; -a email_err.txt 1542723438@qq.com &lt; email_content.txt</code><br>读取email_content.txt这个文件的内容作为邮件内容发送，并将email_err.txt这个文件作为附件一起发送到邮箱</p>
<h3 id="定时发送"><a href="#定时发送" class="headerlink" title="定时发送"></a>定时发送</h3><p>需要修改这个文件/etc/crontab，这相当于一个定时器，例如我在这个文件末尾添加如下代码<br><code>11 23 * * * root /bin/bash /usr/scripts/automatic/automatic_util.sh</code><br>即表示在每天的23点11分以root身份，使用<code>/bin/bash</code>这个解释器来运行automatic_util.sh这个shell脚本</p>
<h3 id="管道发送实例输出"><a href="#管道发送实例输出" class="headerlink" title="管道发送实例输出"></a>管道发送实例输出</h3><pre><code>[xm6f@localhost cut_nginx_log]$ echo &quot;hey,how are you &quot; | mail -v -s &quot;test&quot; 1542723438@qq.com
Resolving host smtp.qq.com . . . done.
Connecting to 14.17.57.241:smtp . . . connected.
220 smtp.qq.com Esmtp QQ Mail Server
&gt;&gt;&gt; EHLO localhost
250-smtp.qq.com
250-PIPELINING
250-SIZE 73400320
250-STARTTLS
250-AUTH LOGIN PLAIN
250-AUTH=LOGIN
250-MAILCOMPRESS
250 8BITMIME
&gt;&gt;&gt; STARTTLS
220 Ready to start TLS
Error in certificate: Peer&apos;s certificate issuer is not recognized.
Comparing DNS name: &quot;upload.mail.qq.com&quot;
Comparing DNS name: &quot;hwsmtp.exmail.qq.com&quot;
Comparing DNS name: &quot;hwimap.exmail.qq.com&quot;
Comparing DNS name: &quot;cloudmx.qq.com&quot;
Comparing DNS name: &quot;imap.exmail.qq.com&quot;
Comparing DNS name: &quot;hwpop.exmail.qq.com&quot;
Comparing DNS name: &quot;smtp.qq.com&quot;
SSL parameters: cipher=AES-128, keysize=128, secretkeysize=128,
issuer=CN=GeoTrust SSL CA - G3,O=GeoTrust Inc.,C=US
subject=CN=pop.qq.com,OU=R&amp;D,O=Shenzhen Tencent Computer Systems Company Limited,L=Shenzhen,ST=Guangdong,C=CN
&gt;&gt;&gt; EHLO localhost
250-smtp.qq.com
250-PIPELINING
250-SIZE 73400320
250-AUTH LOGIN PLAIN
250-AUTH=LOGIN
250-MAILCOMPRESS
250 8BITMIME
&gt;&gt;&gt; AUTH LOGIN
334 VXNlcm5hbWU6
&gt;&gt;&gt; MTczMjgyMTE1MkBxcS5jb20=
334 UGFzc3dvcmQ6
&gt;&gt;&gt; YWlpcmptcWhwdmxlZWFnZw==
235 Authentication successful
&gt;&gt;&gt; MAIL FROM:&lt;1732821152@qq.com&gt;
250 Ok
&gt;&gt;&gt; RCPT TO:&lt;1542723438@qq.com&gt;
250 Ok
&gt;&gt;&gt; DATA
354 End data with &lt;CR&gt;&lt;LF&gt;.&lt;CR&gt;&lt;LF&gt;
&gt;&gt;&gt; .
250 Ok: queued as 
&gt;&gt;&gt; QUIT
221 Bye
[xm6f@localhost cut_nginx_log]$
</code></pre><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p>mail发送邮件平常使用25端口，也可以使用587，465(ssl)，587和25端口一样，465端口就是加密端口。平常一些服务器运营商会禁止使用25端口，使得用上面的配置则发送不去出，因此可以使用587端口<br>设置使用465端口来发送邮件的mail.rc配置如下<br><code>set smtp=smtps://smtp.qq.com:465</code><br>设置使用587端口则如下<br><code>set smtp=smtp.qq.com:587</code></p>
]]></content>
      
        <categories>
            
            <category> linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> linux </tag>
            
            <tag> email </tag>
            
            <tag> mail </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hexo博客电脑迁移]]></title>
      <url>/2017/08/30/hexo/2017-08-30-hexoMoreComputer/</url>
      <content type="html"><![CDATA[<p>公司配了电脑，所以就不用自己带电脑去上班，而出租屋里自己也没wifi，也就导致不好更博。原先自己是将笔记整理好，用simpleNote来进行同步更新，等到了周末就带自己笔记本来公司总结自己写的笔记，并将其更新到博客中。总觉得麻烦，于是就在公司配的笔记本上搭建好环境来更博….</p>
<a id="more"></a>
<p>自己在之前就已经把博客主题和博客source文件都上传到github中，所以换个电脑来更博也不麻烦</p>
<h3 id="配置好hexo环境"><a href="#配置好hexo环境" class="headerlink" title="配置好hexo环境"></a>配置好hexo环境</h3><p>这个windows上直接下载node.js和git,安装时一路enter就好了。安装完成之后在cmd窗口下运行命令<br><code>npm install -g hexo-cli</code><br>来安装hexo</p>
<h3 id="配置git"><a href="#配置git" class="headerlink" title="配置git"></a>配置git</h3><p>安装好git后，需要填写用户名和邮箱作为一个标识，运行命令<br><code>git config --global user.name &quot;cgstudios&quot;</code><br><code>git config --global user.email &quot;1732821152@qq.com&quot;</code><br>参数–global表示全局设置，使用<code>git config --help</code>来查看其他参数</p>
<h3 id="创建本地站点"><a href="#创建本地站点" class="headerlink" title="创建本地站点"></a>创建本地站点</h3><p>使用hexo init命令创建一个本地博客站点</p>
<h3 id="为hexo指定git"><a href="#为hexo指定git" class="headerlink" title="为hexo指定git"></a>为hexo指定git</h3><p>在创建的本地站点目录下运行命令<br><code>npm install hexo-deployer-git -save</code><br>这样才能通过hexo来操作git<br>另外还需安装插件，实现local search搜索，运行命令<br><code>npm install hexo-generator-searchdb --save</code></p>
<h3 id="git连接github"><a href="#git连接github" class="headerlink" title="git连接github"></a>git连接github</h3><p>git上传文件到github会进行加密，且使用rsa加密，这需要让github知道公有密钥，git bash下使用命令<br><code>ssh-keygen -t rsa -C &quot;1732821152@qq.com&quot;</code><br>之后会让你选择确认存放密钥的文件路径，为方便一路enter下去就可以，知道密钥存放路径就行了。将公有密钥id_rsa.pub文件里的内容放到github上</p>
<h3 id="其他配置"><a href="#其他配置" class="headerlink" title="其他配置"></a>其他配置</h3><p>这项配置本人自己需要弄的<br>1.删除本地站点根目录中的source这个文件夹，并从github上下载cgstudios-blog-file,直接在本地站点根目录下运行命令<br><code>git colne https://github.com/cgstudios/cgstudios-blog-file.git</code><br>将clone得到的cgstudios-blog-file这个文件夹重命名为source,并将该文件夹里的site-config-file文件夹中的_config.yml复制到根目录覆盖根目录下的_config.yml</p>
<p>2.在themes文件夹下运行<br><code>git clone https://github.com/cgstudios/myselfBlog-theme-next-myself.git</code><br>再将clone得到的myselfBlog-theme-next-myself重命名为next-myself</p>
<p>3.本地站点目录下运行命令<br><code>npm install aplayer --save</code><br><code>npm install hexo-tag-aplayer</code></p>
<p>之后运行命令<code>hexo deploy</code>就可以查看是否连接到github仓库了</p>
]]></content>
      
        <categories>
            
            <category> hexo </category>
            
        </categories>
        
        
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[为静态博客添加gitalk评论插件]]></title>
      <url>/2017/08/20/gitalk/2017-08-20-gitalk-comment-use/</url>
      <content type="html"><![CDATA[<p>多说跟网易云跟帖都倒闭这么久了，一直在找适合自己的评论系统，之前接触到一个gitment这个开源的基于github的issue评论，测试用了下还不错，不过就是在页面上显示不那么协调，也就没用了。前几天凑巧找着个gitalk这个插件，和gitment类似，一样是基于github的issue来实现评论的。同样的功能，给我的感觉就是gitalk的ui真是不错，于是就打算使用这个了</p>
<a id="more"></a>
<p>这里是链接</p>
<ul>
<li><a href="https://github.com/gitalk/gitalk" target="_blank" rel="external">项目地址</a></li>
<li><a href="https://gitalk.github.io/" target="_blank" rel="external">演示地址</a></li>
</ul>
<p>项目地址中有中文说明，详细的使用方式参考项目地址中的就可以了，这里我只是对我这次的使用进行一次简单的总结，做个记录</p>
<p>首先申请一个Github Application，到<a href="https://github.com/settings/applications/new" target="_blank" rel="external">这个页面</a>去，具体的填写方式如下图中的</p>
<p><img src="/images/gitalk/github-application.jpg" alt="github Application"></p>
<p>其中Homepage URL和Authorization callback URL这两个都填写自己博客站点的url，如我的博客现在浏览器地址中显示的根地址是<code>https://cgspace.date</code>那我就填这个，这两个填对了就好说了<br>粘贴代码到自己的post页面中了<br>我是直接使用url链接引入的方式，来使用gitalk的，如下我的引入代码格式</p>
<pre><code>&lt;div id=&quot;gitalk-container&quot;&gt;&lt;/div&gt;
&lt;link rel=&quot;stylesheet&quot; href=&quot;https://unpkg.com/gitalk/dist/gitalk.css&quot;&gt;
&lt;script src=&quot;https://unpkg.com/gitalk/dist/gitalk.min.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
var gitalk = new Gitalk({
  clientID: &apos;你申请得到的client id&apos;,
  clientSecret: &apos;你申请得到的client secret&apos;,
  repo: &apos;存放评论的仓库&apos;,
  owner: &apos;github登录id名&apos;,
  admin: [&apos;拥有对仓库进行操作的成员id名&apos;],
})
gitalk.render(&apos;gitalk-container&apos;)
&lt;/script&gt;
</code></pre><p>上面代码中列出的参数都是必须的，必须为他们进行赋值。当然也有一些其他的参数，具体可以参考gitalk项目地址里面的中文说明。上面<code>admin</code>参数的值是一个集合来存放，里面存放着这个项目仓库的所有开发人员的github的id名，这是对应那些团体开发的项目来说的，而对于我们一些个人项目，就比如博客，开发维护人员就只有我们自己，所以<code>admin</code>这个参数对应的集合只有一个元素，与<code>owner</code>的值一样<br>这样引入代码完成之后，提交到github，就需要自己对每一篇文章进行初始化，开放与文章对应的issue，之后就可以被其他github用户进行评论了</p>
<p>对于上面的样式引入链接，自己也可以把两文件下载下来然后存放到自己的仓库中进行引入</p>
]]></content>
      
        <categories>
            
            <category> gitalk </category>
            
        </categories>
        
        
        <tags>
            
            <tag> gitalk </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[linux服务器运维问题]]></title>
      <url>/2017/08/20/linux/2017-08-20-linux-server/</url>
      <content type="html"><![CDATA[<p>今天周末，也是无聊。昨天刚搬玩家，新的住址里公司挺近的，所以就来公司坐着了，打算总结一下这个星期工作中遇到的关于linux服务器的问题，多总结多学习，还得好好提升自己</p>
<a id="more"></a>
<h3 id="tomcat不能停止"><a href="#tomcat不能停止" class="headerlink" title="tomcat不能停止"></a>tomcat不能停止</h3><p>一个项目中，将首先是遇到浏览器页面打不开的问题，然后打算重启tomcat,运行命令后就报错停止不了，输出如下</p>
<pre><code>Java HotSpot(TM) 64-Bit Server VM warning: Insufficient space for shared memory file:
   29581
Try using the -Djava.io.tmpdir= option to select an alternate temp location.
</code></pre><p>看到这个问题，意识到内存不够，被占满了。然后就发现服务器的根目录已经全部被使用了，后面会详细说明根目录被全部使用的解决方法，这里先解决这个问题。把tomcat进程杀死，在将目录空间清除一些后在启动tomcat,浏览器访问发现打不开页面，页面显示下面这个错误</p>
<pre><code>dial tcp 192.168.1.7:8098: connectex: No connection could be made because the target machine actively refused it.
</code></pre><p>面对这个问题的解决方式是使用sudo命令来启动tomcat。这貌似跟系统有关，起初以为是权限问题，因为ps之后发现tomcat8098并不在运行，然后将tomcat安装目录都跟该用户所有者为xm6f普通用户，这样还是没用，依然解决不了这个问题。而7这台服务器装的是ubuntu系统，并不是centos系统，centos系统上用普通用户权限启动tomcat还没遇到过这样的问题，最多是权限不够无法写入日志。而这台，tomcat安装目录所有文件权限都有且文件所有者是普通用户，依然启动不了。而解决方式就是仅仅只需要用sudo命令来启动tomcat，即可</p>
<p>另一个tomcat不能停止的问题，例如如下输出</p>
<pre><code>PID file found but no matching process was found. Stop aborted.
</code></pre><p>这个问题这个是因为tomcat进程被强杀了，但是文件run.pid(这个文件来记录进程号的)中还是依然保存着被杀的进程id，也就是说系统中实际运行的tomcat进程id与run.pid中保存的进程id不一样，使得使用命令将tomcat关闭行不通<br>解决方法就是将电脑服务器重启或者直接将现在的tomcat进程杀死就可以了</p>
<h3 id="tomcat部署项目问题"><a href="#tomcat部署项目问题" class="headerlink" title="tomcat部署项目问题"></a>tomcat部署项目问题</h3><p>之前测试将apple部署到远程服务器上<br>使用rz命令将lotmall.war这个文件上传到tomcat8080安装目录的webapps下，之后访问，出现404，后来再查看，发现自动解压出来的lotmall这个文件夹和lotmall.war都不存在，被删了，然后再重新上传，还是被删。后面才知道需要先将tomcat关闭，再上传war包，之后启动tomcat进行访问就不会自动被删除了。部署上去后，命令运行tomcat后，测试运行是否正常，发现浏览器打不开页面，再使用命令<br><code>ps -ef | grep tomcat</code><br>发现tomcat不在运行,使用root身份启动之后，还是不运行，查看logs也没有发现什么错误，之后索性重启机器，然后再次启动tomcat后检查是否正在运行，嗯tomcat正常运行<br>然而浏览器还是访问不了，于是就猜测是端口未开放的问题，命令查看所有已开放端口<br><code>firewall-cmd --list-ports</code><br>其输出是<br><code>FirewallD is not running</code><br>看来防火墙没有打开，于是便使用命令查看状态<br><code>systemctl status firewalld</code><br>确认下<br>其输出如下</p>
<pre><code>[root@localhost bin]# systemctl status firewalld
● firewalld.service - firewalld - dynamic firewall daemon
   Loaded: loaded (/usr/lib/systemd/system/firewalld.service; disabled; vendor preset: enabled)
   Active: inactive (dead)
     Docs: man:firewalld(1)
</code></pre><p>确实不在运行，所以就命令让它运行<br><code>systemctl start firewalld</code><br>即可启动，查看下状态可知inactive变为running，即在运行，然后命令查看所有已开放的端口，发现没有一个端口开放，这里需要开放8080端口<br>于是命令<br><code>sudo firewall-cmd --zone=public --add-port=8080/tcp --permanent</code><br>将其开放，在重新加载<br><code>sudo firewall-cmd --reload</code><br>之后浏览器就可以访问了</p>
<h3 id="linux中的top命令"><a href="#linux中的top命令" class="headerlink" title="linux中的top命令"></a>linux中的top命令</h3><p>直接运行命令<br><code>top</code><br>其输出的讲解如下<br>第一行是任务队列信息，同 uptime 命令的执行结果，其解析如下：<br>01:06:48  当前时间<br>up 1:22   系统运行时间，格式为时:分<br>1 user    当前登录用户数<br>load average: 0.03, 0.04, 0.05 系统负载，即任务队列的平均长度。三个数值分别为 1分钟、5分钟、15分钟前到现在的平均值。</p>
<p>第二、三行为进程和CPU的信息。当有多个CPU时，这些内容可能会超过两行，意思解析如下：<br>total 进程总数<br>running 正在运行的进程数<br>sleeping 睡眠的进程数<br>stopped 停止的进程数<br>zombie 僵尸进程数<br>Cpu(s):<br>0.3% us 用户空间占用CPU百分比<br>1.0% sy 内核空间占用CPU百分比<br>0.0% ni 用户进程空间内改变过优先级的进程占用CPU百分比<br>98.7% id 空闲CPU百分比<br>0.0% wa 等待输入输出的CPU时间百分比<br>0.0%hi：硬件CPU中断占用百分比<br>0.0%si：软中断占用百分比<br>0.0%st：虚拟机占用百分比</p>
<p>最后两行为内存信息。内容如下<br>Mem<br>191272k total   物理内存总量<br>173656k used    使用的物理内存总量<br>17616k free     空闲内存总量<br>22052k buffers    用作内核缓存的内存量<br>Swap<br>192772k total   交换区总量<br>0k used    使用的交换区总量<br>192772k free    空闲交换区总量<br>123988k cached </p>
<p>缓冲的交换区总量,内存中的内容被换出到交换区，而后又被换入到内存，但使用过的交换区尚未被覆盖，该数值即为这些内容已存在于内存中的交换区的大小,相应的内存再次被换出时可不必再对交换区写入</p>
<h3 id="服务器根目录已使用完"><a href="#服务器根目录已使用完" class="headerlink" title="服务器根目录已使用完"></a>服务器根目录已使用完</h3><p>关于根目录空间使用完，那么就需要清理空间，当然首先需要找着占用这些空间的文件，并将这些文件删除<br>首先，查看空间的大概使用情况命令<br><code>df -Th</code><br>输出如下</p>
<pre><code>xm6f@admin-pc:~$ df -Th
文件系统       类型      容量  已用  可用 已用% 挂载点
udev           devtmpfs  3.9G     0  3.9G    0% /dev
tmpfs          tmpfs     794M  9.2M  785M    2% /run
/dev/sda2      ext4      909G  289G  574G   34% /
tmpfs          tmpfs     3.9G     0  3.9G    0% /dev/shm
tmpfs          tmpfs     5.0M     0  5.0M    0% /run/lock
tmpfs          tmpfs     3.9G     0  3.9G    0% /sys/fs/cgroup
/dev/sda1      vfat      511M  3.5M  508M    1% /boot/efi
cgmfs          tmpfs     100K     0  100K    0% /run/cgmanager/fs
tmpfs          tmpfs     794M     0  794M    0% /run/user/1000
</code></pre><p>进入根目录，使用<br><code>du -sh *</code><br>来列出根目录下所有文件夹的使用大小情况，并再进入使用量大的文件夹再次使用次命令，以此类推找着占用空间大的文件，将其删除，一般都是tomcat的日志文件占用量大，及项目的日志文件<br>在删除文件后，将服务器重启，以为在删除日志文件的时候，tomcat还在运行，项目也还在跑。在这样的情况下直接删除日志文件，系统还会默认读取这个被删除的文件，其占用的空间还在继续被进程占用着，在Linux或者Unix系统中，通过rm或者文件管理器删除文件将会从文件系统的目录结构上解除链接(unlink).然而如果文件是被打开的（有一个进程正在使用），那么进程将仍然可以读取该文件，磁盘空间也一直被占用。而我删除的是log文件，删除的时候文件应该正在被使用，所以光靠删除日志文件是不够的。不过也可以将tomcat关闭，让项目不再运行，再将日志文件删除，这时就体现了nginx集群服务的重要性了，同样服务器重启也是如此<br>可以通过一个命令来获得一个已经被删除但是仍然被应用程序占用的文件列表，其命令为<br><code>lsof | grep deleted</code><br>如下部分输出</p>
<pre><code>xm6f@admin-pc:~$ lsof | grep deleted
lsof: WARNING: can&apos;t stat() tracefs file system /sys/kernel/debug/tracing
      Output information may be incomplete.
java      31197            xm6f    1w      REG          8,2 671033021104   41025544 /home/xm6f/dev/apache-tomcat-7.0.78/logs/catalina.out (deleted)
java      31197            xm6f    2w      REG          8,2 671033021104   41025544 /home/xm6f/dev/apache-tomcat-7.0.78/logs/catalina.out (deleted)
java      31197            xm6f    7w      REG          8,2  92820543856   41025989 /home/xm6f/dev/apache-tomcat-7.0.78/logs/catalina.2017-08-16.log (deleted)
java      31197            xm6f    8w      REG          8,2         2937   41026959 /home/xm6f/dev/apache-tomcat-7.0.78/logs/localhost.2017-08-14.log (deleted)
java      31197            xm6f    9w      REG          8,2         2550   41026958 /home/xm6f/dev/apache-tomcat-7.0.78/logs/manager.2017-08-14.log (deleted)
java      31197            xm6f   10w      REG          8,2            0   41025548 /home/xm6f/dev/apache-tomcat-7.0.78/logs/host-manager.2017-08-11.log (deleted)
java      31197  1188      xm6f    1w      REG          8,2 671029150585   41025544 /home/xm6f/dev/apache-tomcat-7.0.78/logs/catalina.out (deleted)
java      31197  1188      xm6f    2w      REG          8,2 671029150585   41025544 /home/xm6f/dev/apache-tomcat-7.0.78/logs/catalina.out (deleted)
java      31197  1188      xm6f    7w      REG          8,2  92816747272   41025989 /home/xm6f/dev/apache-tomcat-7.0.78/logs/catalina.2017-08-16.log (deleted)
</code></pre><p>通过上面可以看得出，以前删除的日志文件，虽然删除了，当时系统还在使用这个文件，系统一直在运行，所以空间一直在占用着，只要系统关闭重启，这样上面那些还在读取已经删除的日志文件的进程就会停止运行，空间自然就回来了<br>结束进程的方法有两种，一种方法是kill掉相应的进程，另一种是停掉使用这个文件的应用，也就是让系统自动停止运行，让os自动回收磁盘空间<br>我这服务器上了解到一个pech项目中有线程会无线循环下去，直接杀死进程也可以，而我值选择重启机器。<br>用到的命令<br>输出当前文件夹下所有文件夹的大小<br><code>du -sh *</code><br><code>du -msh /*</code><br>查看挂载点的大小与使用情况<br><code>df -Th</code><br><code>df -i</code></p>
<p>查找大于10M的文件<br><code>sudo find / -type f -size +10000000c -exec du -sh {} \;</code><br>或者<br><code>sudo find / -type f -size +10M -exec du -sh {} \;</code><br>查看当前目录下一级子文件和子目录占用的磁盘容量<br><code>sudo du -lh --max-depth=1</code><br>占用最多空间的前10个文件或目录<br><code>du -cks * |sort -rn |head -n 10</code></p>
<h3 id="tomcat无日志文件输出"><a href="#tomcat无日志文件输出" class="headerlink" title="tomcat无日志文件输出"></a>tomcat无日志文件输出</h3><p>发现160的三台tomcat没有日志文件输出，即catalina.out这个文件为空，用ls -l命令查看了下权限如下</p>
<pre><code>[xm6f@localhost logs]$ ls -l
总用量 5844760
-rw-r--r--. 1 root root       6653 7月  26 14:38 catalina.2017-07-17.log
-rw-r--r--. 1 root root       9547 7月  26 14:38 catalina.2017-07-26.log
-rw-r--r--. 1 root root      63288 7月  28 16:28 catalina.2017-07-28.log
-rw-r--r--. 1 root root      34028 7月  31 08:30 catalina.2017-07-31.log
-rw-r--r--. 1 root root      61923 8月   1 19:25 catalina.2017-08-01.log
-rw-r--r--. 1 root root      36851 8月   2 16:39 catalina.2017-08-02.log
-rw-r--r--. 1 root root     115277 8月   3 14:06 catalina.2017-08-03.log
-rw-r--r--. 1 root root      57702 8月   4 14:22 catalina.2017-08-04.log
-rw-r--r--. 1 root root     111603 8月   7 17:37 catalina.2017-08-07.log
-rw-r--r--. 1 root root     152436 8月   8 17:54 catalina.2017-08-08.log
-rw-r--r--. 1 root root      72429 8月   9 18:34 catalina.2017-08-09.log
-rw-r--r--. 1 root root      55472 8月  10 17:57 catalina.2017-08-10.log
-rw-r--r--. 1 root root      28248 8月  11 17:21 catalina.2017-08-11.log
-rw-r--r--. 1 root root      31514 8月  14 17:56 catalina.2017-08-14.log
-rw-r--r--. 1 root root      31732 8月  15 15:19 catalina.2017-08-15.log
-rw-r--r--. 1 root root 3815423315 8月  15 15:25 catalina.out
-rw-r--r--. 1 root root          0 7月  26 14:38 host-manager.2017-07-17.log
-rw-r--r--. 1 root root          0 7月  26 14:38 host-manager.2017-07-26.log
-rw-r--r--. 1 root root          0 7月  28 11:49 host-manager.2017-07-28.log
</code></pre><p>都是属于root用户，估计是没权限，<br>所以先关闭tomcat…….这里我也不知道为什么它能启动，毕竟这服务器不是我一个人管，别人都会动<br>使用sudo 命令启动，发现输出个问题，如下</p>
<pre><code>[xm6f@localhost bin]$ sudo ./catalina.sh stop
[sudo] password for xm6f: 
Neither the JAVA_HOME nor the JRE_HOME environment variable is defined
At least one of these environment variable is needed to run this program
</code></pre><p>貌似是找不着jdk和jre，那就给它指定下路径，修改catalina.sh这个文件，在文件开头添加如下</p>
<pre><code>export JAVA_HOME=/home/xm6f/dev/jdk1.7.0_80
export JRE_HOME=/home/xm6f/dev/jdk1.7.0_80/jre
</code></pre><p>之后保存，使用sudo命令运行，后面就有了日志<br>补充一点，防止溢出的优化项的代码添加在catalina.sh这个文件内容中间的</p>
<pre><code>#----- Execute The Requested Command -----------------------------------------
JAVA_OPTS=&quot;$JAVA_OPTS -server -Xms2048m -Xmx2048m -XX:PermSize=1024M -XX:MaxPermSize=1024M&quot;
# Bugzilla 37848: only output this if we have a TTY
</code></pre><p>这个位置<br>代码就是上面的JAVA_OPTS</p>
]]></content>
      
        <categories>
            
            <category> linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> linux </tag>
            
            <tag> centos </tag>
            
            <tag> redis </tag>
            
            <tag> tomcat </tag>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[tomcat配置session共享]]></title>
      <url>/2017/08/12/linux/2017-08-12-tomcat-redis-session-share/</url>
      <content type="html"><![CDATA[<p>现在在公司里需要管理四台服务器，在这四台服务器中都各自装有三台tomcat,其他redis和nginx在其中一些有装，项目部署到不同ip的tomcat，需要实现session共享，也就是需要实现集群。之前配置的是nginx集群，并未涉及到session事物的共享，所以现在要进行配置，实现session集群。</p>
<a id="more"></a>
<p>首先需要准备三个jar包，放到tomcat安装目录的lib文件夹下，每个tomcat都要存放<br>这里我使用到的jar包名如下</p>
<pre><code>tomcat-redis-session-manager-tomcat7.jar 
jedis-2.5.2.jar 
commons-pool2-2.2.jar
</code></pre><p>将其全部复制到tomcat安装路径下的lib文件夹中，然后编辑安装路径下的conf文件夹中的context.xml文件，增加内容如下</p>
<pre><code>&lt;Valve className=&quot;com.orangefunction.tomcat.redissessions.RedisSessionHandlerValve&quot; /&gt;
&lt;Manager className=&quot;com.orangefunction.tomcat.redissessions.RedisSessionManager&quot;
       host=&quot;localhost&quot;
       port=&quot;6379&quot;
       database=&quot;0&quot;
       maxInactiveInterval=&quot;60&quot; /&gt;
</code></pre><p>其中host是配置redis所在机器的ip地址，如果是本台机器，则配置localhost即可，其测试用到的获取sessions的代码如下<br><code>&lt;%= request.getSession().getId() %&gt;</code><br>将其插入到html页面中，我一般就将其设置为html页面的title标签值，这样简单又有用</p>
<h3 id="第一次测试"><a href="#第一次测试" class="headerlink" title="第一次测试"></a>第一次测试</h3><p>这里首先测试了两种情况，<br>第一种：2台tomcat和redis及nginx在同一台机器上<br>结果: 获取的session id一样，这样实现了tomcat的session共享</p>
<p>第二种: 两台不同的机器，机器105上只有1台测试tomcat，机器149上有redis和1台测试tomcat，两台机器上都装的nginx<br>结果: 获取的session id不一样，</p>
<p>这我就一脸懵逼了，差看日志也没啥输出<br>猜测是不能跨ip来进行session共享，不过有感觉有点浮夸，抱着试一试的心态进行了下一步测试</p>
<h3 id="第二次测试"><a href="#第二次测试" class="headerlink" title="第二次测试"></a>第二次测试</h3><p>出现第三种情况，就是将前两种情况进行整合<br>就是两台机器，105和149，<br>机器105中有两台测试的tomcat,即tomcat8081和tomcat8082，有个nginx,nginx并为这两台tomcat进行负载均衡<br>机器149中有两台测试的tomcat,即tomcat8081和tomcat8082, 有个nginx，nginx将这两台tomcat进行了负载均衡，有个redis<br>将机器105中的tomcat8081进行负载均衡添加到149中的nginx里面，<br>为四台tomcat都配置redis的session共享，并都指向149中的redis</p>
<p>结果: 机器105中的tomcat8081和机器149中的两台tomcat使用的session id是一样的，单单只有机器105中的tomcat8082使用的是另一个session id</p>
<p>出现这样的结果让我很吃惊，跨ip是肯定可以跨的，不过为什么又会有一台获取不到session id，其区别也只是tomcat8082和其他tomcat不在同一个nginx负载均衡集群中，所以猜想难道redis的session会和nginx的负载均衡结合起来？所以还是进行下一步的测试</p>
<h3 id="第三次测试"><a href="#第三次测试" class="headerlink" title="第三次测试"></a>第三次测试</h3><p>这次是一台机器，即149，有三台tomcat，分别为tomcat8080,tomcat8081,tomcat8082.还有个nginx和redis<br>将tomcat8080和tomcat8081使用nginx来达到负载均衡，tomcat8082不添加进去<br>并都配置好session共享</p>
<p>结果: 三台tomcat使用的session id都相同<br>这可得怎么搞……</p>
<p>总结上面的三次测试，感觉单靠redis并不能达到跨ip的session共享的结果，只能达到本台机器下的tomcat进行seession共享，而如果使用nginx来配合redis，解决跨ip问题，那么就可以实现跨ip的session共享，这看感觉有点不符合逻辑，因为redis和nginx并不是同一家公司开发的啊，为什么还需要进行互补…看网上的一些教程，貌似都是单靠redis就可以实现session共享，但我也不能确定，总之就是，现在如果我要达到跨ip的session共享，那么就需要nginx的配合，就可以实现</p>
<p>测试过程的终端输出就不贴了。</p>
]]></content>
      
        <categories>
            
            <category> linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> linux </tag>
            
            <tag> centos </tag>
            
            <tag> redis </tag>
            
            <tag> tomcat </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[搭建centos服务器]]></title>
      <url>/2017/08/07/linux/2017-08-07-install-centos-server/</url>
      <content type="html"><![CDATA[<p>7月31号第一天上班，boss找那个java开发的项目经理带我。第一天的工作内容就是搭建个centos服务器，其中已经可以外网访问了。centos中需要配置三台tomcat,不同端口访问，并配置redis数据库。工作不难，下面这些就是我在搭建过程中的记录</p>
<h3 id="安装Centos7系统"><a href="#安装Centos7系统" class="headerlink" title="安装Centos7系统"></a>安装Centos7系统</h3><p>原本主机中安装的是Ubuntu系统，需要将它全部删除，安装centos系统，这个不难不扯。不过在安装过程中需要考虑分区问题及是否需要图形化界面，当然也需要创建账户名和密码及root密码，这里我使用了图形化界面，安装了gnome桌面环境，要安装图形化界面在安装过程中取消最小安装，选择自己所需要的即可。</p>
<a id="more"></a>
<p>不过安装完centos系统后，其中需要配置一项，就是设置sudo命令可以被普通用户xm6f所使用，不然将会报<br>    xm6f 不在 sudoers 文件中。此事将被报告。<br>这个错，所以使用命令操作/etc/sudoers这个文件，在文件末尾添加如下一行<br><code>xm6f ALL=(ALL) ALL</code><br>完后就可以使用在普通用户下使用sudo命令来暂时使用root.按需求，在安装完系统后需要将主机ip设为静态ip，将ip固定。</p>
<h4 id="设置静态ip"><a href="#设置静态ip" class="headerlink" title="设置静态ip"></a>设置静态ip</h4><p>可以使用命令ifconfig查看ip信息，但现在需要进行更改，就需要修改网卡的配置文件，该配置文件存放在/etc/sysconfig/network-scripts目录下，其名字为”ifcfg-“加上网卡名，首先先来到network-scripts目录下，如下输出</p>
<pre><code>[xm6f@localhost ~]$ cd /etc/sysconfig/network-scripts/
[xm6f@localhost network-scripts]$ ls
ifcfg-enp2s0  ifdown-ppp       ifup-ib      ifup-Team
ifcfg-lo      ifdown-routes    ifup-ippp    ifup-TeamPort
ifdown        ifdown-sit       ifup-ipv6    ifup-tunnel
ifdown-bnep   ifdown-Team      ifup-isdn    ifup-wireless
ifdown-eth    ifdown-TeamPort  ifup-plip    init.ipv6-global
ifdown-ib     ifdown-tunnel    ifup-plusb   network-functions
ifdown-ippp   ifup             ifup-post    network-functions-ipv6
ifdown-ipv6   ifup-aliases     ifup-ppp
ifdown-isdn   ifup-bnep        ifup-routes
ifdown-post   ifup-eth         ifup-sit
[xm6f@localhost network-scripts]$ sudo gedit ifcfg-enp2s0
...
</code></pre><p>其中上面的ifcfg-enp2s0就是本centos7服务器主机的网卡配置文件，我们需要修改的就是这个配置文件，起初这个配置文件的内容如下</p>
<pre><code>TYPE=Ethernet
BOOTPROTO=dhcp
DEFROUTE=yes
PEERDNS=yes
PEERROUTES=yes
IPV4_FAILURE_FATAL=no
IPV6INIT=yes
IPV6_AUTOCONF=yes
IPV6_DEFROUTE=yes
IPV6_PEERDNS=yes
IPV6_PEERROUTES=yes
IPV6_FAILURE_FATAL=no
IPV6_ADDR_GEN_MODE=stable-privacy
NAME=enp2s0
UUID=e65481a0-7c13-426d-99cb-b8b281294cb8
DEVICE=enp2s0
ONBOOT=no
</code></pre><p>这里我们需要将其更改，首先修改如下两项</p>
<pre><code>BOOTPROTO=static
ONBOOT=yes
</code></pre><p>之后，再在末尾添加下面几项</p>
<pre><code>IPADDR=192.168.1.149    #最后要的ip地址
GATEWAY=192.168.1.1    #网关
DNS1=192.168.1.1
</code></pre><p>之后运行命令<br><code>sudo systemctl restart network.service</code><br>或<br><code>sudo service network restart</code><br>重启网卡服务,之后查看ip信息则用命令<br><code>ip add</code><br>用此命令来查看ip信息，ip更改过来并且能上网，才算成功，之后就是为这台centos7服务器主机搭建java环境环境安装tomcat等，搭建java环境之前，需要将centos系统中的openjdk卸载，这是centos原装的，openjdk用得少，一般都用oraclejdk,所以看下面如何卸载openjdk</p>
<h4 id="卸载openjdk"><a href="#卸载openjdk" class="headerlink" title="卸载openjdk"></a>卸载openjdk</h4><p>卸载centos7上的openjdk<br>先查看,使用命令<br><code>rpm -qa | grep java</code><br>例如我的输出,显示如下信息</p>
<pre><code>java-1.8.0-openjdk-1.8.0.102-4.b14.el7.x86_64
javapackages-tools-3.4.1-11.el7.noarch
java-1.8.0-openjdk-headless-1.8.0.102-4.b14.el7.x86_64
tzdata-java-2016g-2.el7.noarch
python-javapackages-3.4.1-11.el7.noarch
java-1.7.0-openjdk-headless-1.7.0.111-2.6.7.8.el7.x86_64
java-1.7.0-openjdk-1.7.0.111-2.6.7.8.el7.x86_64
</code></pre><p>卸载命令</p>
<pre><code>rpm -e --nodeps java-1.8.0-openjdk-1.8.0.102-4.b14.el7.x86_64
rpm -e --nodeps java-1.8.0-openjdk-headless-1.8.0.102-4.b14.el7.x86_64
</code></pre><p>还可以这样卸载</p>
<pre><code>java-1.8.0-openjdk-1.8.0.102-4.b14.el7.x86_64
java-1.8.0-openjdk-headless-1.8.0.102-4.b14.el7.x86_64
</code></pre><p>最后我是删成了这样</p>
<pre><code>[xm6f@localhost jdk1.7.0_80]$ rpm -qa | grep java
javapackages-tools-3.4.1-11.el7.noarch
tzdata-java-2016g-2.el7.noarch
python-javapackages-3.4.1-11.el7.noarch
[xm6f@localhost jdk1.7.0_80]$ java
-bash: /usr/bin/java: 没有那个文件或目录
</code></pre><p>然后就是安装oraclejdk，配置环境变量，搭建java环境可以看这移步到这篇文章:[java环境搭建][]</p>
<h3 id="安装Tomcat"><a href="#安装Tomcat" class="headerlink" title="安装Tomcat"></a>安装Tomcat</h3><p>在安装Tomcat之前，因为Tomcat是需要java环境，所以先要安装为centos服务器安装jdk。然而需要在自己电脑上操作服务器，公司给我配置的电脑是windows笔记本，那么就需要在电脑上安装xshell这个软件，用它来连接操作centos服务器，下载安装xshell后，打开xshell，利用ip和账户名和密码连接到centos7这台电脑，并了解centos7这台电脑上是否安装lrzsz这个文件传输工具，无则命令安装<br><code>sudo yum install -y lrzsz</code><br>之后再输入命令’rz’用来上传文件，这里需要注意到，上传之前可能需要切换到/tmp文件夹下来进行上传，貌似是权限的问题<br>上传完成之后，使用tar命令来解压文件，如命令<br><code>sudo tar -zvxf jdk-8u144-linux-x64.tar.gz</code><br>通常解压到/usr/local目录…解压完后直接在安装目录尝试启动tomcat看看，因为这里需要配置多个tomcat，那么就不能为单一的tomcat配置环境变量，这样会导致在哪都只能启动配置了环境变量的tomcat，而不能启动其他的tomcat。所以现在便捷的方式是不为任何一个tomcat配置环境变量，那么这样的话，启动tomcat需要到相应的tomcat文件目录中的bin目录下运行命令<code>./catalina.sh start</code> 或<code>./startup.sh</code>来启动，关闭则为<code>./catalina.sh stop</code>或<code>./shutdown.sh</code></p>
<h4 id="启动tomcat并开放8080端口"><a href="#启动tomcat并开放8080端口" class="headerlink" title="启动tomcat并开放8080端口"></a>启动tomcat并开放8080端口</h4><p>有可能cd不能进入tomcat里的/bin文件夹，会提示权限不够，或者在启动Tomcat的时候提示权限不够，可以先用命令<br><code>ls -l</code><br>来查看下文件或文件夹的运行权限和所属用户组，如果运行权限不足则增加相应的权限，或者更改文件的拥有者，例如命令<br><code>sudo chown -R xm6f bin</code><br>即将bin目录文件的拥有者更改成xm6f普通用户，这样就可以进入bin目录了，进入bin目录后，就可以运行命令来启动tomcat了<br>命令<br><code>./catalina.sh start</code>或者<code>./startup.sh</code><br>因为使用的是8080端口，大于1024端口，而且文件所有者已经更改成了xm6f普通用户，所以不需要使用root来进行启动，启动之后再centos服务器电脑上就使用<code>http://localhost:8080</code>这个链接来访问tomcat服务器主页，那我在自己电脑上来进行访问，其链接为<code>http://192.168.1.149:8080</code>来进行访问。不过需要注意的是，这样访问需要centos服务器已经对外开放了8080端口，默认对外开发的端口为20，并没有8080，所以需要手动开启，不然照样访问不了<br>其开启对外开发8080端口命令如下<br><code>sudo firewall-cmd --zone=public --add-port=8080/tcp --permanent</code><br>运行上面这条命令后，如果运行正常返回success那么再运行下面这条命令<br><code>sudo firewall-cmd --reload</code><br>若同样正常返回success那么就成功的对外开发了8080端口，另外提一点，因为现在操作的是centos7系统，这里可以有两种方式来开放端口，一种就是上面的使用firewall-cmd命令，另一种就是操作iptables,iptables我不大会操作，不过后期再补上。如果没使用firewall-cmd来开放端口的的话，估计就是iptables里面开放了。我之前就是，同事使用iptables开放了端口，而我又不知道，使用firewall-cmd命令<br><code>sudo firewall-cmd --list-ports</code><br>查看了所以的已经开放了的端口号，发现我要开放的端口在这个输出中并不存在，那就肯定是iptables上进行开放了。<br>firewall-cmd关闭已经开发的端口命令<br><code>sudo firewall-cmd --zone=public --remove-port=8080/tcp --permanent</code></p>
<h4 id="配置三台tomcat"><a href="#配置三台tomcat" class="headerlink" title="配置三台tomcat"></a>配置三台tomcat</h4><p>而需要配置三台tomcat，那就需要有三个tomcat安装文件，如下</p>
<pre><code>[xm6f@localhost tomcat]$ ls
apache-tomcat-7.0.79  apache-tomcat-7.0.79-2  apache-tomcat-7.0.79-3
</code></pre><p>依照上面的输出顺序，我配置的端口依次是8080,8081,8082,具体的配置中，apache-tomcat-7.0.79配置文件可以不变，只需要更改后面两个tomcat的配置文件，避免同时启动三台tomcat时出现端口占用的情况。其tomcat配置文件即安装目录的/conf/server.xml，其原始内容为</p>
<pre><code>&lt;?xml version=&apos;1.0&apos; encoding=&apos;utf-8&apos;?&gt;
&lt;!--
  Licensed to the Apache Software Foundation (ASF) under one or more
  contributor license agreements.  See the NOTICE file distributed with
  this work for additional information regarding copyright ownership.
  The ASF licenses this file to You under the Apache License, Version 2.0
  (the &quot;License&quot;); you may not use this file except in compliance with
  the License.  You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
--&gt;
&lt;!-- Note:  A &quot;Server&quot; is not itself a &quot;Container&quot;, so you may not
     define subcomponents such as &quot;Valves&quot; at this level.
     Documentation at /docs/config/server.html
 --&gt;
&lt;Server port=&quot;8005&quot; shutdown=&quot;SHUTDOWN&quot;&gt;
  &lt;Listener className=&quot;org.apache.catalina.startup.VersionLoggerListener&quot; /&gt;
  &lt;!-- Security listener. Documentation at /docs/config/listeners.html
  &lt;Listener className=&quot;org.apache.catalina.security.SecurityListener&quot; /&gt;
  --&gt;
  &lt;!--APR library loader. Documentation at /docs/apr.html --&gt;
  &lt;Listener className=&quot;org.apache.catalina.core.AprLifecycleListener&quot; SSLEngine=&quot;on&quot; /&gt;
  &lt;!--Initialize Jasper prior to webapps are loaded. Documentation at /docs/jasper-howto.html --&gt;
  &lt;Listener className=&quot;org.apache.catalina.core.JasperListener&quot; /&gt;
  &lt;!-- Prevent memory leaks due to use of particular java/javax APIs--&gt;
  &lt;Listener className=&quot;org.apache.catalina.core.JreMemoryLeakPreventionListener&quot; /&gt;
  &lt;Listener className=&quot;org.apache.catalina.mbeans.GlobalResourcesLifecycleListener&quot; /&gt;
  &lt;Listener className=&quot;org.apache.catalina.core.ThreadLocalLeakPreventionListener&quot; /&gt;

  &lt;!-- Global JNDI resources
       Documentation at /docs/jndi-resources-howto.html
  --&gt;
  &lt;GlobalNamingResources&gt;
    &lt;!-- Editable user database that can also be used by
         UserDatabaseRealm to authenticate users
    --&gt;
    &lt;Resource name=&quot;UserDatabase&quot; auth=&quot;Container&quot;
              type=&quot;org.apache.catalina.UserDatabase&quot;
              description=&quot;User database that can be updated and saved&quot;
              factory=&quot;org.apache.catalina.users.MemoryUserDatabaseFactory&quot;
              pathname=&quot;conf/tomcat-users.xml&quot; /&gt;
  &lt;/GlobalNamingResources&gt;

  &lt;!-- A &quot;Service&quot; is a collection of one or more &quot;Connectors&quot; that share
       a single &quot;Container&quot; Note:  A &quot;Service&quot; is not itself a &quot;Container&quot;,
       so you may not define subcomponents such as &quot;Valves&quot; at this level.
       Documentation at /docs/config/service.html
   --&gt;
  &lt;Service name=&quot;Catalina&quot;&gt;

    &lt;!--The connectors can use a shared executor, you can define one or more named thread pools--&gt;
    &lt;!--
    &lt;Executor name=&quot;tomcatThreadPool&quot; namePrefix=&quot;catalina-exec-&quot;
        maxThreads=&quot;150&quot; minSpareThreads=&quot;4&quot;/&gt;
    --&gt;


    &lt;!-- A &quot;Connector&quot; represents an endpoint by which requests are received
         and responses are returned. Documentation at :
         Java HTTP Connector: /docs/config/http.html (blocking &amp; non-blocking)
         Java AJP  Connector: /docs/config/ajp.html
         APR (HTTP/AJP) Connector: /docs/apr.html
         Define a non-SSL HTTP/1.1 Connector on port 8080
    --&gt;
    &lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot;
               connectionTimeout=&quot;20000&quot;
               redirectPort=&quot;8443&quot; /&gt;
    &lt;!-- A &quot;Connector&quot; using the shared thread pool--&gt;
    &lt;!--
    &lt;Connector executor=&quot;tomcatThreadPool&quot;
               port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot;
               connectionTimeout=&quot;20000&quot;
               redirectPort=&quot;8443&quot; /&gt;
    --&gt;
    &lt;!-- Define a SSL HTTP/1.1 Connector on port 8443
         This connector uses the BIO implementation that requires the JSSE
         style configuration. When using the APR/native implementation, the
         OpenSSL style configuration is required as described in the APR/native
         documentation --&gt;
    &lt;!--
    &lt;Connector port=&quot;8443&quot; protocol=&quot;org.apache.coyote.http11.Http11Protocol&quot;
               maxThreads=&quot;150&quot; SSLEnabled=&quot;true&quot; scheme=&quot;https&quot; secure=&quot;true&quot;
               clientAuth=&quot;false&quot; sslProtocol=&quot;TLS&quot; /&gt;
    --&gt;

    &lt;!-- Define an AJP 1.3 Connector on port 8009 --&gt;
    &lt;Connector port=&quot;8009&quot; protocol=&quot;AJP/1.3&quot; redirectPort=&quot;8443&quot; /&gt;


    &lt;!-- An Engine represents the entry point (within Catalina) that processes
         every request.  The Engine implementation for Tomcat stand alone
         analyzes the HTTP headers included with the request, and passes them
         on to the appropriate Host (virtual host).
         Documentation at /docs/config/engine.html --&gt;

    &lt;!-- You should set jvmRoute to support load-balancing via AJP ie :
    &lt;Engine name=&quot;Catalina&quot; defaultHost=&quot;localhost&quot; jvmRoute=&quot;jvm1&quot;&gt;
    --&gt;
    &lt;Engine name=&quot;Catalina&quot; defaultHost=&quot;localhost&quot;&gt;

      &lt;!--For clustering, please take a look at documentation at:
          /docs/cluster-howto.html  (simple how to)
          /docs/config/cluster.html (reference documentation) --&gt;
      &lt;!--
      &lt;Cluster className=&quot;org.apache.catalina.ha.tcp.SimpleTcpCluster&quot;/&gt;
      --&gt;

      &lt;!-- Use the LockOutRealm to prevent attempts to guess user passwords
           via a brute-force attack --&gt;
      &lt;Realm className=&quot;org.apache.catalina.realm.LockOutRealm&quot;&gt;
        &lt;!-- This Realm uses the UserDatabase configured in the global JNDI
             resources under the key &quot;UserDatabase&quot;.  Any edits
             that are performed against this UserDatabase are immediately
             available for use by the Realm.  --&gt;
        &lt;Realm className=&quot;org.apache.catalina.realm.UserDatabaseRealm&quot;
               resourceName=&quot;UserDatabase&quot;/&gt;
      &lt;/Realm&gt;

      &lt;Host name=&quot;localhost&quot;  appBase=&quot;webapps&quot;
            unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot;&gt;

        &lt;!-- SingleSignOn valve, share authentication between web applications
             Documentation at: /docs/config/valve.html --&gt;
        &lt;!--
        &lt;Valve className=&quot;org.apache.catalina.authenticator.SingleSignOn&quot; /&gt;
        --&gt;

        &lt;!-- Access log processes all example.
             Documentation at: /docs/config/valve.html
             Note: The pattern used is equivalent to using pattern=&quot;common&quot; --&gt;
        &lt;Valve className=&quot;org.apache.catalina.valves.AccessLogValve&quot; directory=&quot;logs&quot;
               prefix=&quot;localhost_access_log.&quot; suffix=&quot;.txt&quot;
               pattern=&quot;%h %l %u %t &amp;quot;%r&amp;quot; %s %b&quot; /&gt;

      &lt;/Host&gt;
    &lt;/Engine&gt;
  &lt;/Service&gt;
&lt;/Server&gt;
</code></pre><p>其需要更改的地方只有三处<br>第一处如下</p>
<pre><code>&lt;Server port=&quot;8005&quot; shutdown=&quot;SHUTDOWN&quot;&gt;
</code></pre><p>第二台更改成9005,第三台更改成7005<br>第二处如下</p>
<pre><code>&lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot;
    connectionTimeout=&quot;20000&quot;
    redirectPort=&quot;8443&quot; /&gt;
</code></pre><p>第二台更改成8081,9443，第三台更改成8082,7443<br>第三处如下</p>
<pre><code>&lt;Connector port=&quot;8009&quot; protocol=&quot;AJP/1.3&quot; redirectPort=&quot;8443&quot; /&gt;
</code></pre><p>第二胎更改成9009,9443，第三台更改成7009,7443<br>并且将8081和8082这两个端口都进行对外开放，这样就可以了，要测试的话，分别到各个tomcat目录中将其都启动，浏览器输入ip地址和对应的端口号即可。</p>
<p>至此，就完成了tomcat的安装</p>
<p>另外提下，如果使用tomcat页面中<code>manager-app</code>按钮，实现登陆管理，那么就需要修改<code>/conf/tomcat-users.xml</code>这个文件来设置登录的用户名和密码，这里修改成如下，这里的修改就是取消注释后再进行修改<br>或者直接再文件底部，但需要在tomcat-user标签里面，这里我添加代码的代码如下</p>
<pre><code>&lt;role rolename=&quot;tomcat&quot; /&gt;
&lt;role rolename=&quot;admin&quot;/&gt;
&lt;role rolename=&quot;admin-gui&quot;/&gt;
&lt;role rolename=&quot;manager&quot;/&gt;
&lt;role rolename=&quot;manager-gui&quot;/&gt;
&lt;role rolename=&quot;manager-script&quot;/&gt;
&lt;user username=&quot;tomcat&quot; password=&quot;tomcat&quot; roles=&quot;tomcat,admin-gui,admin,manager,manager-gui,manager-script&quot;/&gt;
</code></pre><p>即用户名和密码都为tomcat</p>
<h3 id="安装redis"><a href="#安装redis" class="headerlink" title="安装redis"></a>安装redis</h3><p>centos7服务器电脑还需要安装redis<br>还没接触过redis，后面跟同事了解到，redis是使用c编写的，redis一般在系统开发中只用作缓存，因为如果要使用的数据量太大的话，而且需要多次使用，如果不使用缓存，那么在每一次请求数据的时候都需要从数据库中进行查找，这样不仅耗时也好资源，所以如果使用redis缓存机制，用户请求数据的时候，如果数据量过大，就会使用redis将该数据暂时放入内存中，以键值对的方式存放着，并于该请求用户的临时id进行关联，使得再次使用到该数据的时候可以直接使用get方式从内存中读取，而不需要从数据库中查…..ok<br>那么下载安装,下载redis-2.8.4.tar压缩包后，将压缩包上传到centos7服务器中，现在操作的这台主机不知道为什么，只能通过tmp目录上传，那么每次上传完成之后在tmp目录下进行解压，之后直接cd进入解压得到的文件夹，例如这里解压得到的文件夹名为redis-2.8.6，使用命令进行编译，再编译完成之后会在目录redis-2.8.6/src下会得到可执行程序，最好把可执行程序单独拿出来，放到/usr/local目录下，同样也把存放在/redis-2.8.6目录下的redis.conf这个配置文件也拿出来，这是解压之后得到的。在/usr/local/目录下创建一个redis文件夹来一起存放，之后手动启动和关闭redis都在这个目录进行操作，后期配置开机启动也使用这个文件夹里的可执行程序。<br>因为需要gcc编译，查看了后知道未安装gcc，那么先安装gcc,其命令<br><code>sudo yum install gcc make</code><br>之后解压redis-2.8.4.tar,并编译<br>解压命令<br><code>sudo tar -zvxf redis-2.8.4.tar</code><br>解压之后cd到解压得到的目录中，运行命令sudo make来编译，出了个错误</p>
<pre><code>zmalloc.h:50:31: 致命错误：jemalloc/jemalloc.h：没有那个文件或目录
</code></pre><p>网上查了之后才知道命令中需要添加一个参数变量,运行命令<br><code>sudo make MALLOC=libc</code><br>就不会出现这个问题，然后测试redis是否安装成功，运行命令<br><code>make test</code><br>时，出现个问题</p>
<pre><code>You need tcl 8.5 or newer in order to run the Redis test
</code></pre><p>看着抛出的错误，提示这需要下载tcl8.5并编译安装</p>
<pre><code>cd  /usr/local/tcl8.6.1/unix/  
sudo ./configure  
sudo make  
sudo make install 
</code></pre><p>之后，再<code>make test</code>，这里我的还是不行，不知道为什么,我选择的是先不管它，直接将redis的服务器和客户端等复制到/usr/local/bin/目录下<br><code>sudo cp redis-server redis-cli /usr/local/bin/</code><br>及其他一些可运行程序<br><code>sudo cp redis-sentinel redis-benchmark redis-check-aof redis-check-dump /usr/local/bin/</code><br>之后新开一个终端连接，直接命令redis-server和redis-cli发现都可以运行,并且在redis-cli下测试都正常，如下</p>
<pre><code>[xm6f@localhost redis-2.8.4]$ ./src/redis-cli 
127.0.0.1:6379&gt; set name aa
OK
127.0.0.1:6379&gt; get name
&quot;aa&quot;
127.0.0.1:6379&gt; 
</code></pre><p>只要这样测试结果正常，那就意味着redis安装成功，不过，redis需要配置开机启动，redis运行的端口号一般默认时6379</p>
<h4 id="配置redis开机启动"><a href="#配置redis开机启动" class="headerlink" title="配置redis开机启动"></a>配置redis开机启动</h4><p>所以为了方便启动和管理，我在/usr/local/下新建了个redis文件夹，并将安装目录下是srz文件夹中的redis-server，redis-cli，redis-sentinel，redis-benchmark，redis-check-aof，redis-check-dump及redis.conf复制到该redis文件夹下，配置开机启动的方式就是在/etc/rc.d/init.d目录下创建一个启动脚本，命令如下<br><code>sudo vim redis</code><br>脚本是从网上找的，只是进行了修改，其内容如下</p>
<pre><code>#!/bin/sh
#chkconfig: 345 86 14
#description: Startup and shutdown script for Redis

PROGDIR=/usr/local/redis
PROGNAME=redis-server
DAEMON=$PROGDIR/$PROGNAME
CONFIG=/usr/local/redis/redis.conf
PIDFILE=/var/run/redis.pid
DESC=&quot;redis daemon&quot;
SCRIPTNAME=/etc/rc.d/init.d/redis

start()
{
    if test -x $DAEMON
        then
        echo -e &quot;Starting $DESC: $PROGNAME&quot;
                  if $DAEMON $CONFIG
                  then
                            echo -e &quot;OK&quot;
                  else
                            echo -e &quot;failed&quot;
                  fi
        else
                  echo -e &quot;Couldn&apos;t find Redis Server ($DAEMON)&quot;
        fi
}

stop()
{
        if test -e $PIDFILE
        then
                  echo -e &quot;Stopping $DESC: $PROGNAME&quot;
                  if kill `cat $PIDFILE`
                  then
                            echo -e &quot;OK&quot;
                  else
                            echo -e &quot;failed&quot;
                  fi
        else
                  echo -e &quot;No Redis Server ($DAEMON) running&quot;
        fi
}

restart()
{
    echo -e &quot;Restarting $DESC: $PROGNAME&quot;
    stop
        start
}

list()
{
        ps aux | grep $PROGNAME
}

case $1 in
        start)
                  start
        ;;
        stop)
        stop
        ;;
        restart)
        restart
        ;;
        list)
        list
        ;;

        *)
        echo &quot;Usage: $SCRIPTNAME {start|stop|restart|list}&quot; &gt;&amp;2
        exit 1
        ;;
esac
exit 0
</code></pre><p>之后就需要修改对redis进行chkconfig配置，其命令如下</p>
<pre><code>sudo chkconfig --add redis
sudo chkconfig --level 345 redis on    #345这个数字根据脚本中来定
sudo chkconfig --list redis
</code></pre><p>之后就可以重启系统进行测试了，只要确定redis能在开机后启动就可以了<br>获取详细信息命令<br><code>./redis-server --help</code><br><code>./redis-cli --help</code><br>关闭命令<br><code>pkill redis-server</code><br>或<br><code>redis-cli shutdown</code></p>
<h4 id="手动启动redis"><a href="#手动启动redis" class="headerlink" title="手动启动redis"></a>手动启动redis</h4><p>手动启动redis一般需要到redis的安装目录的src文件夹下运行redis-server，不过这里我已经将这些可运行程序及配置文件拷贝到/usr/local/redis/目录下，所以可以直接在这个目录下手动启动redis,其命令如下</p>
<pre><code>cd /usr/local/redis
./redis-server redis.conf    #启动redis
./redis-cli -p 端口号 shutdown    #关闭redis服务

./redis-cli        #启动redis客户端
</code></pre><p>查看redis服务是否启动，命令如下<br><code>ps -aux | grep redis</code><br>查看某端口是否被占用,命令如下<br><code>netstat –tunpl | grep 端口</code><br>后期配置<br>在/etc/sysctl.conf文件中添加下面代码:<br><code>vm.overcommit_memory=1</code><br>这个代码可以解决下面这个问题</p>
<pre><code>[3876] 01 Aug 14:09:11.809 # WARNING overcommit_memory is set to 0! Background save may fail under low memory condition. To fix this issue add &apos;vm.overcommit_memory = 1&apos; to /etc/sysctl.conf and then reboot or run     the command &apos;sysctl vm.overcommit_memory=1&apos; for this to take effect.
</code></pre><h3 id="安装nginx服务"><a href="#安装nginx服务" class="headerlink" title="安装nginx服务"></a>安装nginx服务</h3><p>nginx是负责均衡服务器，是c语言开发的，相当于一个调配工具，那个tomcat压力大就调用压力轻的来顶</p>
<h4 id="配置ngin环境"><a href="#配置ngin环境" class="headerlink" title="配置ngin环境"></a>配置ngin环境</h4><p>安装nginx之前先安装好其所需环境<br>1.安装gcc<br>安装 nginx 需要先将官网下载的源码进行编译，编译依赖 gcc 环境，<br>命令<br><code>yum install gcc-c++</code><br>2.安装PCRE库  pcre-devel库<br>PCRE(Perl Compatible Regular Expressions) 是一个Perl库，包括 perl 兼容的正则表达式库。nginx 的 http 模块使用 pcre 来解析正则表达式，所以需要在 linux 上安装 pcre 库，pcre-devel 是使用 pcre 开发的一个二次开发库。nginx也需要此库<br>命令<br><code>yum install -y pcre pcre-devel</code><br>3.zlib 安装<br>zlib 库提供了很多种压缩和解压缩的方式， nginx 使用 zlib 对 http 包的内容进行 gzip ，所以需要在 Centos 上安装 zlib 库<br>命令<br><code>yum install -y zlib zlib-devel</code><br>4.OpenSSL 安装<br>OpenSSL 是一个强大的安全套接字层密码库，囊括主要的密码算法、常用的密钥和证书封装管理功能及 SSL 协议,nginx 不仅支持 http 协议，还支持 https（即在ssl协议上传输http），所以需要在 Centos 安装 OpenSSL 库<br>命令<br><code>yum install -y openssl openssl-devel</code></p>
<h4 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a>安装nginx</h4><p>在tmp文件夹下，使用<code>rz</code>命令上传下载好的nginx-1.12.1.tar压缩文件，之后对其进行解压，将得到一个nginx-1.12.1文件夹，之后安装的命令如下</p>
<pre><code>cd nginx-1.12.1
sudo ./configure
sudo make &amp;&amp; sudo make install
</code></pre><p>这样的编译安装方式会自动将nginx安装到/usr/local/nginx下，如果我们需要自定义nginx的安装目录，例如我需要安装在/home/xm6f/dev/nginx-1.12.1目录下，那么可以使用下面的命令<br><code>./configure --prefix=/home/xm6f/dev/nginx-1.12.1</code><br>然后我们进入到安装目录下的sbin文件夹中，使用命令<br><code>sudo ./nginx</code><br>就可以运行nginx了<br>提示<br>如果不使用sudo来启动nginx就会出现如下错误</p>
<pre><code>nginx: [emerg] bind() to 0.0.0.0:80 failed (13: Permission denied)
</code></pre><p>这个错误不是文件权限错误，而是端口权限的错误，在linux系统中，所有启动数字小于1024的端口都需要root权限，而nginx使用的80端口，所以，就需要sudo使用root身份</p>
<h4 id="nginx启动与关闭"><a href="#nginx启动与关闭" class="headerlink" title="nginx启动与关闭"></a>nginx启动与关闭</h4><p>启动、停止nginx的命令如下</p>
<pre><code>cd /usr/local/nginx/sbin/
sudo ./nginx  : 启动nginx
sudo ./nginx -s stop  : 此方式相当于先查出nginx进程id再使用kill命令强制杀掉进程
sudo ./nginx -s quit  : 此方式是待nginx进程处理任务完毕进行停止
sudo ./nginx -s reload  : 重启
</code></pre><p>之后，跟redis一样，也需要将nginx添加开机启动，开机启动我不是特别了解，网上了解到好像有两种区别，一种是如果直接使用编译安装的方式，那其添加到开机启动的方法就是编辑/etc/rc.local这个文件，往其中添加下面的代码<br><code>/usr/local/nginx/sbin/nginx</code><br>然后就是修改/etc/rc.local这个文件的权限，在/etc目录下使用命令<br><code>sudo chmod 755 rc.local</code><br>如果不修改这个文件的权限，那其开机后只会启动一个进程，如下</p>
<pre><code>Last login: Thu Aug  3 11:22:37 2017 from 192.168.1.70
[xm6f@localhost ~]$ ps -ef | grep nginx
xm6f      2963  2919  0 13:53 pts/0    00:00:00 grep --color=auto nginx
</code></pre><p>这个进程只能被普通用户xm6f控制，而正常启动的nginx会有三个进程，如下</p>
<pre><code>Type `help&apos; to learn how to use Xshell prompt.
[c:\~]$ open

Connecting to 192.168.1.149:22...
Connection established.
To escape to local shell, press &apos;Ctrl+Alt+]&apos;.

Last login: Thu Aug  3 13:53:21 2017 from 192.168.1.70
[xm6f@localhost ~]$ ps -ef | grep nginx
root      1245     1  0 13:55 ?        00:00:00 nginx: master process /usr/local/nginx/sbin/nginx
nobody    1246  1245  0 13:55 ?        00:00:00 nginx: worker process
xm6f      2974  2923  0 13:57 pts/0    00:00:00 grep --color=auto nginx
[xm6f@localhost ~]$ 
</code></pre><p>另一个区别就是如果是使用yum命令安装的方式，就是用systemctl来启动，具体我也不了解……<br>到现在为止，已经成功的安装了nginx并设为开机启动了,那现在需要做的就是配合前面安装的三台tomcat来实现负载均衡，打开nginx安装目录中conf文件夹下的nginx.conf这个配置文件，它是nginx的配置文件，其原始的内容如下</p>
<pre><code>#user  nobody;
worker_processes  1;

#error_log  logs/error.log;
#error_log  logs/error.log  notice;
#error_log  logs/error.log  info;

#pid        logs/nginx.pid;


events {
    worker_connections  1024;
}


http {
    include       mime.types;
    default_type  application/octet-stream;

    #log_format  main  &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;
    #                  &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos;
    #                  &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;;

    #access_log  logs/access.log  main;

    sendfile        on;
    #tcp_nopush     on;

    #keepalive_timeout  0;
    keepalive_timeout  65;

    #gzip  on;

    server {
        listen       80;
        server_name  localhost;

        #charset koi8-r;

        #access_log  logs/host.access.log  main;

        location / {
            root   html;
            index  index.html index.htm;
        }

        #error_page  404              /404.html;

        # redirect server error pages to the static page /50x.html
        #
        error_page   500 502 503 504  /50x.html;
        location = /50x.html {
            root   html;
        }

        # proxy the PHP scripts to Apache listening on 127.0.0.1:80
        #
        #location ~ \.php$ {
        #    proxy_pass   http://127.0.0.1;
        #}

        # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000
        #
        #location ~ \.php$ {
        #    root           html;
        #    fastcgi_pass   127.0.0.1:9000;
        #    fastcgi_index  index.php;
        #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;
        #    include        fastcgi_params;
        #}

        # deny access to .htaccess files, if Apache&apos;s document root
        # concurs with nginx&apos;s one
        #
        #location ~ /\.ht {
        #    deny  all;
        #}
    }


    # another virtual host using mix of IP-, name-, and port-based configuration
    #
    #server {
    #    listen       8000;
    #    listen       somename:8080;
    #    server_name  somename  alias  another.alias;

    #    location / {
    #        root   html;
    #        index  index.html index.htm;
    #    }
    #}


    # HTTPS server
    #
    #server {
    #    listen       443 ssl;
    #    server_name  localhost;

    #    ssl_certificate      cert.pem;
    #    ssl_certificate_key  cert.key;

    #    ssl_session_cache    shared:SSL:1m;
    #    ssl_session_timeout  5m;

    #    ssl_ciphers  HIGH:!aNULL:!MD5;
    #    ssl_prefer_server_ciphers  on;

    #    location / {
    #        root   html;
    #        index  index.html index.htm;
    #    }
    #}

}
</code></pre><p>在nginx.conf配置文件中添加如下代码，位置可以在gzip这一行后面，只要在location前面即可</p>
<pre><code>upstream 119.29.216.43 {
    server 119.29.216.43:8080 weight=1;
    server 119.29.177.116:8080 weight=1;
}
</code></pre><p>并将其中的<code>gzip  on</code>前面的注释，这个功能是将需要发送到浏览器的文件进行压缩，之后再修改server块中索要修改的内容修改成如下</p>
<pre><code>server {
    listen       80;
    server_name  119.29.216.43;

    #charset koi8-r;

    #access_log  logs/host.access.log  main;

    location / {
        root   html;
        index  index.html index.htm;
        proxy_pass  http://119.29.216.43;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        client_max_body_size 10m;
        proxy_connect_timeout 90;
        proxy_sen
    }
...
}
</code></pre><p>这算是最基本的修改了，后面还得涉及到nginx性能的优化配置，这里先不扯。继续看上面的原始配置文件，nginx的server块中表明了nginx使用的地址server_name和端口号listen，其端口号是80端口，为使服务器能够外网访问就需要开放80端口，所以我们需要开放端口，其命令为<br><code>sudo firewall-cmd --zone=public --add-port=80/tcp --permanent</code><br>之后运行下面的命令<br><code>sudo firewall-cmd --reload</code><br>两者都正常运行返回success即为开放成功，另外提下，列出所有已经开放的端口命令如下<br><code>sudo firewall-cmd --list-ports</code><br>目前，将nginx服务启动后，在我自己的笔记本上使用centos7服务器的ip及80端口通过浏览器即可访问到tomcat，但是负载均衡不能得到体现，所以我们可以修改三台tomcat安装目录下的<code>/webapps/ROOT/index.jsp</code>页面，来区分三台不同的tomcat，为了方便，我就修改了index.jsp页面的title，每个title的值就是相应tomcat所在的端口号，浏览器中输入<code>http://192.168.1.149:80</code>出现的页面就会使title=8080的tomcat欢迎页面，每次点击刷新，title都会更换，即tomcat都会更换，这就实现了nginx的负载均衡。<br>至此nginx安装与配置已经完成<br>查询nginx进程：<br><code>ps aux|grep nginx</code><br>查看服务的状态<br><code>service nginx status或systemctl nginx status</code></p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>存储帐号的文件：/etc/passwd<br>存储密码的文件：/etc/shadow<br>查看所有用户命令<br><code>cat /etc/passwd</code><br>便捷的输出：<br><code>grep bash /etc/passwd</code><br>查看所有用户对于的密码<br><code>cat /etc/shadow | grep 用户名</code><br>通过/etc/shadow获取的只是密码加密后的Hash散列值，要获取明文密码，需要自己进行破解<br>root下修改普通用户命令<br><code>passwd 用户名</code><br>root下修改自己密码命令<br><code>passwd</code><br>添加用户<code>adduser 用户名</code></p>
<p>查看系统信息<br><code>uname -a</code><br>和<br><code>cat /etc/redhat-release</code></p>
<p>[java环境搭建][<a href="https://cgspace.date/2017/03/08/java/2017-3-08-java-EnvironmentVariable/" target="_blank" rel="external">https://cgspace.date/2017/03/08/java/2017-3-08-java-EnvironmentVariable/</a>]</p>
]]></content>
      
        <categories>
            
            <category> linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> linux </tag>
            
            <tag> centos </tag>
            
            <tag> redis </tag>
            
            <tag> tomcat </tag>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[毕业后杂谈]]></title>
      <url>/2017/07/25/daily/2017-07-25-daily-biyezatan/</url>
      <content type="html"><![CDATA[<p>从毕业到现在，也过了那么一个多月了，从三月份出去实习到现在，也有四个多月了，还是混得不咋地，现在也是穷的一塌糊涂，瞎折腾吧。从武汉找到厦门，从厦门找到福州，从福州再找到厦门，并实习了两个月。毕业后再找到上海，未果，又回到厦门，工作两个月。到现在又在找工作….三月份来厦门之后，不久才知道了厦门确实不适合找程序员的工作，白兰鸽从一开始就飞错方向，自己傻逼似的把它往那边赶，落成现在这样也是作。</p>
<a id="more"></a>
<p>其实到哪个城市都一样，它们就像盒子，四四方方，有边有角，只是大小不同而已。<br>毕业又有点兴奋有点无奈,兴奋是那种磨刀霍霍向猪羊的感觉，无奈是这条路只有自己一个人走，其实他们也都一样，不过有点被思念，有点不被思念罢了<br>最近看到一个微博，说是三个男的，他们都彼此喜欢，组建成一个家庭，生活在一起。我特别羡慕这样的生活，跟自己喜欢玩得来的人生活在一起，我并不是同性恋，但我也特别希望能和自己的兄弟在一起生活，假如哪一天结婚了，各自和自己的另一半在一起。我也期待着能他们生活在一起，哪怕就在附近，每天生活都有交集。这就感觉是全世界就我们几个人，在一起生活，不需要过多外界的接触，我喜欢这种感觉。</p>
<p>总是想着下辈子要是一棵树就好了，一棵生长在原始森林的树，旁边的树从小就在身边，直到死去，不受任何干扰，一起看着日升日落，度过春夏秋冬。</p>
<p>但现实往往不是这样，接触过的人都会离去，不管是兄弟还是恋人，兄弟之间会随着时间变淡，恋人也会因为某种原因而离开，总有那么一个时候，彼此天各一方，各自会有各自的家庭，有自己的生活圈子，跟以前的人不会再有过多的嬉笑唏嘘。取而代之的是新认识的人，新交的兄弟。我反感这样，反感他们现在身边所谓的兄弟，凭什么我的兄弟现在成了别人的兄弟，这算是私心吧。</p>
<p>刚入大学那会这样的感慨最深。那会儿我们都在不同的城市，打工的打工，上学的上学，过着互不一样的生活。圈子不同联络就少了，大伙也只能在年末才能聚全。我也偶尔会请假去他们的城市看看，接触下他们的生活，看看过的怎么样，这样也能了解下他们的变化，避免后面感情联络不上。不过，时间这东西，我还是输。我不喜欢重新交朋友，心里想着有这么一些玩的好的朋友就已经够了，何必交太那些点头之交虚假的朋友…..想想那会儿还是太傻太天真，任何东西都禁不起时间的磨合，而你还是像个傻逼一样一直活在过去，这就扯到鸡汤了。不过偶尔活在过去也好，有回味，才叫生活。我一直记得一句话，一个忘记历史的名族，是一个没有希望的名族。如果换做一个人来说，总是会忘记自己以前的生活，那你就白活了，因为在你的脑海里你的生活是空白的，而你却在这个世界上存活了这么多年。这算是我喜欢恋旧的一个勉勉强强的理由吧，所以我有个习惯，就是生活一段时间就总结一段时间。找个空闲的时间，安静的角落，自己静下心来想想这段时间怎么生活的，总结一番，给自己加油打气。说实在，我时常在坐车的时候会想这个，坐公交，火车，滴滴…只要能静下来，脑袋里就像是放电影一样回想起过去，朋友面前嘻嘻哈哈，一静下来就会想到过去，高中那伙兄弟当时也都知道了我这脑回路….<br>这让我想到了前段时间看的一个，说是当你回想起以前的事情是，是不是会发现所有的事都是站在第三人称的角度来看的，可这明明都是自己经历的这些，那到底是谁在第三角度看的?仔细想想还真是那么一回事。</p>
<p>有一句话很经典，每个人都是想着自己的生活。</p>
<p>这几天一直在厦门找工作,大概有一个星期了。没工作的日子过得很颓废，除了找工作和自娱自乐还能干啥，还是得尽快找着工作，这样生活也能规律起来，还能养活自己。谈谈我现在的计划吧，在今年剩下的下半年里找个相对稳定点的工作，攒点钱并多积攒点经验，明年再去深圳找工作，以后工作就定深圳了。至于去深圳的原因有两点，其一，一线城市机会多，相对于我的专业来说，一线城市的需求量大，而且技术更新。其二就是离家近，爸妈都在家里，且爸妈只有我跟我哥两儿子，爸妈年级五旬左右，身体逐渐变弱，日后我俩兄弟当中肯定需要有个得经常回家照顾爸妈的。我哥还在念研究生，有考虑出国，所以这几年我得好好混，工作创业就在家附近吧，混不好再看。</p>
<p>我想，等我哪一天回头来看这篇文章的时候，肯定会觉得很幼稚，没错，21岁，我还是很幼稚。没有故事，只有酒。现在出了社会，跟别人比就是个小白，永远抵不过别人的城府，再怎么故作老成，也还是撑不起这局。</p>
<p>说到酒，我下班后常去出租屋楼下的胖阿姨那拿酒，每次拿两瓶都有中奖再来一瓶，通常是提酒到屋里后，再拿钱跟上次中奖的瓶盖儿一并给胖阿姨，常次反复，都是如此，到现在屋里还有三中奖的瓶盖儿。胖阿姨人也很好，这么高频率的中奖她也没说啥，也不会说啥，因为酒是她选的，我只是接手提上屋。之所以管她叫胖阿姨，这我也不知道，只是附近的人都这么叫她，我也就这样跟着叫了。这算是在厦门呆了这么久一来最幸运的事了</p>
]]></content>
      
        <categories>
            
            <category> daily </category>
            
        </categories>
        
        
        <tags>
            
            <tag> daily </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Spring中的jdbcTemplate和FreeMarker的初步接触]]></title>
      <url>/2017/07/11/javaee/2017-07-11-javaEE-spring-jdbcTemplate/</url>
      <content type="html"><![CDATA[<p>这么晚还没下班，没毛病吧，人生就是这么刺激….<br>说说今天接触到的东西<br>项目中定义了一个PurchaseOrderService这个接口，继承自BaseCRUDService这个底层的数据库操作接口,BaseCRUDService是封装在base-daoTemplate这个jar包中,估计这个base-daoTemplate.jar这个jar包是公司自己写的</p>
<a id="more"></a>
<p>里头封装了一些基本的crud操作这是操作数据库的一种方式</p>
<h3 id="BaseCRUDService-java"><a href="#BaseCRUDService-java" class="headerlink" title="BaseCRUDService.java"></a>BaseCRUDService.java</h3><p>BaseCRUDService.java代码如下</p>
<pre><code>public interface BaseCRUDService&lt;T&gt; {
    T createEntity();

    Long count(Map&lt;String, Object&gt; var1);

    Long count(List&lt;Cond&gt; var1);

    Long count(Conds var1);

    T getById(Serializable var1);

    T get(Map&lt;String, Object&gt; var1);

    T get(Conds var1);

    List&lt;T&gt; list(Map&lt;String, Object&gt; var1);

    List&lt;T&gt; list(List&lt;Cond&gt; var1);

    List&lt;T&gt; list(Conds var1);

    void deleteById(Serializable var1);

    void delete(Conds var1);

    T insert(T var1);

    T update(T var1);

    T update(Update var1);
}
</code></pre><p>第二中方式使用spring框架的jdbcTemplate这个jar包来操作</p>
<pre><code>String sql = FreeMarkerHelper.getValueFromTpl(&quot;sql/purchaseOrder/PurchaseOrderListList.sql&quot;, data);
List&lt;PurchaseOrderListVo&gt; orderListVoList = jdbcTemplate.query(sql, ParameterizedBeanPropertyRowMapper.newInstance(PurchaseOrderListVo.class));
</code></pre><p>这感觉有点搞头<br>例如一个方法代码如下</p>
<pre><code>private ListMultimap&lt;String, PurchaseOrderListVo&gt; getOrderListList(List&lt;String&gt; orderIdList) {
    Map&lt;String, Object&gt; data = Maps.newHashMap();
    String orderIds = StringUtils.join(orderIdList, &quot;,&quot;);
    if (StringUtils.isBlank(orderIds)){
        orderIds = &quot;-1&quot;;
    }
    data.put(&quot;orderIds&quot;,  orderIds);
    String sql = FreeMarkerHelper.getValueFromTpl(&quot;sql/purchaseOrder/PurchaseOrderListList.sql&quot;, data);
    List&lt;PurchaseOrderListVo&gt; orderListVoList = jdbcTemplate.query(sql, ParameterizedBeanPropertyRowMapper.newInstance(PurchaseOrderListVo.class));
    ListMultimap&lt;String, PurchaseOrderListVo&gt; listMultimap = ArrayListMultimap.create();
    // 售后信息
    Map&lt;String, Map&lt;String, List&lt;OrderItemAsFlowVo&gt;&gt;&gt; flowMap = orderItemAsFlowQueryService.getListFlowList(orderIdList);
    for (PurchaseOrderListVo listVo : orderListVoList) {
        if (flowMap.get(listVo.getOrderId()) != null) {
            listVo.setFlowList(flowMap.get(listVo.getOrderId()).get(listVo.getPurGoodsSkuId()));
        }
        listMultimap.put(listVo.getOrderId(), listVo);
    }
    return listMultimap;
}
</code></pre><p>感觉这个方法涉及到的工具代码真是牛逼,来解析下这个方法<br>只节解析对我有用的，其他的功能我不管<br>首先代码第一行<br><code>Map&lt;String, Object&gt; data = Maps.newHashMap()</code><br>声明并实例化了一个Map类型的data对象<br>之后<br><code>data.put(&quot;orderIds&quot;,  orderIds);</code><br>这一行代码将数据存入到data对象中<br><code>key=orderIds,value=orderIds</code><br>然后使用FreeMarkerHelper这个类中的getValueFormTpl()这个方法来解析一个sql文件，并实现将搜索需要的参数参合到其中,其代码的实现就是将data对象作为参数传入，并且将sql文件中的参数变量使用data中的key匹配并用value替换</p>
<h3 id="sql文件"><a href="#sql文件" class="headerlink" title="sql文件"></a>sql文件</h3><p>PurchaseOrderListList.sql文件的代码如下</p>
<pre><code>SELECT
    group_concat(id) as id,
    order_id,
    pur_goods_sku_id,
    pur_goods_id,
    status,
    sum(number) as number,
    sum(final_amount) as final_amount,
    pur_goods_name,
    pur_goods_img_url,
    pur_goods_amount as pur_goods_amount,
    pur_goods_type,
    ROUND(supply_price / number, 2) as supply_price,
    create_time,
    is_sample,
    sum(sum_amount) as sum_amount,
    cargo_sku_id,
    sum(original_amount) as original_amount,
    sum(discount_amount) as discount_amount,
    return_time,
    last_updated,
    gift_flag,
    sum(return_amount) as return_amount
FROM
    purchase_order_list
WHERE
    order_id in (${orderIds})
    and is_valid = &apos;T&apos;
    and del_flag = &apos;F&apos;
group by pur_goods_sku_id,order_id
</code></pre><p>观察PurchaseOrderListList.sql中的代码，其中有个<br><code>${orderIds}</code><br>这个就是用来和data对象中的key相匹配，并将data对象中key值orderIds的value传入到PurchaseOrderListList.sql文件中，FreeMarkerHelper再读取PurchaseOrderListList.sql中的内容，之后返回一个String类型的操作数据库的字符串语句<br>之后，调用jdbaTemplate中的query()方法来操作数据库，并返回一个list集合</p>
<h3 id="FreeMarkerHelper-java"><a href="#FreeMarkerHelper-java" class="headerlink" title="FreeMarkerHelper.java"></a>FreeMarkerHelper.java</h3><p>其FreeMarkerHelper代码如下</p>
<pre><code>public class FreeMarkerHelper {

    private static final Configuration config;

    static{
        config = new Configuration(Configuration.VERSION_2_3_22);
        config.setDefaultEncoding(&quot;UTF-8&quot;);
        config.setOutputEncoding(&quot;UTF-8&quot;);

        try {
//            System.out.println(&quot;===========&quot; + new ClassPathResource(&quot;./classes&quot;).getFile().getAbsolutePath() + &quot;===========&quot;);
//            System.out.println(&quot;===========&quot; + new ClassPathResource(&quot;./sql&quot;).getFile().getAbsolutePath() + &quot;===========&quot;);
//            System.out.println(&quot;===========&quot; + new ClassPathResource(&quot;sql&quot;).getFile().getAbsolutePath() + &quot;===========&quot;);
//            System.out.println(&quot;===========&quot; + new ClassPathResource(&quot;&quot;).getFile().getAbsolutePath() + &quot;===========&quot;);
//            System.out.println(&quot;===========&quot; + new ClassPathResource(&quot;/&quot;).getFile().getAbsolutePath() + &quot;===========&quot;);
//            System.out.println(&quot;===========&quot; + new ClassPathResource(&quot;.&quot;).getFile().getAbsolutePath() + &quot;===========&quot;);
            config.setDirectoryForTemplateLoading(new File(CfgConstants.getProperties().get(&quot;tplPath&quot;)));
        } catch (IOException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
    }

    public static String getValueFromTpl(String tplName, Object dataModel) {
        String value = null;
        Template template = null;
        try {
            template = config.getTemplate(tplName);
            value = FreeMarkerTemplateUtils.processTemplateIntoString(template, dataModel);
        } catch (Exception e) {
            e.printStackTrace();
        }

        return value;
    }

}
</code></pre><p>这个FreeMarkerHelper类真是厉害，这类中的代码我根本看不懂,只知道是调用了FreeMarker模板引擎<br>只是我没接触过FreeMarker，问了前辈，前辈说也不知道，表示这个项目中使用FreeMarker只是用来组装sql语句的,并让我不要去研究底层的东西，学会怎么用就行…..</p>
<p>ps:得找个机会总结下最近学到的东西了，不然就忘了</p>
]]></content>
      
        <categories>
            
            <category> javaEE </category>
            
        </categories>
        
        
        <tags>
            
            <tag> codeing </tag>
            
            <tag> javaEE </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Spring MVC注解控制器同步跳转和ajax的异步请求的协作]]></title>
      <url>/2017/07/04/javaee/2017-07-04-javaEE-SpringMVC-jquery-arttemplate/</url>
      <content type="html"><![CDATA[<p>就着现在接触的项目优茶联项目中，谈谈在系统的个人中心里的我的收藏中，对收藏的商品进行取消收藏的流程</p>
<h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><p>其大致流程如下</p>
<ol>
<li>首先，浏览器访问list.jsp这个页面，对应list.jsp这个页面的控制器直接返回一个页面路径(也就是直接返回一个页面)</li>
</ol>
<a id="more"></a>
<ol>
<li><p>在list.jsp页面中点击取消收藏这个按钮，处理这个点击事件的js方法是favorite_list.js中的cancelFavorite()方法，方法获取商品id后进行jquery ajax的异步请求数据加载，其中发送请求的data数据中就包含商品id，并设置了请求方式和路径</p>
</li>
<li><p>发送请求后，服务器根据再次根据异步请求的路径找到与路径相对应的控制器方法，把异步请求需要的数据处理交给这个控制器方法，等待控制器方法返回数据</p>
</li>
<li><p>将放回的结果数据当做参数传入JQuery AJAX的异步请求方法中的success函数，根据结果情况做出相对应的响应</p>
</li>
</ol>
<h4 id="关于success函数"><a href="#关于success函数" class="headerlink" title="关于success函数"></a>关于success函数</h4><p>jquery ajax的异步请求方法中，定义了一个success函数机制，如下面的实现代码<br><code>success:function(result){}</code><br>这样的<br>我也不知道这个success功能该怎么叫，它的工作原理我也不大清楚，说是success函数机制，这也只是我按自己的理解命名的,控制器方法在执行完数据的处理后，return操作后的结果，这就当是服务器的返回，原先缓存在浏览器中的favorite_list.js中的jquery ajax还在运行等待服务器的返回，当其检测到服务器发送回来的数据后，将数据当做参数传到success函数机制中<br>就如下面代码<br><code>success:function(返回数据){}</code><br>后面success函数机制在根据返回的数据进行操作判断之前请求的数据是否处理成功,并做出对应的相应,这是我现在的猜测<br>另外,根据根据控制器方法的不同返回结果，可分为不同的跳转方式</p>
<h4 id="同步跳转"><a href="#同步跳转" class="headerlink" title="同步跳转"></a>同步跳转</h4><p>控制器方法内部有数据的处理及最后返回一个页面地址，这样的属于同步跳转<br>控制器方法内部要是没有数据的处理，最后确返回一个页面地址，这样也数据同步跳转</p>
<h4 id="异步跳转"><a href="#异步跳转" class="headerlink" title="异步跳转"></a>异步跳转</h4><p>控制器方法内部只有数据的处理，最后也只返回数据，这样的数据异步跳转,还有就是，每个ajax的请求都对应一个控制器，每次请求都会对应实例化一个新的Request对象，后面事件触发的ajax数据请求与初次访问页面请求的Request对象是不同的<br>下面贴出相关文件的代码</p>
<h4 id="list-jsp"><a href="#list-jsp" class="headerlink" title="list.jsp"></a>list.jsp</h4><p>list.jsp页面的代码</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;我的收藏&lt;/title&gt;
  &lt;jsp:include page=&quot;/WEB-INF/jsp/www/common/common_css.jsp&quot;&gt;&lt;/jsp:include&gt;
  &lt;jsp:include page=&quot;/WEB-INF/jsp/www/common/common_js.jsp&quot;&gt;&lt;/jsp:include&gt;
  &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/static/css/person.css&quot;&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;/static/css/person_center_nav_position.css&quot;&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;/static/js/lib/kkpager/css/kkpager.css&quot;&gt;
  &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/static/css/collect.css&quot;&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;%--头部 starting--%&gt;
&lt;jsp:include page=&quot;/WEB-INF/jsp/www/include/header.jsp&quot;&gt;&lt;/jsp:include&gt;
&lt;%--头部 ending--%&gt;

&lt;%--查询 starting--%&gt;
&lt;jsp:include page=&quot;/WEB-INF/jsp/www/include/personal_header.jsp&quot;&gt;&lt;/jsp:include&gt;
&lt;%--查询 ending--%&gt;

&lt;%--左侧工具栏 starting--%&gt;
&lt;jsp:include page=&quot;/WEB-INF/jsp/www/include/nav_left_bar.jsp&quot;&gt;&lt;/jsp:include&gt;
&lt;%--左侧工具栏 ending--%&gt;

&lt;!-- 主内容 --&gt;
&lt;div class=&quot;person-wrap&quot;&gt;
  &lt;div class=&quot;person-cont&quot;&gt;
    &lt;div class=&quot;content&quot;&gt;
      &lt;%--右侧导航栏 starting--%&gt;
      &lt;jsp:include page=&quot;/WEB-INF/jsp/www/include/personal_menu.jsp&quot;&gt;&lt;/jsp:include&gt;
      &lt;%--右侧导航栏 ending--%&gt;

      &lt;!-- 个人中心主内容 --&gt;
      &lt;div class=&quot;right-cont-wrap&quot;&gt;
        &lt;div&gt;
          &lt;ul id=&quot;top-nav&quot; class=&quot;nav-menu clearfix&quot;&gt;
            &lt;li class=&quot;active&quot;&gt;&lt;a&gt;收藏的商品&lt;/a&gt;&lt;/li&gt;
            &lt;%--&lt;li&gt;&lt;a&gt;收藏的店铺&lt;/a&gt;&lt;/li&gt;--%&gt;
          &lt;/ul&gt;
          &lt;div class=&quot;top-right-box clearfix&quot;&gt;
            &lt;!-- 添加check出现批量操作面板 --&gt;
            &lt;div id=&quot;title-batch-box&quot; class=&quot;option-wrap pull-left&quot;&gt;
              &lt;div class=&quot;nomal-box&quot;&gt;
                &lt;a id=&quot;batch-btn&quot; class=&quot;batch-btn&quot;&gt;批量处理&lt;/a&gt;
              &lt;/div&gt;
              &lt;div class=&quot;check-box&quot;&gt;
                &lt;div class=&quot;pull-left&quot;&gt;
                  &lt;%--&lt;span class=&quot;check-icon check-tagt&quot;&gt;&lt;/span&gt;--%&gt;
                  &lt;lalel&gt;
                    &lt;input type=&quot;checkbox&quot; class=&quot;check-all&quot;&gt;
                    全选
                  &lt;/lalel&gt;
                &lt;/div&gt;
                &lt;%--&lt;a class=&quot;option-btn cart&quot;&gt;加入购物车&lt;/a&gt;--%&gt;
                &lt;a class=&quot;option-btn collect&quot; onclick=&quot;Collect.cancelFavorite()&quot;&gt;取消收藏&lt;/a&gt;
                &lt;a id=&quot;complete-btn&quot; class=&quot;batch-btn&quot;&gt;完成&lt;/a&gt;
              &lt;/div&gt;
            &lt;/div&gt;
            &lt;div class=&quot;page-box pull-right&quot;&gt;
              &lt;span class=&quot;pull-left&quot;&gt;&lt;span id=&quot;current-page&quot; class=&quot;orange&quot;&gt;1&lt;/span&gt;/&lt;span id=&quot;total-page&quot;&gt;1&lt;/span&gt;&lt;/span&gt;
              &lt;a id=&quot;page-pre&quot; href=&quot;javascript:void(0);&quot; class=&quot;page-btn pre disable&quot; data-page-no=&quot;0&quot;&gt;&lt;/a&gt;
              &lt;a id=&quot;page-next&quot; href=&quot;javascript:void(0);&quot; class=&quot;page-btn next disable&quot; data-page-no=&quot;&quot;&gt;&lt;/a&gt;
            &lt;/div&gt;
          &lt;/div&gt;
        &lt;/div&gt;
        &lt;!-- 添加check出现操作样式 --&gt;
        &lt;div id=&quot;collect-list-box&quot; class=&quot;collect-list-wrap clearfix&quot;&gt;

        &lt;/div&gt;
        &lt;div id=&quot;kkpager&quot;&gt;&lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
      &lt;!-- END个人中心主内容 --&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;!-- END主内容 --&gt;
&lt;%--尾部 starting--%&gt;
&lt;jsp:include page=&quot;/WEB-INF/jsp/www/include/footer.jsp&quot;&gt;&lt;/jsp:include&gt;
&lt;%--尾部 ending--%&gt;
&lt;/body&gt;
&lt;/html&gt;
&lt;script src=&quot;/static/js/user/person.common.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;/static/js/lib/kkpager/kkpager.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;/static/js/favorite/favorite_list.js&quot;&gt;&lt;/script&gt;

&lt;script id=&quot;tpl-list-item&quot; type=&quot;text/html&quot;&gt;

  &lt;div class=&quot;list-item&quot; data-id=&quot;{{id}}&quot;&gt;
    &lt;div class=&quot;item-inner&quot;&gt;
      &lt;a class=&quot;img-cover&quot; href=&quot;/purchaseGoods/detail?goodsId={{good.id}}&quot;&gt;
        &lt;img width=&quot;160&quot; height=&quot;160&quot; src=&quot;{{good.image.url}}&quot;&gt;
      &lt;/a&gt;
      &lt;a class=&quot;p-name&quot; href=&quot;/purchaseGoods/detail?goodsId={{good.id}}&quot;&gt;{{good.name}}&lt;/a&gt;
      &lt;div class=&quot;p-price red&quot;&gt;¥&lt;strong&gt;{{good.price}}&lt;/strong&gt;&lt;/div&gt;
      &lt;div class=&quot;p-operate clearfix&quot;&gt;
        &lt;div class=&quot;op-btn&quot;&gt;
          &lt;a class=&quot;btn-compare&quot; data-id=&quot;{{id}}&quot; onclick=&quot;Collect.addToCartFromFavorite(this)&quot;&gt;加入购物车&lt;/a&gt;
        &lt;/div&gt;
        &lt;div class=&quot;op-btn&quot;&gt;
          &lt;a class=&quot;btn-cut&quot; data-id=&quot;{{id}}&quot; onclick=&quot;Collect.cancelFavorite(this)&quot;&gt;取消收藏&lt;/a&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;item-check&quot;&gt;
      &lt;i class=&quot;i-check&quot;&gt;&lt;/i&gt;
    &lt;/div&gt;
  &lt;/div&gt;

&lt;/script&gt;
</code></pre><p>这个页面中对应的控制器方法使用了同步加载的方法，其返回值是一个list.jsp页面路径,在这个页面中，关键数据使用了arttemplate模板，如<script id="tpl-list-item" type="text/html"></script>标签块中的代码实现，配合ajax实现list.jsp页面数据的异步加载并渲染</p>
<h4 id="FavoriteController-java"><a href="#FavoriteController-java" class="headerlink" title="FavoriteController.java"></a>FavoriteController.java</h4><p>其控制器类FavoriteController的部分代码如下</p>
<pre><code>@Controller
@RequestMapping(&quot;/favorite&quot;)
public class FavoriteController {

    @Autowired
    private FavoriteB2bService favoriteB2bService;

    @RequestMapping(&quot;/list&quot;)
    public String list() {
        return &quot;www/favorite/list&quot;;
    }

    @RequestMapping(&quot;/cancleFavorite&quot;)
    @ResponseBody
    public ResultData cancleFavorite(HttpServletRequest request, String modelJsonStr) {
        if (StringUtils.isBlank(modelJsonStr)) {
            return ResultData.createFail(&quot;商品信息不存在&quot;);
        }
        List&lt;String&gt; ids = Lists.newArrayList();
        ids = JsonUtils.toObject(modelJsonStr, ListUtils.getCollectionType(List.class, String.class));
        String userId = AccountUtils.getCurrShopId(); //TODO 获取当前登录用户id
        favoriteB2bService.cancleFavorite(ids, userId, OrderBizType.purchase);
        return ResultData.createSuccess();
    }

    @RequestMapping(&quot;/getFavoriteList&quot;)
    @ResponseBody
    public ResultData getFavoriteList(HttpServletRequest request, String modelJsonStr) {
        if (StringUtils.isBlank(modelJsonStr)) {
            return ResultData.createFail(&quot;商品信息不存在&quot;);
        }
        FavoriteQuery favoriteQuery = JsonUtils.toObject(modelJsonStr, FavoriteQuery.class) != null ?
                JsonUtils.toObject(modelJsonStr, FavoriteQuery.class) : new FavoriteQuery();
        String userId = AccountUtils.getCurrShopId();
        String storeLevelId = AccountUtils.getCurrStoreLevelId();
        favoriteQuery.setStoreLevelId(storeLevelId);
        favoriteQuery.setUserId(userId);
        favoriteQuery.setOrderBizType(OrderBizType.purchase);
        return favoriteB2bService.getFavoriteList(favoriteQuery);
    }

    ....

}
</code></pre><p>观察上面的代码可以知道这是个基于注解实现的控制器，使用@Controller来声明一个控制器类，<br>@RequestMapping来声明一个控制器方法，RequestMapping方法除了有value属性外，还有method属性</p>
<h4 id="favorite-list-js"><a href="#favorite-list-js" class="headerlink" title="favorite_list.js"></a>favorite_list.js</h4><p>favorite_list.js中的部分代码</p>
<pre><code>$(function(){
    if (!$.checkLogin()) { //验证登录
        return;
    }
    Collect.init();
});

var Collect = {
    init : function() {
        Collect.showBatchBox();
        Collect.hideBatchBox();
        Collect.prePage();
        Collect.nextPage();
        Collect.initCheck();
        Collect.getFavoriteList(1);
        Collect.initFavoritePage();
    },

    cancelFavorite: function(target) {
        var queryData = [];
        if (!target) {
            $(&quot;.collect-list-wrap&quot;).find(&quot;.list-item.active&quot;).each(function(i, perFavorite) {
                queryData.push($(perFavorite).attr(&quot;data-id&quot;));
            });
        } else {
            queryData.push($(target).attr(&quot;data-id&quot;));
        }
        if (queryData.length &lt;= 0) {
            return;
        }
        $.ajax({
            type: &quot;POST&quot;,
            data: {modelJsonStr : JSON.stringify(queryData)},
            url: &quot;/favorite/cancleFavorite&quot;,
            success: function(result) {
                if (result.success) {
                    layer.msg(&quot;取消成功！&quot;, function() {
                        Collect.initFavoritePage();
                        Collect.getFavoriteList(1);
                    });
                } else {
                    layer.msg(result.msg);
                }
            }
        });

    },

    getFavoriteList: function(pageNo) {
        var ii = layer.load();
        var queryData = {
            pageNum: pageNo
        };
        $.ajax({
            type: &quot;POST&quot;,
            data: {modelJsonStr : JSON.stringify(queryData)},
            url: &quot;/favorite/getFavoriteList&quot;,
            success: function(result) {
                //此处用setTimeout演示ajax的回调
                layer.close(ii);
                if (result.success) {
                    $(&quot;#collect-list-box&quot;).empty();
                    $.each(result.data, function(i, perGoods) {
                        var tpl_list_item = template(&quot;tpl-list-item&quot;, perGoods);
                        $(&quot;#collect-list-box&quot;).append($(tpl_list_item));
                    });
                } else {
                    layer.msg(result.msg);
                }

            }
        });
    },

}
</code></pre><p>结合上面的favorite_list.js中的代码，来进一步了解异步加载数据的实现<br>list.jsp页面中引用了favorite_list.js这个文件，在第一次访问list.jsp页面并完成文档加载后会自动调用favorite_list.js中的文档就绪函数$(function(){}),以此来初始化Collect对象，并且调用favorite_list.js中的getFavoriteList()方法，实话说，这个方法就是主要用来实现异步加载list.jsp页面所需要的数据的主要实现部分<br>getFavoriteList()方法中定义了jquery ajax的异步数据请求，设置了url,使得具体的数据获取操作交给控制器类FavoriteController中相对应的控制器方法,且使用了success函数机制等待控制器方法返回的结果<br>并在方法内将结果处理遍历出来，遍历的方法里面使用了arttemplate中的template()方法，将数据对象都渲染到jsp页面<br>遍历出来的数据div块都在类名为collect-list-box的div块里，所以猜测arttemplate模板只能放到页面最后</p>
]]></content>
      
        <categories>
            
            <category> javaEE </category>
            
        </categories>
        
        
        <tags>
            
            <tag> codeing </tag>
            
            <tag> javaEE </tag>
            
            <tag> JQuery </tag>
            
            <tag> AJAX </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JavaEE-Hibernate标签中的懒加载与Session事物]]></title>
      <url>/2017/06/29/javaee/2017-06-29-javaEE-Hibernate-lanjiazai/</url>
      <content type="html"><![CDATA[<p>最近开发的项目，谈开发算不上，只是在前辈们写的代码基础上添写代码，对系统增加功能。在阅读以前的代码过程中，遇到了懒加载，自己对懒加载的根本不了解，就向公司里的老司机请教。</p>
<p>这里就作为总结，谈自己现在对懒加载的认识</p>
<p>ps:用Hibernate还不如用Mybatis..</p>
<a id="more"></a>
<h4 id="懒加载的认识"><a href="#懒加载的认识" class="headerlink" title="懒加载的认识"></a>懒加载的认识</h4><p>例如下面的实体类</p>
<pre><code>@Entity
@Table(name = &quot;cruise_ship_project_classify&quot;)
public class CruiseShipProjectClassify extends com.framework.hibernate.util.Entity {

    @ManyToOne
    @JoinColumn(name = &quot;parentId&quot;)
    private CruiseShipProjectClassify cruiseShipProjectClassify;

    @OneToMany(mappedBy = &quot;cruiseShipProjectClassify&quot;, fetch = FetchType.LAZY)
    private Set&lt;CruiseShipProject&gt; cruiseShipProject;
}
</code></pre><p>看上面的代码可以得出：<br>    实体类CruiseShipProjectClassify和实体类CruiseShipProject是一对多的关系<br>    并对CruiseShipProject设置了懒加载(fetch = FetchType.LAZY)</p>
<p>拿上面的代码来解释其懒加载的定义:<br>    使用了懒加载时，系统控制器在获取CruiseShipProjectClassify对象数据后，在调试模式下会自动获取CruiseShipProject对象的数据，但在正常运行下时，只有当需要用到CruiseShipProject对象数据的时候，才会调用工具去数据库中自动获取CruiseShipProject对象数据。如果没定义使用懒加载，那么系统在每次运行时都会自动去数据库中获取CruiseShipProject对象的数据，无论当前控制器及页面是否用到CruiseShipProject对象数据。如果此时控制器及页面不需要用到这个对象的数据，这个对象又未定义懒加载，那么系统就消耗了本不该消耗的内存去加载搜索其数据，造成了内存的浪费，运行耗时且速度缓慢。<br>    使用了懒加载和未使用懒加载相对比起来，其作用效果就很明显了</p>
<p>然而，需要注意的是，jsp最好不要直接使用其定义了懒加载的对象数据<br>拿上面的代码来说，也就是当jsp页面需要CruiseShipProject对象的数据时候，最好不要调用cruiseShipProject这个对象，就是CruiseShipProject定义懒加载而声明的对象</p>
<p>其原因很简单，就是数据可能会取不到</p>
<h4 id="Session认识"><a href="#Session认识" class="headerlink" title="Session认识"></a>Session认识</h4><p>这就需要对Hibernate的Session进行了解了</p>
<p>需要知道</p>
<p>如果系统底层的crud操作是直接调用Spring中打包的HibernateTemplate来实现，那么Session事物的开启和关闭都将自动完成，而且我也不知道具体在什么时候完成开启和关闭的操作。只知道在需要对数据库进行操作和访问的时候，就会激活Session事物，所有的对数据库操作和访问的语句都将整合到一个Session事物中，这更能确定数据库信息的安全操作。这个Session事物中只要有一条sql语句执行出错，那么整个Session事物操作将会终止，数据库中的信息将会进行回滚，Session事物的连接也将会关闭，这确保了数据的正确性和安全保护</p>
<p>再回到懒加载，</p>
<p>在控制器中，定义了方法获取CruiseShipProjectClassify对象的数据，使用了懒加载的CruiseShipProject将会在遇到了需要对CruiseShipProject对象数据进行使用的时候，才会进行二次获取CruiseShipProject数据，如果没有遇到，那将永远不会其获取CruiseShipProject对象数据</p>
<p>而在进行二次获取时，此时因控制器方法而产生的Session事物已经关闭，那么获取到的CruiseShipProject对象值将会是Null</p>
<p>那么什么时候才是需要对CruiseShipProject对象数据进行使用的时候？</p>
<p>例如，一个jsp页面在需要数据的时候，就会调用该页面所对应的控制器去操作，控制器不知道页面具体需要什么数据，只会根据代码去调用相应的service…控制器方法中执行获取CruiseShipProjectClassify对象的数据并返回，其中本该一次性获取的cruiseShipProject，却因为使用了懒加载，使得控制器并不会去查询cruiseShipProject对象的数据，cruiseShipProject对象的数据就为Null.并返回</p>
<p>当jsp页面定义了${cruiseShipProject.xxx}字段时，就是为例等待控制器返回的数据并填充，当控制器发现这个${cruiseShipProject.xxx}字段的时候，就意味着需要使用cruiseShipProject对象数据，那么就会进行对cruisShipProject数据的二次获取</p>
<p>而此时，原先控制器激活的Session事物连接已经关闭，访问不到数据库，所以，最终还是获取不到定义了懒加载的CruiseShipProject实体类的对象cruiseShipProject对象数据</p>
<p>其实，同事所说的，这有个不确定因素，有的时候获取得到，有的时候获取不到</p>
<p>总之，jsp页面最好不要这样调用已经使用了懒加载的实体类对象</p>
<p>需要该实体类对象数据的时候，就直接在控制器中自己添加一条代码，以此来获取该实体类对象数据</p>
<p>另外，在debug调试模式下，是可以获取使用了懒加载对象的数据，不然怎么debug…..</p>
]]></content>
      
        <categories>
            
            <category> javaEE </category>
            
        </categories>
        
        
        <tags>
            
            <tag> codeing </tag>
            
            <tag> javaEE </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Note]]></title>
      <url>/2017/06/21/note/2017-06-21-createNote/</url>
      <content type="html"><![CDATA[<p>这里将记录日常工作中的一些简单笔记.个人有个习惯,喜欢将开发中遇到的一些需要记住的东西,问题及相对应的解决方法记录下来.</p>
<p>说是喜欢,其实就是记忆力不好,想记下来,就用写笔记这种方式,久而久之就成了习惯</p>
<a id="more"></a>
<hr>
<h4 id="2017-06-20"><a href="#2017-06-20" class="headerlink" title="2017-06-20"></a>2017-06-20</h4><ol>
<li><p>控制器类调用与jsp页面相对应的控制器(方法),控制器再调用相应的server类进行操作<br>最后控制器(方法)将jsp页面所需要的数据进行返回,并将jsp页面进行渲染成html页面,</p>
</li>
<li><p>Hibernate使用标签,那么将不需要.cfg.xml配置文件,<br>其中数据库表的字段和实体类之间的关联则依靠标签,<br>在每一个实体类中,<br>类的开头将使用’@Table’标签指明表<br>例如:<br> @Table(name = “category_type”)<br> public class CategoryType extends com.framework.hibernate.util.Entity implements java.io.Serializable {<br> }</p>
</li>
<li><p>代码使用svn更新遇到问题<br> Error:svn: E210002: Network connection closed unexpectedly<br> svn: E210002: Additional errors:<br>这个还没找到解决方法</p>
</li>
<li><p>使用jsp页面的好处<br>将实体类对象设置成全局变量,这样的话该对象就可以直接存放到Request,Response中,<br>只要控制器中实力类的对象是全局变量,那么就可以被自动放进Request中,返回给请求者,如果对象中含有数据,<br>那么浏览器将配合jsp页面中的标签将其整合渲染成html页面</p>
</li>
<li><p>在一对多的关系中,对象值会一次性获取到<br>例如:实体类A对实体类B是一对多的关系,在Hibernate中需要将实体类B的对象当作变量放入实体类A中<br>那么在控制器中获取实体类A的对象值后,同样会自动获取实体类B对象的值</p>
</li>
<li><p>一海游项目中,如下路径下的jsp页面:<br> /home/cg/Work/JavaEEWork/Intellij-IDEA/sgyy-svn/soutuu_website/data/projects/lvxbang/yhypcweb/src/main/<br> webapp/WEB-INF/jsp/yhypc/cruiseShip/cabinDetails.jsp<br>对应的实体类为:<br> /home/cg/Work/JavaEEWork/Intellij-IDEA/sgyy-svn/soutuu_website/data/business/cruiseship/cruiseshipservice/src/main/<br> java/com/data/data/hmly/service/cruiseship/entity/CruiseShipProject.java<br>其控制器类为:</p>
<p> /home/cg/Work/JavaEEWork/Intellij-IDEA/sgyy-svn/soutuu_website/data/projects/lvxbang/yhypcweb/src/main/<br> java/com/data/data/hmly/action/yhypc/CruiseShipWebAction.java</p>
</li>
</ol>
<hr>
<h4 id="2017-06-21"><a href="#2017-06-21" class="headerlink" title="2017-06-21"></a>2017-06-21</h4><p>电脑太卡了,打算重装系统,无线网卡也不稳定<br>…..</p>
<ol>
<li><p>下载linuxmint系统镜像文件</p>
</li>
<li><p>拷贝linuxmint系统上的工作文件,将其有用的进行打包<br>例如:各类编程源代码,项目源代码,系统主题,chrome-extension,bolg</p>
</li>
<li><p>安装搜狗输入法,或者sunpinyin,谷歌拼音.前提需要安装fcitx</p>
</li>
<li><p>更新源列表<br>linux其他系统可以使用命令:sudo gedit /etc/apt/sources.list<br>但linuxmint系统不再使用这个,有工具提供<br>以前用的软件源<br>rosa:<br><code>http://mirrors.ustc.edu.cn/linuxmint</code><br>trusty:<br><code>http://mirrors.hust.edu.cn/ubuntu</code></p>
</li>
<li><p>安装jdk,node.js<br>并配置环境变量,其命令<br><code>sudo gedit /etc/profile</code><br>现在环境配置<br> #Java-environment<br> export JAVA_HOME=/usr/lib/jvm/jdk1.8.0_77<br> export PATH=$JAVA_HOME/bin:$PATH<br> export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar<br> #set for nodejs-environment<br> #export NODE_HOME=/usr/local/src/node-v7.3.0<br> #export PATH=$NODE_HOME/bin:$PATH<br> #set for hexo-environment<br> export HEXO_HOME=/opt/node-v6.9.2-linux-x64/lib/node_modules/hexo-cli<br> export PATH=$HEXO_HOME/bin:$PATH<br> #Maven-environment<br> export MAVEN_HOME=/home/cg/Work/JavaEEWork/Server/apache-maven-3.5.0<br> export PATH=$MAVEN_HOME/bin:$PATH</p>
</li>
<li><p>安装<br>eclipse<br>intellij idea<br>brackets<br>sublime-text<br>tomcat<br>mysql<br>git<br>svn<br>hexo<br>python3</p>
</li>
<li><p>可以安装新得力软件管理器</p>
</li>
</ol>
<hr>
<h4 id="2017-06-27"><a href="#2017-06-27" class="headerlink" title="2017-06-27"></a>2017-06-27</h4><p>找着一款云笔记应用–Simplenote。</p>
<p>界面风格简洁</p>
<p>并且有Linux版</p>
<p>打算以后用它做笔记</p>
]]></content>
      
        <categories>
            
            <category> note </category>
            
        </categories>
        
        
        <tags>
            
            <tag> daily </tag>
            
            <tag> codeing </tag>
            
            <tag> note </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux上远程连接mysql数据库服务器]]></title>
      <url>/2017/06/20/mysql/2017-06-20-mysql-linuxConnect/</url>
      <content type="html"><![CDATA[<p>昨天有需要从远程mysql数据库服务器中读取数据库信息,自己多于在Linux系统上做开发,而且都是使用xampp软件集成包来完成数据库等服务,并没有涉及到连接远程数据库服务器的需求,所以,就在linux系统上装了个mysql使用</p>
<p>这里记录的只是当时的过程</p>
<a id="more"></a>
<p>过程分类:</p>
<ul>
<li>安装mysql</li>
<li>远程连接mysql服务器</li>
<li>查询操作</li>
</ul>
<h3 id="安装mysql"><a href="#安装mysql" class="headerlink" title="安装mysql"></a>安装mysql</h3><p>终端运行命令</p>
<p><code>sudo apt-get install mysql-server</code></p>
<p>之后选择输入y</p>
<p>再在终端显示的面板中输入root用户的密码</p>
<h4 id="安装过程如下"><a href="#安装过程如下" class="headerlink" title="安装过程如下:"></a>安装过程如下:</h4><pre><code>cg@cg-ThinkPad-Edge-E540 ~ $ sudo apt-get install mysql-server
正在读取软件包列表... 完成
正在分析软件包的依赖关系树       
正在读取状态信息... 完成
将会安装下列额外的软件包：
  libdbd-mysql-perl libdbi-perl libmysqlclient18 libterm-readkey-perl
  mysql-client-5.5 mysql-client-core-5.5 mysql-common mysql-server-5.5
  mysql-server-core-5.5
建议安装的软件包：
  libmldbm-perl libnet-daemon-perl libplrpc-perl libsql-statement-perl tinyca
  mailx
推荐安装的软件包：
  libhtml-template-perl
下列【新】软件包将被安装：
  libdbd-mysql-perl libdbi-perl libmysqlclient18 libterm-readkey-perl
  mysql-client-5.5 mysql-client-core-5.5 mysql-common mysql-server
  mysql-server-5.5 mysql-server-core-5.5
升级了 0 个软件包，新安装了 10 个软件包，要卸载 0 个软件包，有 220 个软件包未被升级。
需要下载 9,642 kB 的软件包。
解压缩后会消耗掉 96.9 MB 的额外空间。
您希望继续执行吗？ [Y/n] y
获取：1 http://mirrors.hust.edu.cn/ubuntu/ trusty-updates/main mysql-common all 5.5.55-0ubuntu0.14.04.1 [13.0 kB]
获取：2 http://mirrors.hust.edu.cn/ubuntu/ trusty-updates/main libmysqlclient18 amd64 5.5.55-0ubuntu0.14.04.1 [597 kB]
获取：3 http://mirrors.hust.edu.cn/ubuntu/ trusty/main libdbi-perl amd64 1.630-1 [879 kB]
获取：4 http://mirrors.hust.edu.cn/ubuntu/ trusty-updates/main libdbd-mysql-perl amd64 4.025-1ubuntu0.1 [87.6 kB]
获取：5 http://mirrors.hust.edu.cn/ubuntu/ trusty/main libterm-readkey-perl amd64 2.31-1 [27.4 kB]
获取：6 http://mirrors.hust.edu.cn/ubuntu/ trusty-updates/main mysql-client-core-5.5 amd64 5.5.55-0ubuntu0.14.04.1 [707 kB]
获取：7 http://mirrors.hust.edu.cn/ubuntu/ trusty-updates/main mysql-client-5.5 amd64 5.5.55-0ubuntu0.14.04.1 [1,586 kB]
获取：8 http://mirrors.hust.edu.cn/ubuntu/ trusty-updates/main mysql-server-core-5.5 amd64 5.5.55-0ubuntu0.14.04.1 [3,737 kB]
获取：9 http://mirrors.hust.edu.cn/ubuntu/ trusty-updates/main mysql-server-5.5 amd64 5.5.55-0ubuntu0.14.04.1 [1,996 kB]
获取：10 http://mirrors.hust.edu.cn/ubuntu/ trusty-updates/main mysql-server all 5.5.55-0ubuntu0.14.04.1 [11.3 kB]
下载 9,642 kB，耗时 39秒 (247 kB/s)                                            
正在预设定软件包 ...
Selecting previously unselected package mysql-common.
(正在读取数据库 ... 系统当前共安装有 177786 个文件和目录。)
Preparing to unpack .../mysql-common_5.5.55-0ubuntu0.14.04.1_all.deb ...
Unpacking mysql-common (5.5.55-0ubuntu0.14.04.1) ...
Selecting previously unselected package libmysqlclient18:amd64.
Preparing to unpack .../libmysqlclient18_5.5.55-0ubuntu0.14.04.1_amd64.deb ...
Unpacking libmysqlclient18:amd64 (5.5.55-0ubuntu0.14.04.1) ...
Selecting previously unselected package libdbi-perl.
Preparing to unpack .../libdbi-perl_1.630-1_amd64.deb ...
Unpacking libdbi-perl (1.630-1) ...
Selecting previously unselected package libdbd-mysql-perl.
Preparing to unpack .../libdbd-mysql-perl_4.025-1ubuntu0.1_amd64.deb ...
Unpacking libdbd-mysql-perl (4.025-1ubuntu0.1) ...
Selecting previously unselected package libterm-readkey-perl.
Preparing to unpack .../libterm-readkey-perl_2.31-1_amd64.deb ...
Unpacking libterm-readkey-perl (2.31-1) ...
Selecting previously unselected package mysql-client-core-5.5.
Preparing to unpack .../mysql-client-core-5.5_5.5.55-0ubuntu0.14.04.1_amd64.deb ...
Unpacking mysql-client-core-5.5 (5.5.55-0ubuntu0.14.04.1) ...
Selecting previously unselected package mysql-client-5.5.
Preparing to unpack .../mysql-client-5.5_5.5.55-0ubuntu0.14.04.1_amd64.deb ...
Unpacking mysql-client-5.5 (5.5.55-0ubuntu0.14.04.1) ...
Selecting previously unselected package mysql-server-core-5.5.
Preparing to unpack .../mysql-server-core-5.5_5.5.55-0ubuntu0.14.04.1_amd64.deb ...
Unpacking mysql-server-core-5.5 (5.5.55-0ubuntu0.14.04.1) ...
Processing triggers for man-db (2.6.7.1-1ubuntu1) ...
正在设置 mysql-common (5.5.55-0ubuntu0.14.04.1) ...
Selecting previously unselected package mysql-server-5.5.
(正在读取数据库 ... 系统当前共安装有 178142 个文件和目录。)
Preparing to unpack .../mysql-server-5.5_5.5.55-0ubuntu0.14.04.1_amd64.deb ...
Unpacking mysql-server-5.5 (5.5.55-0ubuntu0.14.04.1) ...
Selecting previously unselected package mysql-server.
Preparing to unpack .../mysql-server_5.5.55-0ubuntu0.14.04.1_all.deb ...
Unpacking mysql-server (5.5.55-0ubuntu0.14.04.1) ...
Processing triggers for ureadahead (0.100.0-16) ...
ureadahead will be reprofiled on next reboot
Processing triggers for man-db (2.6.7.1-1ubuntu1) ...
正在设置 libmysqlclient18:amd64 (5.5.55-0ubuntu0.14.04.1) ...
正在设置 libdbi-perl (1.630-1) ...
正在设置 libdbd-mysql-perl (4.025-1ubuntu0.1) ...
正在设置 libterm-readkey-perl (2.31-1) ...
正在设置 mysql-client-core-5.5 (5.5.55-0ubuntu0.14.04.1) ...
正在设置 mysql-client-5.5 (5.5.55-0ubuntu0.14.04.1) ...
正在设置 mysql-server-core-5.5 (5.5.55-0ubuntu0.14.04.1) ...
正在设置 mysql-server-5.5 (5.5.55-0ubuntu0.14.04.1) ...
170619 13:44:23 [Warning] Using unique option prefix key_buffer instead of key_buffer_size is deprecated and will be removed in a future release. Please use the full name instead.
170619 13:44:23 [Note] Ignoring --secure-file-priv value as server is running with --bootstrap.
170619 13:44:23 [Note] /usr/sbin/mysqld (mysqld 5.5.55-0ubuntu0.14.04.1) starting as process 17651 ...
mysql start/running, process 17782
Processing triggers for ureadahead (0.100.0-16) ...
正在设置 mysql-server (5.5.55-0ubuntu0.14.04.1) ...
Processing triggers for libc-bin (2.19-0ubuntu6.9) ...
/sbin/ldconfig.real: /usr/lib/nvidia-375/libEGL.so.1 is not a symbolic link

/sbin/ldconfig.real: /usr/lib32/nvidia-375/libEGL.so.1 is not a symbolic link

cg@cg-ThinkPad-Edge-E540 ~ $ 
</code></pre><h3 id="远程连接mysql服务器"><a href="#远程连接mysql服务器" class="headerlink" title="远程连接mysql服务器"></a>远程连接mysql服务器</h3><p>先测试下连接本地数据库</p>
<pre><code>cg@cg-ThinkPad-Edge-E540 ~ $ mysql
ERROR 1045 (28000): Access denied for user &apos;cg&apos;@&apos;localhost&apos; (using password: NO)
cg@cg-ThinkPad-Edge-E540 ~ $ mysql -u root -p
Enter password: 
Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 43
Server version: 5.5.55-0ubuntu0.14.04.1 (Ubuntu)

Copyright (c) 2000, 2017, Oracle and/or its affiliates. All rights reserved.

Oracle is a registered trademark of Oracle Corporation and/or its
affiliates. Other names may be trademarks of their respective
owners.

Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement.

mysql&gt; show databases
    -&gt; show databases;
ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &apos;show databases&apos; at line 2
mysql&gt; show databases
    -&gt; 
  -&gt; ^Z
[1]+  Stopped                 mysql -u root -p
</code></pre><p>正常即可连接远程数据库</p>
<pre><code>cg@cg-ThinkPad-Edge-E540 ~ $ mysql -h 182.254.213.111 -P 3306 -u root -p
Enter password: 
Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 4618
Server version: 5.7.15 MySQL Community Server (GPL)

Copyright (c) 2000, 2017, Oracle and/or its affiliates. All rights reserved.

Oracle is a registered trademark of Oracle Corporation and/or its
affiliates. Other names may be trademarks of their respective
owners.

Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement.
</code></pre><h3 id="查询操作"><a href="#查询操作" class="headerlink" title="查询操作"></a>查询操作</h3><p>连接完成之后,可以使用命令</p>
<p><code>show databases;</code></p>
<p>来显示数据库的库信息</p>
<p>使用命令</p>
<p><code>show tables;</code></p>
<p>来显示当前库中表的信息,当然前提需要指定库</p>
<p>指定库使用命令</p>
<p><code>use xxxx;</code></p>
<p>这跟mysql语句都是一样的</p>
<p>当时过程如下:</p>
<pre><code>mysql&gt; show databases;
    +--------------------------+
    | Database                 |
    +--------------------------+
    | information_schema       |
    | cruise                   |
    | jinbang                  |
    | jinbangH5                |
    | jinbang_dev_shiqingju    |
    | jinbang_dev_shiqingkun   |
    | jinbang_dev_zhouminxiang |
    | jinbang_portal           |
    | jinbang_portal1          |
    | mysql                    |
    | performance_schema       |
    | sys                      |
    | test1                    |
    | test2                    |
    | test3                    |
    | test4                    |
    | test5                    |
    | wordpress                |
    | yihaiyou_test            |
    +--------------------------+
    19 rows in set (0.03 sec)

mysql&gt; help

For information about MySQL products and services, visit:
   http://www.mysql.com/
For developer information, including the MySQL Reference Manual, visit:
   http://dev.mysql.com/
To buy MySQL Enterprise support, training, or other products, visit:
   https://shop.mysql.com/

List of all MySQL commands:
Note that all text commands must be first on line and end with &apos;;&apos;
?         (\?) Synonym for `help&apos;.
clear     (\c) Clear the current input statement.
connect   (\r) Reconnect to the server. Optional arguments are db and host.
delimiter (\d) Set statement delimiter.
edit      (\e) Edit command with $EDITOR.
ego       (\G) Send command to mysql server, display result vertically.
exit      (\q) Exit mysql. Same as quit.
go        (\g) Send command to mysql server.
help      (\h) Display this help.
nopager   (\n) Disable pager, print to stdout.
notee     (\t) Don&apos;t write into outfile.
pager     (\P) Set PAGER [to_pager]. Print the query results via PAGER.
print     (\p) Print current command.
prompt    (\R) Change your mysql prompt.
quit      (\q) Quit mysql.
rehash    (\#) Rebuild completion hash.
source    (\.) Execute an SQL script file. Takes a file name as an argument.
status    (\s) Get status information from the server.
system    (\!) Execute a system shell command.
tee       (\T) Set outfile [to_outfile]. Append everything into given outfile.
use       (\u) Use another database. Takes database name as argument.
charset   (\C) Switch to another charset. Might be needed for processing binlog with multi-byte charsets.
warnings  (\W) Show warnings after every statement.
nowarning (\w) Don&apos;t show warnings after every statement.

For server side help, type &apos;help contents&apos;

mysql&gt; use yihaiyou_test;
Reading table information for completion of table and column names
You can turn off this feature to get a quicker startup with -A

Database changed
mysql&gt; use yihaiyou_test;
Reading table information for completion of table and column names
You can turn off this feature to get a quicker startup with -A

Database changed
mysql&gt; show tables;
+---------------------------------+
| Tables_in_yihaiyou_test         |
+---------------------------------+
| acc                             |
| account_log                     |
| activities                      |
| ads                             |
| advice                          |
| api_monitor                     |
| article_category                |
| bak_sys_menu                    |
| bak_sys_role                    |
| bak_sys_role_menu               |
| bak_sys_user_role               |
| bankcard                        |
| board_location                  |
| category                        |
| category_type                   |
| cmbpaylog                       |
| coderepository                  |
| comment                         |
| comment_photo                   |
| comment_score                   |
| comment_score_type              |
| commission                      |
| contract                        |
| contract_appendices             |
| credit_card                     |
| cruise_ship                     |
| cruise_ship_date                |
| cruise_ship_deck                |
| cruise_ship_deck_facility       |
| cruise_ship_extend              |
| cruise_ship_plan                |
| cruise_ship_project             |
| cruise_ship_project_classify    |
| cruise_ship_project_image       |
| cruise_ship_room                |
| cruise_ship_room_date           |
| cruise_ship_visa                |
| ctrip_city                      |
| ctrip_region                    |
| ctrip_scenics                   |
| ctrip_user                      |
| custom_require                  |
| custom_require_destination      |
| cw_productitem                  |
| data_tasks                      |
| delicacy                        |
| delicacy_extend                 |
| delicacy_restaurant             |
| destination                     |
| elong_geo_cn                    |
| feed_back                       |
| ferrymember                     |
| ferryorder                      |
| ferryorderitem                  |
| flight_city                     |
| globalmoneyrecord               |
| hand_draw_map                   |
| hand_draw_scenic                |
| hotel                           |
| hotel_amenities                 |
| hotel_area                      |
| hotel_brand                     |
| hotel_city                      |
| hotel_city_brand                |
| hotel_city_service              |
| hotel_elong_api_log             |
| hotel_elong_static_info         |
| hotel_extend                    |
| hotel_price                     |
| hotel_price_calendar            |
| hotel_region                    |
| hotel_room                      |
| hotel_service_tmp               |
| hotel_to_update                 |
| impression                      |
| impression_gallery              |
| invoice                         |
| jszx_order                      |
| jszx_order_detail               |
| label                           |
| label_item                      |
| line                            |
| line_contact                    |
| line_departure                  |
| line_departure_info             |
| line_insurance                  |
| lineacrosscitys                 |
| linecategory                    |
| linecategorydetail              |
| linecost                        |
| linedayplaninfo                 |
| linedays                        |
| linedaysplan                    |
| linedaysproductprice            |
| lineexplain                     |
| lineimages                      |
| lineplaytitle                   |
| linestatistic                   |
| linetypeprice                   |
| linetypeprice_agent             |
| linetypepricedate               |
| lxb_advice                      |
| lxb_coupon                      |
| lxb_friend_link                 |
| lxb_insurance                   |
| lxb_labels                      |
| lxb_objectlabels                |
| lxb_sales_images                |
| lxb_user_coupon                 |
| member                          |
| msg_template                    |
| multi_date                      |
| nctrip_access_token             |
| nctrip_addinfo_detail           |
| nctrip_api_log                  |
| nctrip_display_tag              |
| nctrip_display_tag_group        |
| nctrip_order_contact_info       |
| nctrip_order_form_info          |
| nctrip_order_form_resource_info |
| nctrip_order_passenger_info     |
| nctrip_product_addinfo          |
| nctrip_resource_addinfo         |
| nctrip_resource_price_calendar  |
| nctrip_scenic_spot_city_info    |
| nctrip_scenic_spot_id           |
| nctrip_scenic_spot_info         |
| nctrip_scenic_spot_poi_info     |
| nctrip_scenic_spot_product      |
| nctrip_scenic_spot_resource     |
| order_refund                    |
| orderalias                      |
| other_favorite                  |
| other_message                   |
| other_visit_history             |
| outer_collect_info              |
| outer_mascot_bename             |
| outer_participator_answer       |
| outer_question                  |
| outer_question_candidate        |
| paylog                          |
| pinglun                         |
| pinglunreply                    |
| plan                            |
| plan_day                        |
| plan_statistic                  |
| plan_trip                       |
| plan_urban_traffic_rel          |
| playtitle                       |
| product                         |
| product_activity                |
| product_validate_channel        |
| product_validate_code           |
| productimage                    |
| productvalidatecode             |
| productvalidaterecord           |
| promotion                       |
| qrtz_blob_triggers              |
| qrtz_calendars                  |
| qrtz_cron_triggers              |
| qrtz_fired_triggers             |
| qrtz_job_details                |
| qrtz_locks                      |
| qrtz_paused_trigger_grps        |
| qrtz_scheduler_state            |
| qrtz_simple_triggers            |
| qrtz_simprop_triggers           |
| qrtz_triggers                   |
| quantity_sales                  |
| quantity_sales_detail           |
| quantity_unit_num               |
| qunar_sight                     |
| recday_scenics_num              |
| recommend_plan                  |
| recommend_plan_day              |
| recommend_plan_photo            |
| recommend_plan_tag              |
| recommend_plan_trip             |
| recpday_cityids                 |
| recplan_days                    |
| recplan_scenics                 |
| refund_log                      |
| region                          |
| reply                           |
| restaurang                      |
| restaurant                      |
| restaurant_extend               |
| restaurant_geoinfo              |
| scenic                          |
| scenic_area                     |
| scenic_extend                   |
| scenic_extend_tmp               |
| scenic_gallery                  |
| scenic_geoinfo                  |
| scenic_geoinfo_tmp              |
| scenic_relation                 |
| scenic_statistics               |
| scenic_theme                    |
| scenic_theme_relation           |
| scenic_tmp                      |
| sendingmsg                      |
| sendingmsg_his                  |
| serialscode                     |
| shenzhouaccesstoken             |
| shenzhouorder                   |
| supplier                        |
| suppliercity                    |
| supplierconfig                  |
| supplierservice                 |
| sys_action_log                  |
| sys_menu                        |
| sys_resource                    |
| sys_resource_map                |
| sys_role                        |
| sys_role_menu                   |
| sys_role_resource               |
| sys_site                        |
| sys_unit                        |
| sys_unit_detail                 |
| sys_unit_image                  |
| sys_unit_qualification          |
| sys_user                        |
| sys_user_role                   |
| t_base_pinyin                   |
| tb_area                         |
| tb_area_extend                  |
| tb_area_optimize_support_city   |
| tb_area_relation                |
| tb_dis                          |
| tb_ticket_validate_info         |
| tb_transportation               |
| tciket_price_type_extend        |
| testperson                      |
| third_party_user                |
| ticket                          |
| ticket_receiver                 |
| ticketdateprice                 |
| ticketexplain                   |
| ticketprice                     |
| ticketprice_agent               |
| tmp_time_desc                   |
| torder                          |
| tordercontact                   |
| torderdetail                    |
| torderdetailflattened           |
| torderinsurance                 |
| torderinvoice                   |
| torderlog                       |
| tordertourist                   |
| tourist                         |
| traffic                         |
| traffic_price                   |
| traffic_price_calendar          |
| user                            |
| user_copy                       |
| user_exinfo                     |
| user_relation                   |
| user_share_record               |
| userlevel                       |
| wx_account                      |
| wx_account_menu                 |
| wx_data_img                     |
| wx_data_img_text                |
| wx_data_item                    |
| wx_data_text                    |
| wx_follower                     |
| wx_location_log                 |
| wx_qrcode                       |
| wx_receive_msg_log              |
| wx_reply_keyword                |
| wx_reply_rule                   |
| wx_resource                     |
| wx_support_account              |
| wx_visit_log                    |
| yihaiyou                        |
| zhouandcountry                  |
| zmy_ticket                      |
+---------------------------------+
277 rows in set (0.06 sec)

mysql&gt; select * from sys_role;
+----+-------------------------+----------+--------+------+--------------------------------------------------------------------+--------+-------------+
| id | name                    | del_flag | status | seq  | remark                                                             | siteid | displayName |
+----+-------------------------+----------+--------+------+--------------------------------------------------------------------+--------+-------------+
| -2 | 系统管理员              |        0 |      0 |    0 | 内置超级管理员                                                     |     -1 | NULL        |
| -1 | 站点管理员              |        0 |      0 |    0 | 站点管理员,拥有所有权限                                            |     -1 | NULL        |
|  1 | 景点管理员              |        0 |      0 |    0 |                                                                    |     -1 | NULL        |
|  3 | 公司管理员              |        0 |      0 |    0 | 公司通过后授予该角色                                               |     -1 | NULL        |
|  4 | 酒店民宿系统            |        0 |      0 |    0 | 商户系统角色                                                       |     -1 | NULL        |
|  5 | 海上休闲系统            |        0 |      0 |    0 | 商户系统角色                                                       |     -1 | NULL        |
|  6 | 邮轮系统                |        0 |      0 |    0 | 商户系统角色                                                       |     -1 | NULL        |
|  7 | 景点门票系统            |        0 |      0 |    0 | 商户系统角色                                                       |     -1 | NULL        |
| 10 | 临时站点管理员          |        0 |      0 |    0 | 安全扫描临时使用角色2017.1.23                                      |     -1 | NULL        |
| 11 | 公司管理员(默认)        |        0 |      0 |    0 | 添加公司或公司入驻时，授予公司管理员默认角色                       |     -1 | NULL        |
+----+-------------------------+----------+--------+------+--------------------------------------------------------------------+--------+-------------+
10 rows in set (0.02 sec)

mysql&gt; select * from wx_visit_log;
Empty set (0.04 sec)

mysql&gt; 
</code></pre><p>数据库服务器连接完成之后,后面的操作命令则跟mysql语句都一样</p>
<hr>
<h4 id="update-2017-06-28"><a href="#update-2017-06-28" class="headerlink" title="update-2017-06-28"></a>update-2017-06-28</h4><p>查看表中的字段的备注信息，对字段名的含义了解</p>
<p>命令：</p>
<p><code>show full columns from xxx;</code></p>
<p>查看表的注释：</p>
<p><code>show create table xxx;</code></p>
<p><img src="/images/mysql/mysql-show-table.png" alt="mysql-show"></p>
]]></content>
      
        <categories>
            
            <category> mysql </category>
            
        </categories>
        
        
        <tags>
            
            <tag> codeing </tag>
            
            <tag> mysql </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[精致地生活]]></title>
      <url>/2017/05/11/daily/2017-05-11-daily-exquisiteLife/</url>
      <content type="html"><![CDATA[<p>我一直想过精致的生活<br>但<br>我一直找不到什么是精致的生活<br>我以前想的<br>就是认真的去做一件事<br>端端正正的去做</p>
<a id="more"></a>
<p>比如一个人吃饭<br>我就端正的坐着<br>碗摆好<br>筷子摆好<br>深呼吸一口气<br>把心思都放在饭上面<br>端正的看她<br>嘴角偶尔微微一笑<br>注释她的美<br>享受她的味<br>这就是我所做的精致的吃饭</p>
<p>但<br>要说精致地生活<br>这范围太大<br>我不知道如何去面对<br>就像海上钢琴师里面说的<br>在那个无限蔓延的城市里,什么东西都有,可惟独没有尽头.根本就没有尽头.看不见的是这一切的尽头,世界的尽头。<br>这让我无所适从<br>让我迷茫<br>适应不过来</p>
<p>所以<br>要说精致地生活<br>在这偌大僵硬的的城市里<br>我还不知道如何去精致<br>迷茫比向往大多了,,,,,,,</p>
<p>爱一个女人,住一间屋子,买一块地,望一个景,走一条死路.太多选择,我无所适从,漫无止境,茫茫无际。</p>
]]></content>
      
        <categories>
            
            <category> daily </category>
            
        </categories>
        
        
        <tags>
            
            <tag> daily </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[git使用]]></title>
      <url>/2017/05/10/git/2017-05-10-git-gitUse/</url>
      <content type="html"><![CDATA[<p>今天经理分配一个问题让去解决,就是git连接码云来进行项目的版本控制时,分支与主分支合并时的冲突问题,于是就打算今天拿出一天时间来弄这个问题,截止到现在,问题算是解决了,不过并不是采用我的方法.我的方法更老套,就是操作命令.而最后采用的是直接在idea上操作</p>
<a id="more"></a>
<p>折腾这么久,想想还是写在这里总结一下</p>
<h3 id="操作概述"><a href="#操作概述" class="headerlink" title="操作概述"></a>操作概述</h3><h4 id="git连接gitosc"><a href="#git连接gitosc" class="headerlink" title="git连接gitosc"></a>git连接gitosc</h4><p>如果在本地已建立仓库,且本地也与gitosc建立ssh安全连接<br><code>git remote add origin https://git.oschina.net/用户名/仓库名.git</code><br>注意:本地仓库名和远程建立的仓库名要一样</p>
<h4 id="第一步正常后"><a href="#第一步正常后" class="headerlink" title="第一步正常后"></a>第一步正常后</h4><p>输入<code>git pull origin master</code>,可提交并同步.git pull命令的作用是，取回远程主机某个分支的更新，再与本地的指定分支合并<br>注意:最后可以再输入<br><code>git push origin master</code><br>提交,这在github上可以一并完成</p>
<h4 id="本地更新后-同样"><a href="#本地更新后-同样" class="headerlink" title="本地更新后,同样"></a>本地更新后,同样</h4><p>命令:</p>
<ul>
<li>1.<code>git status</code>检查工作区是否有内容未被提交</li>
<li>2.<code>git add .</code>将所有未被提交的内容添加到暂存区</li>
<li>3.<code>git commit -m &quot;test again&quot;</code>为本次提交设置备注</li>
<li>4.<code>git push origin master</code>将master主分支提交到远程仓库</li>
</ul>
<h4 id="创建合并分支"><a href="#创建合并分支" class="headerlink" title="创建合并分支"></a>创建合并分支</h4><p>命令:</p>
<ul>
<li>1.<code>git branch xxxx</code>创建xxxx分支</li>
<li>2.<code>git checkout xxxx</code>切换到xxxx分支(可将上面1,2两条命令整合:<code>git checkout -b xxxx</code>)</li>
<li>3.<code>git merge xxxx</code>合并xxxx分支到当前分支</li>
<li>4.<code>git branch -d xxxx</code>删除xxxx分支</li>
</ul>
<p>注意:<br>第3步合并分支时,git一般使用”Fast forward”模式.在这种模式下,删除分支后,也会丢掉分支信息<br>所以未避免丢掉分支信息,就可以添加参数来禁用”Fast forward”模式<br>例如<br><code>git merge -no-ff -m &quot;注释&quot; xxxx</code><br>如果使用xxxx分支提交到远程仓库,那么,提交完成之后,远程仓库同样会有两条分支选择,一条master,一条xxxx<br>那么,在还没合并前,master主分支上是看不到xxxx分支提交的内容的,这是合乎情理的</p>
<h4 id="分支冲突描述"><a href="#分支冲突描述" class="headerlink" title="分支冲突描述"></a>分支冲突描述</h4><p>例如有两条分支,一条master主分支,一条xxxx分支,当前个分支上的内容都一样<br>此时,在master主分支上添加内容a后提交到远程仓库,xxxx分支上添加内容b后提交到远程仓库<br>当前都未合并,所以说双方都看不到各自提交的内容</p>
<h4 id="主分支和次分支的提交过程"><a href="#主分支和次分支的提交过程" class="headerlink" title="主分支和次分支的提交过程"></a>主分支和次分支的提交过程</h4><p>(主分支与次分支在同一本地仓库)当次分支更新了内容a到暂存区后,切换到主分支后依然可以查看次分支更新的内容a,但当次分支更新了内容a到暂存区后,又将内容a提交到远程仓库中,此时主分支就不能status到是否有内容未被提交,<br>也就不能查看到内容a了<br>那在此前提下继续操作<br>在主分支下,更新内容b到暂存区并提交到远程仓库,那么<br>在远程仓库中,主分支和次分支所现实的内容是不一样的,本地也是如此</p>
<h4 id="解决冲突的方法"><a href="#解决冲突的方法" class="headerlink" title="解决冲突的方法"></a>解决冲突的方法</h4><ul>
<li>1.<code>git reset --merge</code>:将主分支回退到merge前(首先一般都是在主分支合并次分支的)</li>
<li>2.更改需要保留的内容,使两个分支更新的内容一致,如果需要保留分支上的内容,那么则切换到主分支上,更改内容使其与分支上的内容一致</li>
<li>3.使内容一致后在将更改的分支提交到远程仓库</li>
</ul>
<p>另外说下,<br>1.本地创建分支后,是用新分支提交内容到远程仓库会同步创建分支,而本地删除分支后,status检查不到更改.打算提交更改内容,以此来尝试远程删除分支,依然没用<br>但远程仓库里提供了删除分支<br>所以,git新建分支时用分支push内容到远程仓库可以同步新建分支,git删除分支时就不会同步删除分支.可以手动在远程仓库进行删除操作<br>2.在分支合并的时候如果出现一些问题,导致下一步进行不下去,可以输入命令将其回退到合并前<br>一些其他的命令:</p>
<ul>
<li>git branch:列出所有分支,输出的前面有*号表示是当前分支</li>
<li>git log:查看所有日志</li>
<li>git diff xx:查看xx文件修改了那些内容</li>
<li>git remote:查看远程库的信息</li>
<li>git remote –v:查看远程库的详细信息</li>
<li>git reset –merge:回退到merge前</li>
<li>git reset  –hard HEAD^:回退到上一个版本(‘^’有多少个就回到多少个版本)</li>
<li>git rm xx:删除xx文件</li>
<li>git pull origin next:master 取回origin主机的next分支，与本地的master分支合并,如果远程分支是与当前分支合并，则冒号后面的部分可以省略:git pull origin next</li>
</ul>
<h3 id="操作实例"><a href="#操作实例" class="headerlink" title="操作实例"></a>操作实例</h3><h4 id="git连接gitosc-1"><a href="#git连接gitosc-1" class="headerlink" title="git连接gitosc"></a>git连接gitosc</h4><pre><code>cg@cg-ThinkPad-Edge-E540 ~ $ cd Work/GitoscWork
cg@cg-ThinkPad-Edge-E540 ~/Work/GitoscWork $ ls
test-1
cg@cg-ThinkPad-Edge-E540 ~/Work/GitoscWork $ cd test-1
cg@cg-ThinkPad-Edge-E540 ~/Work/GitoscWork/test-1 $ git init
Initialized empty Git repository in /home/cg/Work/GitoscWork/test-1/.git/
cg@cg-ThinkPad-Edge-E540 ~/Work/GitoscWork/test-1 $ pwd
/home/cg/Work/GitoscWork/test-1
cg@cg-ThinkPad-Edge-E540 ~/Work/GitoscWork/test-1 $ git status
On branch master

Initial commit

Untracked files:
  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)

    testDemo

nothing added to commit but untracked files present (use &quot;git add&quot; to track)
cg@cg-ThinkPad-Edge-E540 ~/Work/GitoscWork/test-1 $ git add testDemo
cg@cg-ThinkPad-Edge-E540 ~/Work/GitoscWork/test-1 $ git commit -m &quot;first create&quot;
[master (root-commit) a391ca3] first create
 1 file changed, 2 insertions(+)
 create mode 100644 testDemo
cg@cg-ThinkPad-Edge-E540 ~/Work/GitoscWork/test-1 $ git status
On branch master
nothing to commit, working directory clean
cg@cg-ThinkPad-Edge-E540 ~/Work/GitoscWork/test-1 $ ssh -T git@git.oschina.net
The authenticity of host &apos;git.oschina.net (116.211.167.14)&apos; can&apos;t be established.
ECDSA key fingerprint is 27:e5:d3:f7:2a:9e:eb:6c:93:cd:1f:c1:47:a3:54:b1.
Are you sure you want to continue connecting (yes/no)? y
Please type &apos;yes&apos; or &apos;no&apos;: yes
Warning: Permanently added &apos;git.oschina.net,116.211.167.14&apos; (ECDSA) to the list of known hosts.
Connection closed by 116.211.167.14
cg@cg-ThinkPad-Edge-E540 ~/Work/GitoscWork/test-1 $ ^C
cg@cg-ThinkPad-Edge-E540 ~/Work/GitoscWork/test-1 $ git --help
usage: git [--version] [--help] [-C &lt;path&gt;] [-c name=value]
       [--exec-path[=&lt;path&gt;]] [--html-path] [--man-path] [--info-path]
       [-p|--paginate|--no-pager] [--no-replace-objects] [--bare]
       [--git-dir=&lt;path&gt;] [--work-tree=&lt;path&gt;] [--namespace=&lt;name&gt;]
       &lt;command&gt; [&lt;args&gt;]

The most commonly used git commands are:
   add        Add file contents to the index
   bisect     Find by binary search the change that introduced a bug
   branch     List, create, or delete branches
   checkout   Checkout a branch or paths to the working tree
   clone      Clone a repository into a new directory
   commit     Record changes to the repository
   diff       Show changes between commits, commit and working tree, etc
   fetch      Download objects and refs from another repository
   grep       Print lines matching a pattern
   init       Create an empty Git repository or reinitialize an existing one
   log        Show commit logs
   merge      Join two or more development histories together
   mv         Move or rename a file, a directory, or a symlink
   pull       Fetch from and integrate with another repository or a local branch
   push       Update remote refs along with associated objects
   rebase     Forward-port local commits to the updated upstream head
   reset      Reset current HEAD to the specified state
   rm         Remove files from the working tree and from the index
   show       Show various types of objects
   status     Show the working tree status
   tag        Create, list, delete or verify a tag object signed with GPG

&apos;git help -a&apos; and &apos;git help -g&apos; lists available subcommands and some
concept guides. See &apos;git help &lt;command&gt;&apos; or &apos;git help &lt;concept&gt;&apos;
to read about a specific subcommand or concept.
cg@cg-ThinkPad-Edge-E540 ~/Work/GitoscWork/test-1 $ git config  -help
usage: git config [options]

Config file location
    --global              use global config file
    --system              use system config file
    --local               use repository config file
    -f, --file &lt;file&gt;     use given config file
    --blob &lt;blob-id&gt;      read config from given blob object

Action
    --get                 get value: name [value-regex]
    --get-all             get all values: key [value-regex]
    --get-regexp          get values for regexp: name-regex [value-regex]
    --get-urlmatch        get value specific for the URL: section[.var] URL
    --replace-all         replace all matching variables: name value [value_regex]
    --add                 add a new variable: name value
    --unset               remove a variable: name [value-regex]
    --unset-all           remove all matches: name [value-regex]
    --rename-section      rename section: old-name new-name
    --remove-section      remove a section: name
    -l, --list            list all
    -e, --edit            open an editor
    --get-color &lt;slot&gt;    find the color configured: [default]
    --get-colorbool &lt;slot&gt;
                      find the color setting: [stdout-is-tty]

Type
    --bool                value is &quot;true&quot; or &quot;false&quot;
    --int                 value is decimal number
    --bool-or-int         value is --bool or --int
    --path                value is a path (file or directory name)

Other
    -z, --null            terminate values with NUL byte
    --includes            respect include directives on lookup

cg@cg-ThinkPad-Edge-E540 ~/Work/GitoscWork/test-1 $ git remote add origin https://git.oschina.net/cg0827/test-1.gitcg@cg-ThinkPad-Edge-E540 ~/Work/GitoscWork/test-1 $ git remote add origin https://git.oschina.net/cg0827/test-1.git
fatal: remote origin already exists.
cg@cg-ThinkPad-Edge-E540 ~/Work/GitoscWork/test-1 $ git push -help
usage: git push [&lt;options&gt;] [&lt;repository&gt; [&lt;refspec&gt;...]]

    -v, --verbose         be more verbose
    -q, --quiet           be more quiet
    --repo &lt;repository&gt;   repository
    --all                 push all refs
    --mirror              mirror all refs
    --delete              delete refs
    --tags                push tags (can&apos;t be used with --all or --mirror)
    -n, --dry-run         dry run
    --porcelain           machine-readable output
    -f, --force           force updates
    --force-with-lease[=&lt;refname&gt;:&lt;expect&gt;]
                      require old value of ref to be at this value
    --recurse-submodules[=&lt;check&gt;]
                      control recursive pushing of submodules
    --thin                use thin pack
    --receive-pack &lt;receive-pack&gt;
                      receive pack program
    --exec &lt;receive-pack&gt;
                      receive pack program
    -u, --set-upstream    set upstream for git pull/status
    --progress            force progress reporting
    --prune               prune locally removed refs
    --no-verify           bypass pre-push hook
    --follow-tags         push missing but relevant tags

cg@cg-ThinkPad-Edge-E540 ~/Work/GitoscWork/test-1 $ git push -u origin master
Username for &apos;https://git.oschina.net&apos;: cg0827
Password for &apos;https://cg0827@git.oschina.net&apos;: 
To https://git.oschina.net/cg0827/test-1.git
 ! [rejected]        master -&gt; master (fetch first)
error: failed to push some refs to &apos;https://git.oschina.net/cg0827/test-1.git&apos;
hint: Updates were rejected because the remote contains work that you do
hint: not have locally. This is usually caused by another repository pushing
hint: to the same ref. You may want to first integrate the remote changes
hint: (e.g., &apos;git pull ...&apos;) before pushing again.
hint: See the &apos;Note about fast-forwards&apos; in &apos;git push --help&apos; for details.
cg@cg-ThinkPad-Edge-E540 ~/Work/GitoscWork/test-1 $ git status
On branch master
nothing to commit, working directory clean
cg@cg-ThinkPad-Edge-E540 ~/Work/GitoscWork/test-1 $ git remote add origin https://git.oschina.net/cg0827/test-1.git
fatal: remote origin already exists.
cg@cg-ThinkPad-Edge-E540 ~/Work/GitoscWork/test-1 $ git pull
Username for &apos;https://git.oschina.net&apos;: cg0827
Password for &apos;https://cg0827@git.oschina.net&apos;: 
warning: no common commits
remote: Counting objects: 3, done.
remote: Total 3 (delta 0), reused 0 (delta 0)
Unpacking objects: 100% (3/3), done.
From https://git.oschina.net/cg0827/test-1
 * [new branch]      master     -&gt; origin/master
There is no tracking information for the current branch.
Please specify which branch you want to merge with.
See git-pull(1) for details

    git pull &lt;remote&gt; &lt;branch&gt;

If you wish to set tracking information for this branch you can do so with:

    git branch --set-upstream-to=origin/&lt;branch&gt; master

cg@cg-ThinkPad-Edge-E540 ~/Work/GitoscWork/test-1 $ git pull -h
usage: git pull [-n | --no-stat] [--[no-]commit] [--[no-]squash] [--[no-]ff] [--[no-]rebase|--rebase=preserve] [-s strategy]... [&lt;fetch-options&gt;] &lt;repo&gt; &lt;head&gt;...

Fetch one or more remote refs and integrate it/them with the current HEAD.
cg@cg-ThinkPad-Edge-E540 ~/Work/GitoscWork/test-1 $ git-pull(1)
bash: syntax error near unexpected token `1&apos;
cg@cg-ThinkPad-Edge-E540 ~/Work/GitoscWork/test-1 $ git pull origin master
Username for &apos;https://git.oschina.net&apos;: cg0827
Password for &apos;https://cg0827@git.oschina.net&apos;: 
From https://git.oschina.net/cg0827/test-1
 * branch            master     -&gt; FETCH_HEAD
Merge made by the &apos;recursive&apos; strategy.
 README.md | 1 +
 1 file changed, 1 insertion(+)
 create mode 100644 README.md
cg@cg-ThinkPad-Edge-E540 ~/Work/GitoscWork/test-1 $ git push -u origin master
Username for &apos;https://git.oschina.net&apos;: cg0827
Password for &apos;https://cg0827@git.oschina.net&apos;: 
Counting objects: 6, done.
Delta compression using up to 4 threads.
Compressing objects: 100% (3/3), done.
Writing objects: 100% (5/5), 550 bytes | 0 bytes/s, done.
Total 5 (delta 0), reused 0 (delta 0)
To https://git.oschina.net/cg0827/test-1.git
   eac4c33..a8d7464  master -&gt; master
Branch master set up to track remote branch master from origin.
cg@cg-ThinkPad-Edge-E540 ~/Work/GitoscWork/test-1 $ 
</code></pre><h4 id="提交更新"><a href="#提交更新" class="headerlink" title="提交更新"></a>提交更新</h4><p>在本地仓库创建文件后,提交更新到远程仓库</p>
<pre><code>cg@cg-ThinkPad-Edge-E540 ~/Work/GitoscWork/test-1 $ git status
On branch master
Your branch is up-to-date with &apos;origin/master&apos;.

Changes not staged for commit:
  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)

    modified:   testDemo

no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)
cg@cg-ThinkPad-Edge-E540 ~/Work/GitoscWork/test-1 $ git add .
cg@cg-ThinkPad-Edge-E540 ~/Work/GitoscWork/test-1 $ git commit -m &quot;test second&quot;
[master f1f28d4] test second
 1 file changed, 1 insertion(+)
cg@cg-ThinkPad-Edge-E540 ~/Work/GitoscWork/test-1 $ git push origin master
Username for &apos;https://git.oschina.net&apos;: cg0827
Password for &apos;https://cg0827@git.oschina.net&apos;: 
Counting objects: 5, done.
Delta compression using up to 4 threads.
Compressing objects: 100% (3/3), done.
Writing objects: 100% (3/3), 317 bytes | 0 bytes/s, done.
Total 3 (delta 0), reused 0 (delta 0)
To https://git.oschina.net/cg0827/test-1.git
   a8d7464..f1f28d4  master -&gt; master
cg@cg-ThinkPad-Edge-E540 ~/Work/GitoscWork/test-1 $ 
</code></pre><h4 id="创建合并分支-1"><a href="#创建合并分支-1" class="headerlink" title="创建合并分支"></a>创建合并分支</h4><p>创建一个test2分支</p>
<pre><code>cg@cg-ThinkPad-Edge-E540 ~/Work/GitoscWork/test-1 $ git branch
* master
cg@cg-ThinkPad-Edge-E540 ~/Work/GitoscWork/test-1 $ git branch test2
cg@cg-ThinkPad-Edge-E540 ~/Work/GitoscWork/test-1 $ git checkout test2
Switched to branch &apos;test2&apos;
cg@cg-ThinkPad-Edge-E540 ~/Work/GitoscWork/test-1 $ git branch
  master
* test2
cg@cg-ThinkPad-Edge-E540 ~/Work/GitoscWork/test-1 $ git status
On branch test2
Changes not staged for commit:
  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)

    modified:   testDemo

no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)
cg@cg-ThinkPad-Edge-E540 ~/Work/GitoscWork/test-1 $ git checkout master
M    testDemo
Switched to branch &apos;master&apos;
Your branch is up-to-date with &apos;origin/master&apos;.
cg@cg-ThinkPad-Edge-E540 ~/Work/GitoscWork/test-1 $ git status
On branch master
Your branch is up-to-date with &apos;origin/master&apos;.

Changes not staged for commit:
  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)

    modified:   testDemo

no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)
cg@cg-ThinkPad-Edge-E540 ~/Work/GitoscWork/test-1 $ git checkout test2
M    testDemo
Switched to branch &apos;test2&apos;
cg@cg-ThinkPad-Edge-E540 ~/Work/GitoscWork/test-1 $ git status
On branch test2
Changes not staged for commit:
  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)

    modified:   testDemo

no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)
cg@cg-ThinkPad-Edge-E540 ~/Work/GitoscWork/test-1 $ git add .
cg@cg-ThinkPad-Edge-E540 ~/Work/GitoscWork/test-1 $ git commit -m &quot;branch test2 to create&quot;
[test2 a95ff74] branch test2 to create
 1 file changed, 2 insertions(+)
cg@cg-ThinkPad-Edge-E540 ~/Work/GitoscWork/test-1 $ git push origin master
Username for &apos;https://git.oschina.net&apos;: ^C
cg@cg-ThinkPad-Edge-E540 ~/Work/GitoscWork/test-1 $ git branch
  master
* test2
cg@cg-ThinkPad-Edge-E540 ~/Work/GitoscWork/test-1 $ git push origin test2
Username for &apos;https://git.oschina.net&apos;: cg0827
Password for &apos;https://cg0827@git.oschina.net&apos;: 
Counting objects: 5, done.
Delta compression using up to 4 threads.
Compressing objects: 100% (3/3), done.
Writing objects: 100% (3/3), 347 bytes | 0 bytes/s, done.
Total 3 (delta 0), reused 0 (delta 0)
To https://git.oschina.net/cg0827/test-1.git
 * [new branch]      test2 -&gt; test2
cg@cg-ThinkPad-Edge-E540 ~/Work/GitoscWork/test-1 $ git branch
  master
* test2
cg@cg-ThinkPad-Edge-E540 ~/Work/GitoscWork/test-1 $ git checkout master
Switched to branch &apos;master&apos;
Your branch is up-to-date with &apos;origin/master&apos;.
cg@cg-ThinkPad-Edge-E540 ~/Work/GitoscWork/test-1 $ ls
README.md  testDemo
cg@cg-ThinkPad-Edge-E540 ~/Work/GitoscWork/test-1 $ cat testDemo
1.测试-----2017-0510-08:59:58

2.test----2017-0510-09:50:12
cg@cg-ThinkPad-Edge-E540 ~/Work/GitoscWork/test-1 $ git checkout test2
Switched to branch &apos;test2&apos;
cg@cg-ThinkPad-Edge-E540 ~/Work/GitoscWork/test-1 $ cat testDemo
1.测试-----2017-0510-08:59:58

2.test----2017-0510-09:50:12

3.分支:test2----2017-0510-10:08:02
cg@cg-ThinkPad-Edge-E540 ~/Work/GitoscWork/test-1 $ git branch
  master
* test2
cg@cg-ThinkPad-Edge-E540 ~/Work/GitoscWork/test-1 $ git checkout master
Switched to branch &apos;master&apos;
Your branch is up-to-date with &apos;origin/master&apos;.
cg@cg-ThinkPad-Edge-E540 ~/Work/GitoscWork/test-1 $ git merge test2
Updating f1f28d4..a95ff74
Fast-forward
 testDemo | 2 ++
 1 file changed, 2 insertions(+)
cg@cg-ThinkPad-Edge-E540 ~/Work/GitoscWork/test-1 $ cat testDemo
1.测试-----2017-0510-08:59:58

2.test----2017-0510-09:50:12

3.分支:test2----2017-0510-10:08:02
cg@cg-ThinkPad-Edge-E540 ~/Work/GitoscWork/test-1 $ 
cg@cg-ThinkPad-Edge-E540 ~/Work/GitoscWork/test-1 $ git push origin master
Username for &apos;https://git.oschina.net&apos;: cg0827
Password for &apos;https://cg0827@git.oschina.net&apos;: 
Total 0 (delta 0), reused 0 (delta 0)
To https://git.oschina.net/cg0827/test-1.git
   f1f28d4..a95ff74  master -&gt; master
cg@cg-ThinkPad-Edge-E540 ~/Work/GitoscWork/test-1 $ 
</code></pre><h4 id="冲突情况一"><a href="#冲突情况一" class="headerlink" title="冲突情况一"></a>冲突情况一</h4><p>不确定这是否算是冲突,在本地同一仓库中的分支上更改内容后,并提交到暂存区后,切换到主分支上后,status可以检查到,也能查看到相应的更改内容</p>
<pre><code>cg@cg-ThinkPad-Edge-E540 ~/Work/GitoscWork/test-1 $ git checkout test2
Switched to branch &apos;test2&apos;
cg@cg-ThinkPad-Edge-E540 ~/Work/GitoscWork/test-1 $ git branch
  master
* test2
cg@cg-ThinkPad-Edge-E540 ~/Work/GitoscWork/test-1 $ git status
On branch test2
Changes not staged for commit:
  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)

    modified:   testDemo

no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)
cg@cg-ThinkPad-Edge-E540 ~/Work/GitoscWork/test-1 $ git add testDemo
cg@cg-ThinkPad-Edge-E540 ~/Work/GitoscWork/test-1 $ git checkout master
M    testDemo
Switched to branch &apos;master&apos;
Your branch is up-to-date with &apos;origin/master&apos;.
cg@cg-ThinkPad-Edge-E540 ~/Work/GitoscWork/test-1 $ git status
On branch master
Your branch is up-to-date with &apos;origin/master&apos;.

Changes to be committed:
  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)

    modified:   testDemo

cg@cg-ThinkPad-Edge-E540 ~/Work/GitoscWork/test-1 $ cat testDemo
1.测试-----2017-0510-08:59:58

2.test----2017-0510-09:50:12

3.分支:test2----2017-0510-10:08:02

4.分支test2存入--------2017-0510-10:30:24
cg@cg-ThinkPad-Edge-E540 ~/Work/GitoscWork/test-1 $ git status
On branch master
Your branch is up-to-date with &apos;origin/master&apos;.

Changes to be committed:
  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)

    modified:   testDemo

Changes not staged for commit:
  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)

    modified:   testDemo

cg@cg-ThinkPad-Edge-E540 ~/Work/GitoscWork/test-1 $ cat testDemo
1.测试-----2017-0510-08:59:58

2.test----2017-0510-09:50:12

3.分支:test2----2017-0510-10:08:02

4.分支test2存入--------2017-0510-10:30:24

5.主分支master写入--------2017-0510-10:32:50
cg@cg-ThinkPad-Edge-E540 ~/Work/GitoscWork/test-1 $ git add testDemo
cg@cg-ThinkPad-Edge-E540 ~/Work/GitoscWork/test-1 $ git push origin master
Username for &apos;https://git.oschina.net&apos;: cg082702
Password for &apos;https://cg082702@git.oschina.net&apos;: 
cg@cg-ThinkPad-Edge-E540 ~/Work/GitoscWork/test-1 $ git push origin master
Username for &apos;https://git.oschina.net&apos;: cg0827
Password for &apos;https://cg0827@git.oschina.net&apos;: 
Everything up-to-date
cg@cg-ThinkPad-Edge-E540 ~/Work/GitoscWork/test-1 $ git commit -m &quot;branch master update&quot;
[master 6ce4589] branch master update
 1 file changed, 4 insertions(+)
cg@cg-ThinkPad-Edge-E540 ~/Work/GitoscWork/test-1 $ git branch
* master
  test2
cg@cg-ThinkPad-Edge-E540 ~/Work/GitoscWork/test-1 $ git push origin master
Username for &apos;https://git.oschina.net&apos;: cg0827 
Password for &apos;https://cg0827@git.oschina.net&apos;: 
Counting objects: 5, done.
Delta compression using up to 4 threads.
Compressing objects: 100% (3/3), done.
Writing objects: 100% (3/3), 391 bytes | 0 bytes/s, done.
Total 3 (delta 0), reused 0 (delta 0)
To https://git.oschina.net/cg0827/test-1.git
   a95ff74..6ce4589  master -&gt; master
cg@cg-ThinkPad-Edge-E540 ~/Work/GitoscWork/test-1 $ git checkout test2
Switched to branch &apos;test2&apos;
cg@cg-ThinkPad-Edge-E540 ~/Work/GitoscWork/test-1 $ git status
On branch test2
nothing to commit, working directory clean
cg@cg-ThinkPad-Edge-E540 ~/Work/GitoscWork/test-1 $ cat testDemo
1.测试-----2017-0510-08:59:58

2.test----2017-0510-09:50:12

3.分支:test2----2017-0510-10:08:02
cg@cg-ThinkPad-Edge-E540 ~/Work/GitoscWork/test-1 $ 
cg@cg-ThinkPad-Edge-E540 ~/Work/GitoscWork/test-1 $ git merge master
Updating a95ff74..6ce4589
Fast-forward
 testDemo | 4 ++++
 1 file changed, 4 insertions(+)
cg@cg-ThinkPad-Edge-E540 ~/Work/GitoscWork/test-1 $ cat testDemo
1.测试-----2017-0510-08:59:58

2.test----2017-0510-09:50:12

3.分支:test2----2017-0510-10:08:02

4.分支test2存入--------2017-0510-10:30:24

5.主分支master写入--------2017-0510-10:32:50
cg@cg-ThinkPad-Edge-E540 ~/Work/GitoscWork/test-1 $ 
</code></pre><h4 id="分支冲突合并"><a href="#分支冲突合并" class="headerlink" title="分支冲突合并"></a>分支冲突合并</h4><p>当次分支和主分支都更改了内容时,输入代码<br><code>git merge test3</code>后<br>说是将分支合并到主分支上,<br>其实是将两分支更改的内容都显示在主分支的文件里,这样是为了能在主分支上更方便的对比选择保留那个分支上更改的内容</p>
<p><img src="/images/git/git-gitUse.png" alt="分支合并后选择"></p>
<pre><code>cg@cg-ThinkPad-Edge-E540 ~/Work/GitoscWork/test-1 $ git branch
  master
* test3
cg@cg-ThinkPad-Edge-E540 ~/Work/GitoscWork/test-1 $ git status
On branch test3
Changes not staged for commit:
  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)

    modified:   testDemo

no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)
cg@cg-ThinkPad-Edge-E540 ~/Work/GitoscWork/test-1 $ git add .
cg@cg-ThinkPad-Edge-E540 ~/Work/GitoscWork/test-1 $ git commit -m &quot;push branch test3&quot;
[test3 7e54227] push branch test3
 1 file changed, 2 insertions(+)
cg@cg-ThinkPad-Edge-E540 ~/Work/GitoscWork/test-1 $ git push origin test3
Username for &apos;https://git.oschina.net&apos;: cg0827 
Password for &apos;https://cg0827@git.oschina.net&apos;: 
Counting objects: 5, done.
Delta compression using up to 4 threads.
Compressing objects: 100% (3/3), done.
Writing objects: 100% (3/3), 343 bytes | 0 bytes/s, done.
Total 3 (delta 1), reused 0 (delta 0)
To https://git.oschina.net/cg0827/test-1.git
 * [new branch]      test3 -&gt; test3
cg@cg-ThinkPad-Edge-E540 ~/Work/GitoscWork/test-1 $ git branch
  master
* test3
cg@cg-ThinkPad-Edge-E540 ~/Work/GitoscWork/test-1 $ git checkout test3
Already on &apos;test3&apos;
cg@cg-ThinkPad-Edge-E540 ~/Work/GitoscWork/test-1 $ git checkout master
Switched to branch &apos;master&apos;
Your branch is up-to-date with &apos;origin/master&apos;.
cg@cg-ThinkPad-Edge-E540 ~/Work/GitoscWork/test-1 $ git status
On branch master
Your branch is up-to-date with &apos;origin/master&apos;.

nothing to commit, working directory clean
cg@cg-ThinkPad-Edge-E540 ~/Work/GitoscWork/test-1 $ git status
On branch master
Your branch is up-to-date with &apos;origin/master&apos;.

Changes not staged for commit:
  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)

    modified:   testDemo

no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)
cg@cg-ThinkPad-Edge-E540 ~/Work/GitoscWork/test-1 $ git add .
cg@cg-ThinkPad-Edge-E540 ~/Work/GitoscWork/test-1 $ git commit -m &quot;test in master for test3&quot;
[master fe73e5d] test in master for test3
 1 file changed, 2 insertions(+)
cg@cg-ThinkPad-Edge-E540 ~/Work/GitoscWork/test-1 $ git push origin master
Username for &apos;https://git.oschina.net&apos;: cg0827
Password for &apos;https://cg0827@git.oschina.net&apos;: 
Counting objects: 7, done.
Delta compression using up to 4 threads.
Compressing objects: 100% (3/3), done.
Writing objects: 100% (3/3), 340 bytes | 0 bytes/s, done.
Total 3 (delta 1), reused 0 (delta 0)
To https://git.oschina.net/cg0827/test-1.git
   889a0f8..fe73e5d  master -&gt; master
cg@cg-ThinkPad-Edge-E540 ~/Work/GitoscWork/test-1 $ git branch
* master
  test3
cg@cg-ThinkPad-Edge-E540 ~/Work/GitoscWork/test-1 $ cat testDemo
1.测试-----2017-0510-08:59:58

2.test----2017-0510-09:50:12

3.分支:test2----2017-0510-10:08:02

4.分支test2存入--------2017-0510-10:30:24

5.主分支master写入--------2017-0510-10:32:50

6.分支test2写入---------2017-0510-10:48:22

7.删除test2分支--------2017-0510-10:58:21

8.添加test3分支----------2017-0510-11:15:38

9.验证master关于test3分支----------2017-0510-11:34:15
cg@cg-ThinkPad-Edge-E540 ~/Work/GitoscWork/test-1 $ git checkout test3
Switched to branch &apos;test3&apos;
cg@cg-ThinkPad-Edge-E540 ~/Work/GitoscWork/test-1 $ cat testDemo
1.测试-----2017-0510-08:59:58

2.test----2017-0510-09:50:12

3.分支:test2----2017-0510-10:08:02

4.分支test2存入--------2017-0510-10:30:24

5.主分支master写入--------2017-0510-10:32:50

6.分支test2写入---------2017-0510-10:48:22

7.删除test2分支--------2017-0510-10:58:21

8.添加test3分支----------2017-0510-11:15:38

9.push分支test3---------2017-0510-11:28:03
cg@cg-ThinkPad-Edge-E540 ~/Work/GitoscWork/test-1 $ git branch
  master
* test3
cg@cg-ThinkPad-Edge-E540 ~/Work/GitoscWork/test-1 $ git checkout master
Switched to branch &apos;master&apos;
Your branch is up-to-date with &apos;origin/master&apos;.
cg@cg-ThinkPad-Edge-E540 ~/Work/GitoscWork/test-1 $ git merge test3
Auto-merging testDemo
CONFLICT (content): Merge conflict in testDemo
Automatic merge failed; fix conflicts and then commit the result.
cg@cg-ThinkPad-Edge-E540 ~/Work/GitoscWork/test-1 $ cat testDemo
1.测试-----2017-0510-08:59:58

2.test----2017-0510-09:50:12

3.分支:test2----2017-0510-10:08:02

4.分支test2存入--------2017-0510-10:30:24

5.主分支master写入--------2017-0510-10:32:50

6.分支test2写入---------2017-0510-10:48:22

7.删除test2分支--------2017-0510-10:58:21

8.添加test3分支----------2017-0510-11:15:38

&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
9.验证master关于test3分支----------2017-0510-11:34:15
=======
9.push分支test3---------2017-0510-11:28:03
&gt;&gt;&gt;&gt;&gt;&gt;&gt; test3
cg@cg-ThinkPad-Edge-E540 ~/Work/GitoscWork/test-1 $ 
cg@cg-ThinkPad-Edge-E540 ~/Work/GitoscWork/test-1 $ git status
On branch master
Your branch is up-to-date with &apos;origin/master&apos;.

You have unmerged paths.
  (fix conflicts and run &quot;git commit&quot;)

Unmerged paths:
  (use &quot;git add &lt;file&gt;...&quot; to mark resolution)

    both modified:      testDemo

no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)
cg@cg-ThinkPad-Edge-E540 ~/Work/GitoscWork/test-1 $ 
</code></pre><h4 id="分支合并解决方法"><a href="#分支合并解决方法" class="headerlink" title="分支合并解决方法"></a>分支合并解决方法</h4><p>merate遇到error,那么回退到merge,再把分支上的更改成master上</p>
<pre><code>cg@cg-ThinkPad-Edge-E540 ~/Work/GitoscWork/test-1 $ git merge test3
Auto-merging testDemo
CONFLICT (content): Merge conflict in testDemo
Automatic merge failed; fix conflicts and then commit the result.
cg@cg-ThinkPad-Edge-E540 ~/Work/GitoscWork/test-1 $ git status
On branch master
Your branch is up-to-date with &apos;origin/master&apos;.

You have unmerged paths.
  (fix conflicts and run &quot;git commit&quot;)

Unmerged paths:
  (use &quot;git add &lt;file&gt;...&quot; to mark resolution)

    both modified:      testDemo

no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)
cg@cg-ThinkPad-Edge-E540 ~/Work/GitoscWork/test-1 $ cat testDemo
1.测试-----2017-0510-08:59:58

2.test----2017-0510-09:50:12

3.分支:test2----2017-0510-10:08:02

4.分支test2存入--------2017-0510-10:30:24

5.主分支master写入--------2017-0510-10:32:50

6.分支test2写入---------2017-0510-10:48:22

7.删除test2分支--------2017-0510-10:58:21

8.添加test3分支----------2017-0510-11:15:38

&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
9.验证master关于test3分支----------2017-0510-11:34:15
=======
9.push分支test3---------2017-0510-11:28:03
&gt;&gt;&gt;&gt;&gt;&gt;&gt; test3
cg@cg-ThinkPad-Edge-E540 ~/Work/GitoscWork/test-1 $ git checkout test3
testDemo: needs merge
error: you need to resolve your current index first
cg@cg-ThinkPad-Edge-E540 ~/Work/GitoscWork/test-1 $ 
cg@cg-ThinkPad-Edge-E540 ~/Work/GitoscWork/test-1 $ git reset --merge
cg@cg-ThinkPad-Edge-E540 ~/Work/GitoscWork/test-1 $ git merge test3
Auto-merging testDemo
CONFLICT (content): Merge conflict in testDemo
Automatic merge failed; fix conflicts and then commit the result.
cg@cg-ThinkPad-Edge-E540 ~/Work/GitoscWork/test-1 $ git status
On branch master
Your branch is up-to-date with &apos;origin/master&apos;.

You have unmerged paths.
  (fix conflicts and run &quot;git commit&quot;)

Unmerged paths:
  (use &quot;git add &lt;file&gt;...&quot; to mark resolution)

    both modified:      testDemo

no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)
cg@cg-ThinkPad-Edge-E540 ~/Work/GitoscWork/test-1 $ cat testDemo
1.测试-----2017-0510-08:59:58

2.test----2017-0510-09:50:12

3.分支:test2----2017-0510-10:08:02

4.分支test2存入--------2017-0510-10:30:24

5.主分支master写入--------2017-0510-10:32:50

6.分支test2写入---------2017-0510-10:48:22

7.删除test2分支--------2017-0510-10:58:21

8.添加test3分支----------2017-0510-11:15:38

&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
9.验证master关于test3分支----------2017-0510-11:34:15
=======
9.push分支test3---------2017-0510-11:28:03
&gt;&gt;&gt;&gt;&gt;&gt;&gt; test3
cg@cg-ThinkPad-Edge-E540 ~/Work/GitoscWork/test-1 $ git checkout test3
testDemo: needs merge
error: you need to resolve your current index first
cg@cg-ThinkPad-Edge-E540 ~/Work/GitoscWork/test-1 $ git reset --merge
cg@cg-ThinkPad-Edge-E540 ~/Work/GitoscWork/test-1 $ git checkout test3
Switched to branch &apos;test3&apos;
cg@cg-ThinkPad-Edge-E540 ~/Work/GitoscWork/test-1 $ cat testDemo
1.测试-----2017-0510-08:59:58

2.test----2017-0510-09:50:12

3.分支:test2----2017-0510-10:08:02

4.分支test2存入--------2017-0510-10:30:24

5.主分支master写入--------2017-0510-10:32:50

6.分支test2写入---------2017-0510-10:48:22

7.删除test2分支--------2017-0510-10:58:21

8.添加test3分支----------2017-0510-11:15:38

9.push分支test3---------2017-0510-11:28:03
cg@cg-ThinkPad-Edge-E540 ~/Work/GitoscWork/test-1 $ git status
On branch test3
Changes not staged for commit:
  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)

    modified:   testDemo

no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)
cg@cg-ThinkPad-Edge-E540 ~/Work/GitoscWork/test-1 $ cat testDemo
1.测试-----2017-0510-08:59:58

2.test----2017-0510-09:50:12

3.分支:test2----2017-0510-10:08:02

4.分支test2存入--------2017-0510-10:30:24

5.主分支master写入--------2017-0510-10:32:50

6.分支test2写入---------2017-0510-10:48:22

7.删除test2分支--------2017-0510-10:58:21

8.添加test3分支----------2017-0510-11:15:38

9.验证master关于test3分支----------2017-0510-11:34:15
cg@cg-ThinkPad-Edge-E540 ~/Work/GitoscWork/test-1 $ 
cg@cg-ThinkPad-Edge-E540 ~/Work/GitoscWork/test-1 $ git checkout master
error: Your local changes to the following files would be overwritten by checkout:
    testDemo
Please, commit your changes or stash them before you can switch branches.
Aborting
cg@cg-ThinkPad-Edge-E540 ~/Work/GitoscWork/test-1 $ git add .
cg@cg-ThinkPad-Edge-E540 ~/Work/GitoscWork/test-1 $ git commit -m &quot;test3 change to master&quot;
[test3 e00cda5] test3 change to master
 1 file changed, 1 insertion(+), 1 deletion(-)
cg@cg-ThinkPad-Edge-E540 ~/Work/GitoscWork/test-1 $ git push origin test3
Username for &apos;https://git.oschina.net&apos;: cg0827  
Password for &apos;https://cg0827@git.oschina.net&apos;: 
Counting objects: 1, done.
Writing objects: 100% (1/1), 188 bytes | 0 bytes/s, done.
Total 1 (delta 0), reused 0 (delta 0)
To https://git.oschina.net/cg0827/test-1.git
   7e54227..e00cda5  test3 -&gt; test3
cg@cg-ThinkPad-Edge-E540 ~/Work/GitoscWork/test-1 $ 
cg@cg-ThinkPad-Edge-E540 ~/Work/GitoscWork/test-1 $ git checkout master
Switched to branch &apos;master&apos;
Your branch is up-to-date with &apos;origin/master&apos;.
cg@cg-ThinkPad-Edge-E540 ~/Work/GitoscWork/test-1 $ git merge test3
Merge made by the &apos;recursive&apos; strategy.
cg@cg-ThinkPad-Edge-E540 ~/Work/GitoscWork/test-1 $ git status
On branch master
Your branch is ahead of &apos;origin/master&apos; by 3 commits.
  (use &quot;git push&quot; to publish your local commits)

nothing to commit, working directory clean
cg@cg-ThinkPad-Edge-E540 ~/Work/GitoscWork/test-1 $ 
</code></pre>]]></content>
      
        <categories>
            
            <category> git </category>
            
        </categories>
        
        
        <tags>
            
            <tag> git </tag>
            
            <tag> codeing </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java-android反编译]]></title>
      <url>/2017/05/09/java/2017-05-09-java-Decompile-Tool/</url>
      <content type="html"><![CDATA[<p>今天在读公司之前开发的一个项目的代码,对其中的一段代码挺感兴趣,就尝试着自己敲,下载需要导入的jar包.自己单独运行看看效果.<br>不过其中一段小插曲,就是下载的包导入项目中后一直提示不出来,就是代码import不到,于是就想着去看看jar包里的代码是什么样的,心里怀疑这难不成是包里的类名换了,,,,?<br>于是就想到了我之前弄的android反编译.<br>时隔太久,担心忘了,就总结在此</p>
<a id="more"></a>
<p>后来查看之后才发现下载的jar包其实是个压缩包,里面才是真正需要用到的jar包.重新导入里面的包后,就ok了</p>
<h3 id="反编译用到的工具及下载地址"><a href="#反编译用到的工具及下载地址" class="headerlink" title="反编译用到的工具及下载地址:"></a>反编译用到的工具及下载地址:</h3><ul>
<li><a href="https://ibotpeaches.github.io/Apktool/" target="_blank" rel="external">apktool_2.2.1</a></li>
<li><a href="https://sourceforge.net/projects/dex2jar/files/" target="_blank" rel="external">dex2jar-2.0</a></li>
<li><a href="http://jd.benow.ca/jd-gui/downloads/jd-gui-0.3.5.linux.i686.tar.gz" target="_blank" rel="external">jd-gui-0.3.5</a></li>
</ul>
<h4 id="apktool-2-2-1"><a href="#apktool-2-2-1" class="headerlink" title="apktool_2.2.1"></a>apktool_2.2.1</h4><p>下载解压后文件夹下原只包含两个文件</p>
<p>apktool和apktool.jar<br>apktool为脚本,为运行apktool.jar</p>
<p>作用: 获取apk安装包里的资源文件和xml布局文件<br>使用方法: 运行命令<br><code>sudo ./apktool</code><br>可显示使用方法参数<br>反编译方法: 命令<br><code>sudo ./apktool d xxx.apk</code><br>来反编译xxx.apk文件,以此来获得apk文件的xml布局文件和资源文件<br>详细参数使用:<br><code>sudo ./apktool --help</code></p>
<h4 id="dex2jar-2-0"><a href="#dex2jar-2-0" class="headerlink" title="dex2jar-2.0"></a>dex2jar-2.0</h4><p>作用:这个工具用于将项目里的dex文件转换成jar文件<br>示例<br>这里测试反编译apk安装包<br>此前测试<br>过程:<br>apk包名:baidutieba_v7.9.2.apk,将此安装包重命名为后缀为<code>.zip</code>(或其他)的压缩文件,之后解压,即得到baidutieba_v7.9.2文件夹及内容,其中就有 classes.dex文件<br>将文件夹baidutieba_v7.9.2内的classes.dex文件复制到dex2jar-2.0文件夹中在dex2jar-2.0文件夹内运行命令<br><code>sudo ./d2j-dex2jar.sh classes.dex</code><br>后,即可在dex2jar-2.0中得到classes-dex2jar.jar文件<br>如若运行不了,则为脚本添加权限<br>剩余的任务交给jd-gui来查看即可</p>
<h4 id="jd-gui-0-3-5"><a href="#jd-gui-0-3-5" class="headerlink" title="jd-gui-0.3.5"></a>jd-gui-0.3.5</h4><p>作用: 用来查看.jar文件的源代码<br>双击运行即可</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>apktool_2.2.1用来获取.apk文件的资源文件</li>
<li>dex2jar-2.0和jd-gui-0.3.5两个工具结合起来用来获取apk安装包的源代码</li>
<li>jd-gui-0.3.5是用来查看.jar的java源代码,可以用在很多地方</li>
</ul>
<p>我已经将三个工具打包上传到百度云,链接: <a href="https://pan.baidu.com/s/1kVSJozH" target="_blank" rel="external">https://pan.baidu.com/s/1kVSJozH</a> 密码: xuq4</p>
]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> codeing </tag>
            
            <tag> java </tag>
            
            <tag> android </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[步入社会的第一次感受]]></title>
      <url>/2017/05/08/daily/2017-05-08-daily-companyDinnerParty-first/</url>
      <content type="html"><![CDATA[<p>现在是2017年5月8号 10:33分</p>
<p>昨天公司举行了开业典礼<br>白天做的无非就是招待领导吃饭喝酒</p>
<p>而昨天也有一位同事w离职,<br>晚上大家一块打算给w饯行<br>所以</p>
<a id="more"></a>
<p>一起吃个晚饭<br>随后一块去了另一位同事的酒吧玩</p>
<p>晚上喝醉了<br>但新认识了几个朋友</p>
<p>这一天下来<br>确实学到了不少<br>出社会的人行为举止都特别讲究<br>特别细腻<br>跟人交流都会站在他人的角度<br>细心观察<br>说话也都是一套一套的<br>全都是客套话<br>但不说不行,就是这样</p>
<p>所谓的君子之交淡如水<br>描述的就是社会上交朋友的样子吧</p>
<p>所以我还得继续学</p>
<p>这大概就是出社会的感觉吧</p>
]]></content>
      
        <categories>
            
            <category> daily </category>
            
        </categories>
        
        
        <tags>
            
            <tag> daily </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[关于厦门-始]]></title>
      <url>/2017/05/06/daily/2017-05-06-daily-xiamenBegin/</url>
      <content type="html"><![CDATA[<p>我现在人就在厦门,一家公司里实习.<br>公司是小公司,开始以为挺好的,后面接触多了,感觉也就那样.</p>
<p>上班一天下来也都是碌碌无趣<br>公司早上八点半上班.</p>
<p>早上八点从出租屋里出来,坐个公交车大概八点二十可以到公司,</p>
<a id="more"></a>
<p>中午十二点下班后就和同事在公司附近的小菜馆吃饭,完后回到公司忙自己的.</p>
<p>公司下午是两点上班,六点下班</p>
<p>自己下班后</p>
<p>一块钱坐个公交回去<br>或者<br>走路回去<br>沿着海边走走<br>吹吹风</p>
<p>周六周末<br>不用上班<br>也不知道去哪<br>有时候就去公司坐着<br>写写代码<br>做点自己的事</p>
<p>想起之前看到的一句花:这三年,你改变了多少.<br>对着细想,<br>我的三年只是刚开始,往后的三年间,或许我都将是一个人在厦门生活,伴着潮起日落</p>
<p>三年后,我不知道自己将会是一副什么样子</p>
]]></content>
      
        <categories>
            
            <category> daily </category>
            
        </categories>
        
        
        <tags>
            
            <tag> daily </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hexo搭建博客]]></title>
      <url>/2017/05/05/hexo/2017-05-05-hexoBlog/</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>我之前使用的是jekyll来创建博客,现在转用hexo了.其实在使用jekyll的时候就了解了hexo,那个时候也打算使用hexo来搭建博客,但苦于当时没能把hexo环境搭建好,急于求成就用已经搭建好环境的jekyll来创建博客了.<br>自己挺钟情hexo的,一直想用上她.恰好最近出差,利用空余的时间在宾馆把hexo环境搭建好了,把之前的博客也迁移到了hexo搭建的博客上面.做个总结,就写了这篇文章</p>
<p>文章中的命令行代码都是在搭建环境时所另外复制保存的</p>
<a id="more"></a>
<h3 id="了解使用hexo"><a href="#了解使用hexo" class="headerlink" title="了解使用hexo"></a>了解使用hexo</h3><h4 id="什么是Hexo"><a href="#什么是Hexo" class="headerlink" title="什么是Hexo"></a>什么是Hexo</h4><p>在使用hexo之前,首先我们先要了解什么是hexo,hexo是静态博客生成工具,单纯的生成静态html页面,将页面组合起来,就成了博客.当然,你也可以自己写html页面,写多个html页面,在将html页面手动联系起来,放在同一个站点下,也可以是一个博客,不过,使用hexo来创建博客将会更简单,更快捷方便。所以,hexo就是一个使搭建博客操作变得简单的工具,跟jekyll一个作用,详情,可以参考<a href="https://hexo.io/zh-cn/docs/index.html" target="_blank" rel="external">Hexo官方文档</a><br>ok,在我们已经知道hexo是什么之后,我们还需要稍微了解一下hexo她大概是怎么运作的<br>首先知道Hexo这个工具是由JavaScript编写的,那么我们在本地运行Hexo就需要JavaScript环境,即node.js。所以,我们需要安装node.js,至于node.js是什么.这里就不做介绍.不过需要知道node.js中包括了npm,npm是node.js的一个模块管理工具,目前使用她所起到的作用就像是一个下载器。跟命令apt-get命令差不多，其实说到JavaScript,个人认为,JavaScript到以后将会发展成主流编程语言,取代java<br>扯远了,,,,,,,,<br>再来了解hexo的运作方式,先看hexo默认生成的目录结构<br>如图:</p>
<p><img src="/images/hexo/hexo-blog-DefaultFile.png" alt="hexo-blog-defaultFile"></p>
<p>各文件作用:</p>
<ul>
<li>node_modules-存放所需要用到的js模块</li>
<li>scaffolds-存放页面模板</li>
<li>source-资源文件夹</li>
<li>themes-存放主题</li>
<li>_config.yml-站点的配置文件</li>
<li>db.json-数据缓存文件</li>
<li>package.json-应用程序的信息</li>
</ul>
<p>hexo有个专门存放主题的文件夹themes,存放这一个自带的主题landscape,更改主题则需要自己下载主题存放到该目录下,并在站点的配置文件_config.yml中进行配置,hexo生成静态html页面的原则就是依据模板文件和主题文件来自动生成html页面<br>所以,说到这,仔细想想,也可以说hexo是一个框架,工具和框架貌似都差不多.跟jekyll不同的是,hexo运行时不会生成html页面,需要输入执行命令后,才会生存html页面<br>生成的html页面将会在此时的hexo博客跟目录下新建一个public文件夹,所有的html页面和所需的资源都将存放到这个文件夹中.再说明一下,提交到github上面的文件也都只有public文件夹里的文件,其余的文件并不会提交到仓库中</p>
<h4 id="搭建hexo环境"><a href="#搭建hexo环境" class="headerlink" title="搭建hexo环境"></a>搭建hexo环境</h4><p>前面说到,hexo是使用JavaScript语言编写的,那么就需要先搭建好JavaScript环境,即安装node.js，这里个人建议到[node.js官网][]下载安装,并配置好环境变量,我这是linux内核系统<br>在linux下配置环境变量,运行命令<br><code>sudo gedit /etc/profile</code><br>在其中添加</p>
<pre><code>#set for nodejs-environment
#NODE_HOME的路径填写自己的node的安装路径
export NODE_HOME=/usr/local/src/node-v7.3.0
export PATH=$NODE_HOME/bin:$PATH
</code></pre><p>完后运行<br><code>source /etc/profile</code><br>来使配置立即生效.之后可以输入<br><code>node -v</code><br>来查看node.js是否安装成功,输出版本号则表示安装成功.完成node.js的安装,就可以使用npm命令来安装hexo了<br>运行命令<br><code>npm install -g hexo-cli</code><br>完后测试安装是否成功,如果不成功,看输出是什么样的,我是配置了hexo的环境变量<br>这里贴下我之前的命令行记录:</p>
<pre><code>cg@cg-ThinkPad-Edge-E540 ~ $ node -v
v6.9.2
cg@cg-ThinkPad-Edge-E540 ~ $ npm

Usage: npm &lt;command&gt;

where &lt;command&gt; is one of:
    access, adduser, bin, bugs, c, cache, completion, config,
    ddp, dedupe, deprecate, dist-tag, docs, edit, explore, get,
    help, help-search, i, init, install, install-test, it, link,
    list, ln, login, logout, ls, outdated, owner, pack, ping,
    prefix, prune, publish, rb, rebuild, repo, restart, root,
    run, run-script, s, se, search, set, shrinkwrap, star,
    stars, start, stop, t, tag, team, test, tst, un, uninstall,
    unpublish, unstar, up, update, v, version, view, whoami

npm &lt;cmd&gt; -h     quick help on &lt;cmd&gt;
npm -l           display full usage info
npm help &lt;term&gt;  search for help on &lt;term&gt;
npm help npm     involved overview

Specify configs in the ini-formatted file:
    /home/cg/.npmrc
or on the command line via: npm &lt;command&gt; --key value
Config info can be viewed via: npm help config

npm@3.10.9 /opt/node-v6.9.2-linux-x64/lib/node_modules/npm
cg@cg-ThinkPad-Edge-E540 ~ $ sudo npm install hexo-cli -g
[sudo] password for cg: 
/opt/node-v6.9.2-linux-x64/bin/hexo -&gt; /opt/node-v6.9.2-linux-x64/lib/node_modules/hexo-cli/bin/hexo

&gt; dtrace-provider@0.8.1 install /opt/node-v6.9.2-linux-x64/lib/node_modules/hexo-cli/node_modules/dtrace-provider
&gt; node scripts/install.js


&gt; hexo-util@0.6.0 postinstall /opt/node-v6.9.2-linux-x64/lib/node_modules/hexo-cli/node_modules/hexo-util
&gt; npm run build:highlight


&gt; hexo-util@0.6.0 build:highlight /opt/node-v6.9.2-linux-x64/lib/node_modules/hexo-cli/node_modules/hexo-util
&gt; node scripts/build_highlight_alias.js &gt; highlight_alias.json

/opt/node-v6.9.2-linux-x64/lib
└─┬ hexo-cli@1.0.2 
  ├── abbrev@1.1.0 
  ├── bluebird@3.5.0 
  ├─┬ chalk@1.1.3 
  │ ├── ansi-styles@2.2.1 
  │ ├── escape-string-regexp@1.0.5 
  │ ├─┬ has-ansi@2.0.0 
  │ │ └── ansi-regex@2.1.1 
  │ ├── strip-ansi@3.0.1 
  │ └── supports-color@2.0.0 
  ├─┬ hexo-fs@0.1.6 
  │ ├─┬ chokidar@1.6.1 
  │ │ ├─┬ anymatch@1.3.0 
  │ │ │ ├── arrify@1.0.1 
  │ │ │ └─┬ micromatch@2.3.11 
  │ │ │   ├─┬ arr-diff@2.0.0 
  │ │ │   │ └── arr-flatten@1.0.3 
  │ │ │   ├── array-unique@0.2.1 
  │ │ │   ├─┬ braces@1.8.5 
  │ │ │   │ ├─┬ expand-range@1.8.2 
  │ │ │   │ │ └─┬ fill-range@2.2.3 
  │ │ │   │ │   ├── is-number@2.1.0 
  │ │ │   │ │   ├── isobject@2.1.0 
  │ │ │   │ │   ├── randomatic@1.1.6 
  │ │ │   │ │   └── repeat-string@1.6.1 
  │ │ │   │ ├── preserve@0.2.0 
  │ │ │   │ └── repeat-element@1.1.2 
  │ │ │   ├─┬ expand-brackets@0.1.5 
  │ │ │   │ └── is-posix-bracket@0.1.1 
  │ │ │   ├── extglob@0.3.2 
  │ │ │   ├── filename-regex@2.0.0 
  │ │ │   ├─┬ kind-of@3.2.0 
  │ │ │   │ └── is-buffer@1.1.5 
  │ │ │   ├─┬ normalize-path@2.1.1 
  │ │ │   │ └── remove-trailing-separator@1.0.1 
  │ │ │   ├─┬ object.omit@2.0.1 
  │ │ │   │ ├─┬ for-own@0.1.5 
  │ │ │   │ │ └── for-in@1.0.2 
  │ │ │   │ └── is-extendable@0.1.1 
  │ │ │   ├─┬ parse-glob@3.0.4 
  │ │ │   │ ├── glob-base@0.3.0 
  │ │ │   │ └── is-dotfile@1.0.2 
  │ │ │   └─┬ regex-cache@0.4.3 
  │ │ │     ├── is-equal-shallow@0.1.3 
  │ │ │     └── is-primitive@2.0.0 
  │ │ ├── async-each@1.0.1 
  │ │ ├── glob-parent@2.0.0 
  │ │ ├── inherits@2.0.3 
  │ │ ├─┬ is-binary-path@1.0.1 
  │ │ │ └── binary-extensions@1.8.0 
  │ │ ├─┬ is-glob@2.0.1 
  │ │ │ └── is-extglob@1.0.0 
  │ │ ├── path-is-absolute@1.0.1 
  │ │ └─┬ readdirp@2.1.0 
  │ │   ├─┬ minimatch@3.0.3 
  │ │   │ └─┬ brace-expansion@1.1.7 
  │ │   │   ├── balanced-match@0.4.2 
  │ │   │   └── concat-map@0.0.1 
  │ │   ├─┬ readable-stream@2.2.9 
  │ │   │ ├── buffer-shims@1.0.0 
  │ │   │ ├── core-util-is@1.0.2 
  │ │   │ ├── isarray@1.0.0 
  │ │   │ ├── process-nextick-args@1.0.7 
  │ │   │ ├── string_decoder@1.0.0 
  │ │   │ └── util-deprecate@1.0.2 
  │ │   └── set-immediate-shim@1.0.1 
  │ └── graceful-fs@4.1.11 
  ├─┬ hexo-log@0.1.2 
  │ └─┬ bunyan@1.8.10 
  │   ├─┬ dtrace-provider@0.8.1 
  │   │ └── nan@2.6.2 
  │   ├── moment@2.18.1 
  │   ├─┬ mv@2.1.1 
  │   │ ├─┬ mkdirp@0.5.1 
  │   │ │ └── minimist@0.0.8 
  │   │ ├── ncp@2.0.0 
  │   │ └─┬ rimraf@2.4.5 
  │   │   └─┬ glob@6.0.4 
  │   │     ├─┬ inflight@1.0.6 
  │   │     │ └── wrappy@1.0.2 
  │   │     └── once@1.4.0 
  │   └── safe-json-stringify@1.0.4 
  ├─┬ hexo-util@0.6.0 
  │ ├─┬ camel-case@3.0.0 
  │ │ ├─┬ no-case@2.3.1 
  │ │ │ └── lower-case@1.1.4 
  │ │ └── upper-case@1.1.3 
  │ ├─┬ cross-spawn@4.0.2 
  │ │ ├─┬ lru-cache@4.0.2 
  │ │ │ ├── pseudomap@1.0.2 
  │ │ │ └── yallist@2.1.2 
  │ │ └─┬ which@1.2.14 
  │ │   └── isexe@2.0.0 
  │ ├── highlight.js@9.11.0 
  │ ├── html-entities@1.2.1 
  │ └── striptags@2.2.1 
  ├── minimist@1.2.0 
  ├── object-assign@4.1.1 
  └─┬ tildify@1.2.0 
    └── os-homedir@1.0.2 

npm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@^1.0.0 (node_modules/hexo-cli/node_modules/chokidar/node_modules/fsevents):
npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@1.1.1: wanted {&quot;os&quot;:&quot;darwin&quot;,&quot;arch&quot;:&quot;any&quot;} (current: {&quot;os&quot;:&quot;linux&quot;,&quot;arch&quot;:&quot;x64&quot;})
cg@cg-ThinkPad-Edge-E540 ~ $ hexo
hexo: command not found
cg@cg-ThinkPad-Edge-E540 ~ $ hexo init test
hexo: command not found
cg@cg-ThinkPad-Edge-E540 ~ $ 
</code></pre><p>这里看得出我的hexo安装并为成功,看得出此时需要做的是配置环境变量<br>而我,那个时候的我第一时间没那么去做</p>
<p>继续看如下:</p>
<pre><code>cg@cg-ThinkPad-Edge-E540 ~ $ export NVM_DIR=&quot;$HOME/.nvm&quot;
cg@cg-ThinkPad-Edge-E540 ~ $ nvm
No command &apos;nvm&apos; found, did you mean:
 Command &apos;npm&apos; from package &apos;npm&apos; (universe)
 Command &apos;nvi&apos; from package &apos;nvi&apos; (universe)
 Command &apos;vm&apos; from package &apos;mgetty-voice&apos; (universe)
 Command &apos;nam&apos; from package &apos;nam&apos; (universe)
 Command &apos;pvm&apos; from package &apos;pvm&apos; (universe)
 Command &apos;n-m&apos; from package &apos;python-networkmanager&apos; (universe)
 Command &apos;lvm&apos; from package &apos;lvm2&apos; (main)
 Command &apos;nm&apos; from package &apos;binutils&apos; (main)
 Command &apos;nm&apos; from package &apos;binutils-multiarch&apos; (main)
 Command &apos;kvm&apos; from package &apos;qemu-kvm&apos; (main)
nvm: command not found
cg@cg-ThinkPad-Edge-E540 ~ $ hexo
hexo: command not found
cg@cg-ThinkPad-Edge-E540 ~ $ curl -sL https://deb.nodesource.com/setup_6.x | sudo -E bash -
[sudo] password for cg: 
Sorry, try again.
[sudo] password for cg: 

## Installing the NodeSource Node.js v6.x repo...


## Populating apt-get cache...

+ apt-get update
忽略 http://mirrors.ustc.edu.cn rosa InRelease
忽略 http://mirrors.hust.edu.cn trusty InRelease
命中 http://archive.ubuntukylin.com:10006 xenial InRelease                     
命中 http://mirrors.ustc.edu.cn rosa Release.gpg                               
命中 http://mirrors.hust.edu.cn trusty-updates InRelease                       
命中 http://mirrors.ustc.edu.cn rosa Release                                   
命中 http://mirrors.hust.edu.cn trusty Release.gpg                             
命中 http://archive.ubuntukylin.com:10006 xenial/main amd64 Packages           
命中 http://mirrors.ustc.edu.cn rosa/main amd64 Packages                       
命中 http://mirrors.hust.edu.cn trusty-updates/main amd64 Packages             
命中 http://archive.ubuntukylin.com:10006 xenial/main i386 Packages            
命中 http://mirrors.hust.edu.cn trusty-updates/restricted amd64 Packages       
命中 http://mirrors.ustc.edu.cn rosa/upstream amd64 Packages                   
命中 http://archive.ubuntukylin.com:10006 xenial/main Translation-en           
命中 http://mirrors.hust.edu.cn trusty-updates/universe amd64 Packages         
命中 http://mirrors.ustc.edu.cn rosa/import amd64 Packages                     
命中 http://mirrors.hust.edu.cn trusty-updates/multiverse amd64 Packages       
命中 http://mirrors.ustc.edu.cn rosa/main i386 Packages                        
命中 http://mirrors.hust.edu.cn trusty-updates/main i386 Packages              
命中 http://mirrors.ustc.edu.cn rosa/upstream i386 Packages                    
命中 http://mirrors.hust.edu.cn trusty-updates/restricted i386 Packages        
获取：1 http://security.ubuntu.com trusty-security InRelease [65.9 kB]         
命中 http://mirrors.hust.edu.cn trusty-updates/universe i386 Packages          
命中 http://mirrors.ustc.edu.cn rosa/import i386 Packages                      
命中 http://mirrors.hust.edu.cn trusty-updates/multiverse i386 Packages        
命中 http://mirrors.hust.edu.cn trusty-updates/main Translation-en             
命中 http://mirrors.hust.edu.cn trusty-updates/multiverse Translation-en       
命中 http://mirrors.hust.edu.cn trusty-updates/restricted Translation-en       
命中 http://mirrors.hust.edu.cn trusty-updates/universe Translation-en         
命中 http://mirrors.hust.edu.cn trusty Release                                 
命中 http://mirrors.hust.edu.cn trusty/main amd64 Packages                     
忽略 http://ppa.launchpad.net trusty InRelease                                 
命中 http://mirrors.hust.edu.cn trusty/restricted amd64 Packages               
命中 http://mirrors.hust.edu.cn trusty/universe amd64 Packages                 
忽略 http://archive.canonical.com trusty InRelease                             
忽略 http://extra.linuxmint.com rosa InRelease                                 
忽略 http://ppa.launchpad.net trusty InRelease                                 
命中 http://mirrors.hust.edu.cn trusty/multiverse amd64 Packages               
命中 http://mirrors.hust.edu.cn trusty/main i386 Packages                      
命中 http://mirrors.hust.edu.cn trusty/restricted i386 Packages                
命中 http://mirrors.hust.edu.cn trusty/universe i386 Packages                  
命中 http://mirrors.hust.edu.cn trusty/multiverse i386 Packages                
命中 http://archive.canonical.com trusty Release.gpg                           
命中 http://mirrors.hust.edu.cn trusty/main Translation-zh_CN                  
获取：2 http://security.ubuntu.com trusty-security/main amd64 Packages [610 kB]
命中 http://mirrors.hust.edu.cn trusty/main Translation-en                     
命中 http://mirrors.hust.edu.cn trusty/multiverse Translation-zh_CN            
命中 http://archive.canonical.com trusty Release                               
命中 http://mirrors.hust.edu.cn trusty/multiverse Translation-en               
命中 http://mirrors.hust.edu.cn trusty/restricted Translation-zh_CN            
命中 http://mirrors.hust.edu.cn trusty/restricted Translation-en               
命中 http://archive.canonical.com trusty/partner amd64 Packages                
命中 http://mirrors.hust.edu.cn trusty/universe Translation-zh_CN              
命中 http://mirrors.hust.edu.cn trusty/universe Translation-en                 
命中 http://archive.canonical.com trusty/partner i386 Packages                 
命中 http://extra.linuxmint.com rosa Release.gpg                               
命中 http://archive.canonical.com trusty/partner Translation-en                
忽略 http://mirrors.ustc.edu.cn rosa/import Translation-zh_CN                  
忽略 http://mirrors.ustc.edu.cn rosa/import Translation-zh                     
忽略 http://mirrors.ustc.edu.cn rosa/import Translation-en                     
忽略 http://ppa.launchpad.net trusty InRelease                                 
忽略 http://mirrors.ustc.edu.cn rosa/main Translation-zh_CN                    
忽略 http://mirrors.ustc.edu.cn rosa/main Translation-zh                       
忽略 http://mirrors.hust.edu.cn trusty/main Translation-zh                     
忽略 http://mirrors.ustc.edu.cn rosa/main Translation-en                       
忽略 http://mirrors.hust.edu.cn trusty/multiverse Translation-zh               
忽略 http://mirrors.ustc.edu.cn rosa/upstream Translation-zh_CN                
忽略 http://mirrors.hust.edu.cn trusty/restricted Translation-zh               
忽略 http://mirrors.ustc.edu.cn rosa/upstream Translation-zh                   
忽略 http://mirrors.hust.edu.cn trusty/universe Translation-zh                 
忽略 http://mirrors.ustc.edu.cn rosa/upstream Translation-en                   
获取：3 http://security.ubuntu.com trusty-security/restricted amd64 Packages [14.0 kB]
命中 http://ppa.launchpad.net trusty Release.gpg                               
命中 http://extra.linuxmint.com rosa Release                                   
获取：4 http://security.ubuntu.com trusty-security/universe amd64 Packages [157 kB]
命中 http://ppa.launchpad.net trusty Release.gpg                               
命中 http://extra.linuxmint.com rosa/main amd64 Packages                       
忽略 http://ppa.launchpad.net trusty Release.gpg                               
命中 http://ppa.launchpad.net trusty Release                                   
获取：5 http://security.ubuntu.com trusty-security/multiverse amd64 Packages [4,135 B]
获取：6 http://security.ubuntu.com trusty-security/main i386 Packages [568 kB] 
命中 http://ppa.launchpad.net trusty Release                                   
忽略 http://ppa.launchpad.net trusty Release                                   
命中 http://ppa.launchpad.net trusty/main Sources                              
获取：7 http://security.ubuntu.com trusty-security/restricted i386 Packages [13.8 kB]
命中 http://ppa.launchpad.net trusty/main amd64 Packages                       
命中 http://ppa.launchpad.net trusty/main i386 Packages                        
获取：8 http://security.ubuntu.com trusty-security/universe i386 Packages [157 kB]
命中 http://ppa.launchpad.net trusty/main Translation-en                       
获取：9 http://security.ubuntu.com trusty-security/multiverse i386 Packages [4,288 B]
命中 http://ppa.launchpad.net trusty/main Sources                              
命中 http://ppa.launchpad.net trusty/main i386 Packages                        
命中 http://ppa.launchpad.net trusty/main amd64 Packages                       
命中 http://ppa.launchpad.net trusty/main Translation-en                       
命中 http://security.ubuntu.com trusty-security/main Translation-en            
命中 http://security.ubuntu.com trusty-security/multiverse Translation-en      
命中 http://security.ubuntu.com trusty-security/restricted Translation-en      
忽略 http://ppa.launchpad.net trusty/main Sources/DiffIndex                    
命中 http://security.ubuntu.com trusty-security/universe Translation-en        
忽略 http://ppa.launchpad.net trusty/main amd64 Packages/DiffIndex             
忽略 http://ppa.launchpad.net trusty/main i386 Packages/DiffIndex              
命中 http://extra.linuxmint.com rosa/main i386 Packages                        
忽略 http://extra.linuxmint.com rosa/main Translation-zh                       
忽略 http://extra.linuxmint.com rosa/main Translation-en                       
忽略 http://extra.linuxmint.com rosa/main Translation-zh_CN                    
忽略 http://ppa.launchpad.net trusty/main Translation-zh                       
忽略 http://ppa.launchpad.net trusty/main Translation-zh_CN
忽略 http://ppa.launchpad.net trusty/main Translation-en                       
错误 http://ppa.launchpad.net trusty/main amd64 Packages
  404  Not Found
错误 http://ppa.launchpad.net trusty/main Sources
  404  Not Found
错误 http://ppa.launchpad.net trusty/main i386 Packages
  404  Not Found
下载 1,594 kB，耗时 38秒 (41.3 kB/s)
W: 无法下载 http://ppa.launchpad.net/kilian/f.lux/ubuntu/dists/trusty/main/source/Sources  404  Not Found

W: 无法下载 http://ppa.launchpad.net/kilian/f.lux/ubuntu/dists/trusty/main/binary-amd64/Packages  404  Not Found

W: 无法下载 http://ppa.launchpad.net/kilian/f.lux/ubuntu/dists/trusty/main/binary-i386/Packages  404  Not Found

E: Some index files failed to download. They have been ignored, or old ones used instead.
Error executing command, exiting
cg@cg-ThinkPad-Edge-E540 ~ $ sudo apt-get install -y nodejs
正在读取软件包列表... 完成
正在分析软件包的依赖关系树       
正在读取状态信息... 完成       
nodejs is already the newest version.
升级了 0 个软件包，新安装了 0 个软件包，要卸载 0 个软件包，有 198 个软件包未被升级。
cg@cg-ThinkPad-Edge-E540 ~ $ 
</code></pre><p>看这个记录有意思,想想以后要是遇到问题真得先让自己清醒下来,抽根烟缓缓,不然又会傻逼一样犯错<br>不过运行上面那步之后,我才开始验证是否是环境变量的原因了</p>
<pre><code>cg@cg-ThinkPad-Edge-E540 ~ $ cd /opt/node-v6.9.2-linux-x64/lib
cg@cg-ThinkPad-Edge-E540 /opt/node-v6.9.2-linux-x64/lib $ ls
node_modules
cg@cg-ThinkPad-Edge-E540 /opt/node-v6.9.2-linux-x64/lib $ cd node_modules
cg@cg-ThinkPad-Edge-E540 /opt/node-v6.9.2-linux-x64/lib/node_modules $ ls
hexo  hexo-cli  npm
cg@cg-ThinkPad-Edge-E540 /opt/node-v6.9.2-linux-x64/lib/node_modules $ cd hexo
cg@cg-ThinkPad-Edge-E540 /opt/node-v6.9.2-linux-x64/lib/node_modules/hexo $ ls
bin  CONTRIBUTING.md  lib  LICENSE  node_modules  package.json  README.md
cg@cg-ThinkPad-Edge-E540 /opt/node-v6.9.2-linux-x64/lib/node_modules/hexo $ cd bin
cg@cg-ThinkPad-Edge-E540 /opt/node-v6.9.2-linux-x64/lib/node_modules/hexo/bin $ ls
hexo
cg@cg-ThinkPad-Edge-E540 /opt/node-v6.9.2-linux-x64/lib/node_modules/hexo/bin $ hexo
hexo: command not found
cg@cg-ThinkPad-Edge-E540 /opt/node-v6.9.2-linux-x64/lib/node_modules/hexo/bin $ ./hexo
Usage: hexo &lt;command&gt;

Commands:
  help     Get help on a command.
  init     Create a new Hexo folder.
  version  Display version information.

Global Options:
  --config  Specify config file instead of using _config.yml
  --cwd     Specify the CWD
  --debug   Display all verbose messages in the terminal
  --draft   Display draft posts
  --safe    Disable all plugins and scripts
  --silent  Hide output on console

For more help, you can use &apos;hexo help [command]&apos; for the detailed information
or you can check the docs: http://hexo.io/docs/
cg@cg-ThinkPad-Edge-E540 /opt/node-v6.9.2-linux-x64/lib/node_modules/hexo/bin $ cd ../../
cg@cg-ThinkPad-Edge-E540 /opt/node-v6.9.2-linux-x64/lib/node_modules $ ls
hexo  hexo-cli  npm
cg@cg-ThinkPad-Edge-E540 /opt/node-v6.9.2-linux-x64/lib/node_modules $ cd hexo-cli
cg@cg-ThinkPad-Edge-E540 /opt/node-v6.9.2-linux-x64/lib/node_modules/hexo-cli $ ls
assets  bin  completion  lib  LICENSE  node_modules  package.json  README.md
cg@cg-ThinkPad-Edge-E540 /opt/node-v6.9.2-linux-x64/lib/node_modules/hexo-cli $ cd bin
cg@cg-ThinkPad-Edge-E540 /opt/node-v6.9.2-linux-x64/lib/node_modules/hexo-cli/bin $ ls
hexo
cg@cg-ThinkPad-Edge-E540 /opt/node-v6.9.2-linux-x64/lib/node_modules/hexo-cli/bin $ ./hexo
Usage: hexo &lt;command&gt;

Commands:
  help     Get help on a command.
  init     Create a new Hexo folder.
  version  Display version information.

Global Options:
  --config  Specify config file instead of using _config.yml
  --cwd     Specify the CWD
  --debug   Display all verbose messages in the terminal
  --draft   Display draft posts
  --safe    Disable all plugins and scripts
  --silent  Hide output on console

For more help, you can use &apos;hexo help [command]&apos; for the detailed information
or you can check the docs: http://hexo.io/docs/
cg@cg-ThinkPad-Edge-E540 /opt/node-v6.9.2-linux-x64/lib/node_modules/hexo-cli/bin $ ./hexo -v
hexo-cli: 1.0.2
os: Linux 3.19.0-32-generic linux x64
http_parser: 2.7.0
node: 6.9.2
v8: 5.1.281.88
uv: 1.9.1
zlib: 1.2.8
ares: 1.10.1-DEV
icu: 57.1
modules: 48
openssl: 1.0.2j

cg@cg-ThinkPad-Edge-E540 /opt/node-v6.9.2-linux-x64/lib/node_modules/hexo-cli/bin $ 
</code></pre><p>确定了是环境变量的因素后,就开始解决了</p>
<pre><code>cg@cg-ThinkPad-Edge-E540 ~ $ sudo gedit /etc/profile
[sudo] password for cg: 
cg@cg-ThinkPad-Edge-E540 ~ $ source /etc/profile
cg@cg-ThinkPad-Edge-E540 ~ $ hexo
Usage: hexo &lt;command&gt;

Commands:
  help     Get help on a command.
  init     Create a new Hexo folder.
  version  Display version information.

Global Options:
  --config  Specify config file instead of using _config.yml
  --cwd     Specify the CWD
  --debug   Display all verbose messages in the terminal
  --draft   Display draft posts
  --safe    Disable all plugins and scripts
  --silent  Hide output on console

For more help, you can use &apos;hexo help [command]&apos; for the detailed information
or you can check the docs: http://hexo.io/docs/
cg@cg-ThinkPad-Edge-E540 ~ $ 
</code></pre><p>其中添加的环境变量:</p>
<pre><code>#set for hexo-environment
export HEXO_HOME=/opt/node-v6.9.2-linux-x64/lib/node_modules/hexo-cli
export PATH=$HEXO_HOME/bin:$PATH
</code></pre><p>上面的HEXO_HOME的路径修改成自己的<br>后面生成博客目录出了点问题:</p>
<pre><code>cg@cg-ThinkPad-Edge-E540 ~/Work $ cd HexoWork
cg@cg-ThinkPad-Edge-E540 ~/Work/HexoWork $ ls
blog
cg@cg-ThinkPad-Edge-E540 ~/Work/HexoWork $ cd blog
cg@cg-ThinkPad-Edge-E540 ~/Work/HexoWork/blog $ hexo -v
hexo-cli: 1.0.2
os: Linux 3.19.0-32-generic linux x64
http_parser: 2.7.0
node: 6.9.2
v8: 5.1.281.88
uv: 1.9.1
zlib: 1.2.8
ares: 1.10.1-DEV
icu: 57.1
modules: 48
openssl: 1.0.2j
cg@cg-ThinkPad-Edge-E540 ~/Work/HexoWork/blog $ hexo init
INFO  Cloning hexo-starter to ~/Work/HexoWork/blog
Cloning into &apos;/home/cg/Work/HexoWork/blog&apos;...
remote: Counting objects: 53, done.
remote: Total 53 (delta 0), reused 0 (delta 0), pack-reused 53
Unpacking objects: 100% (53/53), done.
Checking connectivity... done.
Submodule &apos;themes/landscape&apos; (https://github.com/hexojs/hexo-theme-landscape.git) registered for path &apos;themes/landscape&apos;
Cloning into &apos;themes/landscape&apos;...
remote: Counting objects: 775, done.
remote: Compressing objects: 100% (6/6), done.
remote: Total 775 (delta 1), reused 0 (delta 0), pack-reused 769
Receiving objects: 100% (775/775), 2.53 MiB | 7.00 KiB/s, done.
Resolving deltas: 100% (394/394), done.
Checking connectivity... done.
Submodule path &apos;themes/landscape&apos;: checked out &apos;decdc2d9956776cbe95420ae94bac87e22468d38&apos;
INFO  Install dependencies
npm WARN deprecated swig@1.4.2: This package is no longer maintained
^CINFO  Farewell...] \ fetchMetadata: sill mapToRegistry uri https://registry.npmjs.org/argparse
/opt/node-v6.9.2-linux-x64/lib/node_modules/hexo-cli/lib/hexo.js:95
    hexo.exit().then(function() {
           ^

TypeError: Cannot read property &apos;then&apos; of undefined
    at process.&lt;anonymous&gt; (/opt/node-v6.9.2-linux-x64/lib/node_modules/hexo-cli/lib/hexo.js:95:16)
    at emitNone (events.js:86:13)
    at process.emit (events.js:185:7)
    at Signal.wrap.onsignal (internal/process.js:199:44)
cg@cg-ThinkPad-Edge-E540 ~/Work/HexoWork/blog $ 
</code></pre><p>这个问题貌似是因为网速问题,有个方法说是更改淘宝镜像地址可以解决,不过我没有这样做,再运行一次,过一会儿时间就好了<br>安装hexo成功现实</p>
<pre><code>cg@cg-ThinkPad-Edge-E540 ~ $ hexo
Usage: hexo &lt;command&gt;

Commands:
  help     Get help on a command.
  init     Create a new Hexo folder.
  version  Display version information.

Global Options:
  --config  Specify config file instead of using _config.yml
  --cwd     Specify the CWD
  --debug   Display all verbose messages in the terminal
  --draft   Display draft posts
  --safe    Disable all plugins and scripts
  --silent  Hide output on console

For more help, you can use &apos;hexo help [command]&apos; for the detailed information
or you can check the docs: http://hexo.io/docs/
cg@cg-ThinkPad-Edge-E540 ~ $ node -v
v6.9.2
cg@cg-ThinkPad-Edge-E540 ~ $ hexo -v
hexo-cli: 1.0.2
os: Linux 3.19.0-32-generic linux x64
http_parser: 2.7.0
node: 6.9.2
v8: 5.1.281.88
uv: 1.9.1
zlib: 1.2.8
ares: 1.10.1-DEV
icu: 57.1
modules: 48
openssl: 1.0.2j
cg@cg-ThinkPad-Edge-E540 ~ $ cd Work/HexoWork
cg@cg-ThinkPad-Edge-E540 ~/Work/HexoWork $ ls
blog
cg@cg-ThinkPad-Edge-E540 ~/Work/HexoWork $ cd blog
cg@cg-ThinkPad-Edge-E540 ~/Work/HexoWork/blog $ ls
cg@cg-ThinkPad-Edge-E540 ~/Work/HexoWork/blog $ hexo init
INFO  Cloning hexo-starter to ~/Work/HexoWork/blog
Cloning into &apos;/home/cg/Work/HexoWork/blog&apos;...
remote: Counting objects: 53, done.
remote: Total 53 (delta 0), reused 0 (delta 0), pack-reused 53
Unpacking objects: 100% (53/53), done.
Checking connectivity... done.
Submodule &apos;themes/landscape&apos; (https://github.com/hexojs/hexo-theme-landscape.git) registered for path &apos;themes/landscape&apos;
Cloning into &apos;themes/landscape&apos;...
remote: Counting objects: 775, done.
remote: Compressing objects: 100% (6/6), done.
remote: Total 775 (delta 1), reused 0 (delta 0), pack-reused 769
Receiving objects: 100% (775/775), 2.53 MiB | 24.00 KiB/s, done.
Resolving deltas: 100% (394/394), done.
Checking connectivity... done.
Submodule path &apos;themes/landscape&apos;: checked out &apos;decdc2d9956776cbe95420ae94bac87e22468d38&apos;
INFO  Install dependencies
npm WARN deprecated swig@1.4.2: This package is no longer maintained
[    ...[    ..............] - fetchMetadata: sill mapToRegistry uri https://registry.nnpm WARN prefer global marked@0.3.6 should be installed with -g

&gt; dtrace-provider@0.8.1 install /home/cg/Work/HexoWork/blog/node_modules/dtrace-provider
&gt; node scripts/install.js


&gt; hexo-util@0.6.0 postinstall /home/cg/Work/HexoWork/blog/node_modules/hexo-util
&gt; npm run build:highlight


&gt; hexo-util@0.6.0 build:highlight /home/cg/Work/HexoWork/blog/node_modules/hexo-util
&gt; node scripts/build_highlight_alias.js &gt; highlight_alias.json

hexo-site@0.0.0 /home/cg/Work/HexoWork/blog
├─┬ hexo@3.3.5 
│ ├── abbrev@1.1.0 
│ ├── archy@1.0.0 
│ ├── bluebird@3.5.0 
│ ├─┬ chalk@1.1.3 
│ │ ├── ansi-styles@2.2.1 
│ │ ├── escape-string-regexp@1.0.5 
│ │ ├─┬ has-ansi@2.0.0 
│ │ │ └── ansi-regex@2.1.1 
│ │ ├── strip-ansi@3.0.1 
│ │ └── supports-color@2.0.0 
│ ├─┬ cheerio@0.20.0 
│ │ ├─┬ css-select@1.2.0 
│ │ │ ├── boolbase@1.0.0 
│ │ │ ├── css-what@2.1.0 
│ │ │ ├── domutils@1.5.1 
│ │ │ └── nth-check@1.0.1 
│ │ ├─┬ dom-serializer@0.1.0 
│ │ │ └── domelementtype@1.1.3 
│ │ ├── entities@1.1.1 
│ │ ├─┬ htmlparser2@3.8.3 
│ │ │ ├── domelementtype@1.3.0 
│ │ │ ├── domhandler@2.3.0 
│ │ │ ├── entities@1.0.0 
│ │ │ └─┬ readable-stream@1.1.14 
│ │ │   ├── core-util-is@1.0.2 
│ │ │   ├── isarray@0.0.1 
│ │ │   └── string_decoder@0.10.31 
│ │ └─┬ jsdom@7.2.2 
│ │   ├── abab@1.0.3 
│ │   ├── acorn@2.7.0 
│ │   ├── acorn-globals@1.0.9 
│ │   ├── cssom@0.3.2 
│ │   ├── cssstyle@0.2.37 
│ │   ├─┬ escodegen@1.8.1 
│ │   │ ├── esprima@2.7.3 
│ │   │ ├── estraverse@1.9.3 
│ │   │ ├── esutils@2.0.2 
│ │   │ ├─┬ optionator@0.8.2 
│ │   │ │ ├── deep-is@0.1.3 
│ │   │ │ ├── fast-levenshtein@2.0.6 
│ │   │ │ ├── levn@0.3.0 
│ │   │ │ ├── prelude-ls@1.1.2 
│ │   │ │ ├── type-check@0.3.2 
│ │   │ │ └── wordwrap@1.0.0 
│ │   │ └── source-map@0.2.0 
│ │   ├── nwmatcher@1.3.9 
│ │   ├── parse5@1.5.1 
│ │   ├─┬ request@2.81.0 
│ │   │ ├── aws-sign2@0.6.0 
│ │   │ ├── aws4@1.6.0 
│ │   │ ├── caseless@0.12.0 
│ │   │ ├─┬ combined-stream@1.0.5 
│ │   │ │ └── delayed-stream@1.0.0 
│ │   │ ├── extend@3.0.1 
│ │   │ ├── forever-agent@0.6.1 
│ │   │ ├─┬ form-data@2.1.4 
│ │   │ │ └── asynckit@0.4.0 
│ │   │ ├─┬ har-validator@4.2.1 
│ │   │ │ ├─┬ ajv@4.11.8 
│ │   │ │ │ ├── co@4.6.0 
│ │   │ │ │ └─┬ json-stable-stringify@1.0.1 
│ │   │ │ │   └── jsonify@0.0.0 
│ │   │ │ └── har-schema@1.0.5 
│ │   │ ├─┬ hawk@3.1.3 
│ │   │ │ ├── boom@2.10.1 
│ │   │ │ ├── cryptiles@2.0.5 
│ │   │ │ ├── hoek@2.16.3 
│ │   │ │ └── sntp@1.0.9 
│ │   │ ├─┬ http-signature@1.1.1 
│ │   │ │ ├── assert-plus@0.2.0 
│ │   │ │ ├─┬ jsprim@1.4.0 
│ │   │ │ │ ├── assert-plus@1.0.0 
│ │   │ │ │ ├── extsprintf@1.0.2 
│ │   │ │ │ ├── json-schema@0.2.3 
│ │   │ │ │ └── verror@1.3.6 
│ │   │ │ └─┬ sshpk@1.13.0 
│ │   │ │   ├── asn1@0.2.3 
│ │   │ │   ├── assert-plus@1.0.0 
│ │   │ │   ├── bcrypt-pbkdf@1.0.1 
│ │   │ │   ├─┬ dashdash@1.14.1 
│ │   │ │   │ └── assert-plus@1.0.0 
│ │   │ │   ├── ecc-jsbn@0.1.1 
│ │   │ │   ├─┬ getpass@0.1.7 
│ │   │ │   │ └── assert-plus@1.0.0 
│ │   │ │   ├── jodid25519@1.0.2 
│ │   │ │   ├── jsbn@0.1.1 
│ │   │ │   └── tweetnacl@0.14.5 
│ │   │ ├── is-typedarray@1.0.0 
│ │   │ ├── isstream@0.1.2 
│ │   │ ├── json-stringify-safe@5.0.1 
│ │   │ ├── oauth-sign@0.8.2 
│ │   │ ├── performance-now@0.2.0 
│ │   │ ├── qs@6.4.0 
│ │   │ ├── safe-buffer@5.0.1 
│ │   │ ├── stringstream@0.0.5 
│ │   │ ├── tunnel-agent@0.6.0 
│ │   │ └── uuid@3.0.1 
│ │   ├── sax@1.2.2 
│ │   ├── symbol-tree@3.2.2 
│ │   ├─┬ tough-cookie@2.3.2 
│ │   │ └── punycode@1.4.1 
│ │   ├── webidl-conversions@2.0.1 
│ │   ├─┬ whatwg-url-compat@0.6.5 
│ │   │ └── tr46@0.0.3 
│ │   └── xml-name-validator@2.0.1 
│ ├─┬ deep-assign@2.0.0 
│ │ └── is-obj@1.0.1 
│ ├─┬ hexo-cli@1.0.2 
│ │ └── minimist@1.2.0 
│ ├── hexo-front-matter@0.2.3 
│ ├─┬ hexo-fs@0.1.6 
│ │ ├─┬ chokidar@1.6.1 
│ │ │ ├─┬ anymatch@1.3.0 
│ │ │ │ ├── arrify@1.0.1 
│ │ │ │ └─┬ micromatch@2.3.11 
│ │ │ │   ├─┬ arr-diff@2.0.0 
│ │ │ │   │ └── arr-flatten@1.0.3 
│ │ │ │   ├── array-unique@0.2.1 
│ │ │ │   ├─┬ braces@1.8.5 
│ │ │ │   │ ├─┬ expand-range@1.8.2 
│ │ │ │   │ │ └─┬ fill-range@2.2.3 
│ │ │ │   │ │   ├── is-number@2.1.0 
│ │ │ │   │ │   ├─┬ isobject@2.1.0 
│ │ │ │   │ │   │ └── isarray@1.0.0 
│ │ │ │   │ │   ├── randomatic@1.1.6 
│ │ │ │   │ │   └── repeat-string@1.6.1 
│ │ │ │   │ ├── preserve@0.2.0 
│ │ │ │   │ └── repeat-element@1.1.2 
│ │ │ │   ├─┬ expand-brackets@0.1.5 
│ │ │ │   │ └── is-posix-bracket@0.1.1 
│ │ │ │   ├── extglob@0.3.2 
│ │ │ │   ├── filename-regex@2.0.1 
│ │ │ │   ├─┬ kind-of@3.2.0 
│ │ │ │   │ └── is-buffer@1.1.5 
│ │ │ │   ├─┬ normalize-path@2.1.1 
│ │ │ │   │ └── remove-trailing-separator@1.0.1 
│ │ │ │   ├─┬ object.omit@2.0.1 
│ │ │ │   │ ├─┬ for-own@0.1.5 
│ │ │ │   │ │ └── for-in@1.0.2 
│ │ │ │   │ └── is-extendable@0.1.1 
│ │ │ │   ├─┬ parse-glob@3.0.4 
│ │ │ │   │ ├── glob-base@0.3.0 
│ │ │ │   │ └── is-dotfile@1.0.2 
│ │ │ │   └─┬ regex-cache@0.4.3 
│ │ │ │     ├── is-equal-shallow@0.1.3 
│ │ │ │     └── is-primitive@2.0.0 
│ │ │ ├── async-each@1.0.1 
│ │ │ ├── glob-parent@2.0.0 
│ │ │ ├── inherits@2.0.3 
│ │ │ ├─┬ is-binary-path@1.0.1 
│ │ │ │ └── binary-extensions@1.8.0 
│ │ │ ├─┬ is-glob@2.0.1 
│ │ │ │ └── is-extglob@1.0.0 
│ │ │ ├── path-is-absolute@1.0.1 
│ │ │ └─┬ readdirp@2.1.0 
│ │ │   ├─┬ readable-stream@2.2.9 
│ │ │   │ ├── buffer-shims@1.0.0 
│ │ │   │ ├── isarray@1.0.0 
│ │ │   │ ├── process-nextick-args@1.0.7 
│ │ │   │ ├── string_decoder@1.0.0 
│ │ │   │ └── util-deprecate@1.0.2 
│ │ │   └── set-immediate-shim@1.0.1 
│ │ └── graceful-fs@4.1.11 
│ ├─┬ hexo-i18n@0.2.1 
│ │ └── sprintf-js@1.0.3 
│ ├─┬ hexo-log@0.1.2 
│ │ └─┬ bunyan@1.8.10 
│ │   ├─┬ dtrace-provider@0.8.1 
│ │   │ └── nan@2.6.2 
│ │   ├─┬ mv@2.1.1 
│ │   │ ├── ncp@2.0.0 
│ │   │ └─┬ rimraf@2.4.5 
│ │   │   └── glob@6.0.4 
│ │   └── safe-json-stringify@1.0.4 
│ ├─┬ hexo-util@0.6.0 
│ │ ├─┬ camel-case@3.0.0 
│ │ │ ├─┬ no-case@2.3.1 
│ │ │ │ └── lower-case@1.1.4 
│ │ │ └── upper-case@1.1.3 
│ │ ├─┬ cross-spawn@4.0.2 
│ │ │ ├─┬ lru-cache@4.0.2 
│ │ │ │ ├── pseudomap@1.0.2 
│ │ │ │ └── yallist@2.1.2 
│ │ │ └─┬ which@1.2.14 
│ │ │   └── isexe@2.0.0 
│ │ ├── highlight.js@9.11.0 
│ │ ├── html-entities@1.2.1 
│ │ └── striptags@2.2.1 
│ ├─┬ js-yaml@3.8.3 
│ │ ├── argparse@1.0.9 
│ │ └── esprima@3.1.3 
│ ├── lodash@4.17.4 
│ ├─┬ minimatch@3.0.3 
│ │ └─┬ brace-expansion@1.1.7 
│ │   ├── balanced-match@0.4.2 
│ │   └── concat-map@0.0.1 
│ ├── moment@2.13.0 
│ ├── moment-timezone@0.5.13 
│ ├─┬ nunjucks@2.5.2 
│ │ ├── asap@2.0.5 
│ │ └─┬ yargs@3.32.0 
│ │   ├── camelcase@2.1.1 
│ │   ├─┬ cliui@3.2.0 
│ │   │ └── wrap-ansi@2.1.0 
│ │   ├── decamelize@1.2.0 
│ │   ├─┬ os-locale@1.4.0 
│ │   │ └─┬ lcid@1.0.0 
│ │   │   └── invert-kv@1.0.0 
│ │   ├─┬ string-width@1.0.2 
│ │   │ ├── code-point-at@1.1.0 
│ │   │ └─┬ is-fullwidth-code-point@1.0.0 
│ │   │   └── number-is-nan@1.0.1 
│ │   ├── window-size@0.1.4 
│ │   └── y18n@3.2.1 
│ ├── pretty-hrtime@1.0.3 
│ ├─┬ strip-indent@1.0.1 
│ │ └── get-stdin@4.0.1 
│ ├─┬ swig@1.4.2 
│ │ ├─┬ optimist@0.6.1 
│ │ │ ├── minimist@0.0.10 
│ │ │ └── wordwrap@0.0.3 
│ │ └─┬ uglify-js@2.4.24 
│ │   ├── async@0.2.10 
│ │   ├── source-map@0.1.34 
│ │   ├── uglify-to-browserify@1.0.2 
│ │   └─┬ yargs@3.5.4 
│ │     ├── camelcase@1.2.1 
│ │     ├── window-size@0.1.0 
│ │     └── wordwrap@0.0.2 
│ ├─┬ swig-extras@0.0.1 
│ │ └─┬ markdown@0.5.0 
│ │   └── nopt@2.1.2 
│ ├── text-table@0.2.0 
│ ├─┬ tildify@1.2.0 
│ │ └── os-homedir@1.0.2 
│ ├── titlecase@1.1.2 
│ └─┬ warehouse@2.2.0 
│   ├─┬ cuid@1.3.8 
│   │ ├── browser-fingerprint@0.0.1 
│   │ ├── core-js@1.2.7 
│   │ └── node-fingerprint@0.0.2 
│   ├─┬ is-plain-object@2.0.1 
│   │ └── isobject@1.0.2 
│   └─┬ JSONStream@1.3.1 
│     ├── jsonparse@1.3.0 
│     └── through@2.3.8 
├─┬ hexo-generator-archive@0.1.4 
│ ├─┬ hexo-pagination@0.0.2 
│ │ └── utils-merge@1.0.0 
│ └── object-assign@2.1.1 
├─┬ hexo-generator-category@0.1.3 
│ └── object-assign@2.1.1 
├─┬ hexo-generator-index@0.2.1 
│ └── object-assign@4.1.1 
├── hexo-generator-tag@0.2.0 
├─┬ hexo-renderer-ejs@0.2.0 
│ └── ejs@1.0.0 
├─┬ hexo-renderer-marked@0.2.11 
│ └── marked@0.3.6 
├─┬ hexo-renderer-stylus@0.3.3 
│ ├── nib@1.1.2 
│ └─┬ stylus@0.54.5 
│   ├── css-parse@1.7.0 
│   ├─┬ debug@2.6.6 
│   │ └── ms@0.7.3 
│   ├─┬ glob@7.0.6 
│   │ ├── fs.realpath@1.0.0 
│   │ ├─┬ inflight@1.0.6 
│   │ │ └── wrappy@1.0.2 
│   │ └── once@1.4.0 
│   ├─┬ mkdirp@0.5.1 
│   │ └── minimist@0.0.8 
│   ├── sax@0.5.8 
│   └─┬ source-map@0.1.43 
│     └── amdefine@1.0.1 
└─┬ hexo-server@0.2.0 
  ├─┬ compression@1.6.2 
  │ ├─┬ accepts@1.3.3 
  │ │ ├── mime-types@2.1.15 
  │ │ └── negotiator@0.6.1 
  │ ├── bytes@2.3.0 
  │ ├─┬ compressible@2.0.10 
  │ │ └── mime-db@1.27.0 
  │ ├─┬ debug@2.2.0 
  │ │ └── ms@0.7.1 
  │ ├── on-headers@1.0.1 
  │ └── vary@1.1.1 
  ├─┬ connect@3.6.1 
  │ ├─┬ debug@2.6.3 
  │ │ └── ms@0.7.2 
  │ ├─┬ finalhandler@1.0.1 
  │ │ ├─┬ debug@2.6.3 
  │ │ │ └── ms@0.7.2 
  │ │ ├── statuses@1.3.1 
  │ │ └── unpipe@1.0.0 
  │ └── parseurl@1.3.1 
  ├── mime@1.3.4 
  ├─┬ morgan@1.8.1 
  │ ├── basic-auth@1.1.0 
  │ ├─┬ debug@2.6.1 
  │ │ └── ms@0.7.2 
  │ ├── depd@1.1.0 
  │ └─┬ on-finished@2.3.0 
  │   └── ee-first@1.1.1 
  ├─┬ opn@4.0.2 
  │ └─┬ pinkie-promise@2.0.1 
  │   └── pinkie@2.0.4 
  └─┬ serve-static@1.12.2 
    ├── encodeurl@1.0.1 
    ├── escape-html@1.0.3 
    └─┬ send@0.15.2 
      ├─┬ debug@2.6.4 
      │ └── ms@0.7.3 
      ├── destroy@1.0.4 
      ├── etag@1.8.0 
      ├── fresh@0.5.0 
      ├─┬ http-errors@1.6.1 
      │ └── setprototypeof@1.0.3 
      ├── ms@1.0.0 
      └── range-parser@1.2.0 

npm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@^1.0.0 (node_modules/chokidar/node_modules/fsevents):
npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@1.1.1: wanted {&quot;os&quot;:&quot;darwin&quot;,&quot;arch&quot;:&quot;any&quot;} (current: {&quot;os&quot;:&quot;linux&quot;,&quot;arch&quot;:&quot;x64&quot;})
INFO  Start blogging with Hexo!
cg@cg-ThinkPad-Edge-E540 ~/Work/HexoWork/blog $ 
</code></pre><p>这样,就完成了hexo本地环境的搭建,也在创建了本地博客，之后就可以在source目录下写文章了</p>
<h4 id="发布博客"><a href="#发布博客" class="headerlink" title="发布博客"></a>发布博客</h4><p>文章写完后,在本地博客跟目录下运行命令<br><code>hexo serve</code><br>后,就可以在浏览器中访问本地博客,地址为<br><code>http://localhost:4000/</code><br>之后,运行命令<br><code>hexo generate</code><br>来生成html页面,存放到根目录的public文件夹内<br>再运行<br><code>hexo deploy</code><br>命令,就可以将博客push到github中,需要注意的是,这里推送到github的只是public文件夹里的文件,其他的文件不会推送到github仓库中,还有,单纯的使用deploy命令来将内容推送到github仓库中时,自己并不能设置更性日志,她所设置的日志只是一些更性时间。而在之前使用的jekyll创建博客时,是单纯的使用git命令来推送文章,里面每推送一次,都需要设置描述性的日志<br>即命令<br><code>git commit -m &quot;xxxxx&quot;</code><br>而这里的<br><code>hexo deploy</code><br>则不是这样,她属于包装了git命令,使得推送更新变得更为简单,这点倒让我觉得不太好</p>
]]></content>
      
        <categories>
            
            <category> hexo </category>
            
        </categories>
        
        
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[下课了,以后都没课了]]></title>
      <url>/2017/03/23/daily/2017-3-23-daily-classLast/</url>
      <content type="html"><![CDATA[<p>今天上午最后一节课</p>
<p>这学期的最后一节课</p>
<p>学生生涯最后一节课</p>
<p>以后再也不是学生了</p>
<p>即将毕业的时间段内,越来越知道自己的责任了.</p>
<a id="more"></a>
<p>因为总有一天,我也会上有老下有小,或许就这几年左右</p>
<p>我得担当起家里的重担,在父母老去之前,或者说追上父母老去的速度</p>
<p>我必须给父母一个安稳的生活</p>
<p>想起以前电影里的一句话</p>
<p>男人一辈子要守住四样东西:脚下的土地,家中的父母,怀里的女人,身边的兄弟</p>
<p>所以理想中来说,我只会在此之后结婚生子</p>
<p>我想这应该是每一个男人所奋斗的目标</p>
<p>这也是我所努力的方向,提升自己的能力,强大自己</p>
<p>,,,</p>
<p>毕业了</p>
<p>我想</p>
<p>那也不远了</p>
<p><img src="/images/daily/daily-classLast.jpg" alt="daily-classLast"></p>
]]></content>
      
        <categories>
            
            <category> daily </category>
            
        </categories>
        
        
        <tags>
            
            <tag> daily </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java笔试]]></title>
      <url>/2017/03/16/java/2017-3-16-java-Writtenexamination/</url>
      <content type="html"><![CDATA[<p>昨天邮件收到一份笔试题目,全英文.<br>答题时间是一个小时,本来信心满满,但自己翻译弄懂题目就花了半个多小时,哎 英语是硬伤.</p>
<h3 id="ok-上题目"><a href="#ok-上题目" class="headerlink" title="ok,上题目:"></a>ok,上题目:</h3><p>题目（共两题，考核基础代码能力而不是算法好坏）：</p>
<p>Problem Statement # 1</p>
<p>Given a set of N (&gt; 1) positive integers, you are supposed to partition them into two disjoint sets A1 and A2 of n1 and n2 numbers, respectively. Let S1 and S2 denote the sums of all the numbers in A1 and A2, respectively. You are supposed to make the partition so that |n1 - n2| is minimized first, and then |S1 - S2| is maximized.</p>
<a id="more"></a>
<p>Input Specification:<br>Each input file contains one test case. For each case, the first line gives an integer N (2 &lt;= N &lt;= 10^5), and then N positive integers follow in the next line, separated by spaces. It is guaranteed that all the integers and their sum are less than 2^31.</p>
<p>Output Specification:<br>For each case, print in a line two numbers: |n1 - n2| and |S1 - S2|, separated by exactly one space.</p>
<p>Sample Input 1:</p>
<p>10</p>
<p>23 8 10 99 46 2333 46 1 666 555</p>
<p>Sample Output 1:</p>
<p>0 3611</p>
<p>Sample Input 2:</p>
<p>13</p>
<p>110 79 218 69 3721 100 29 135 2 6 13 5188 85</p>
<p>Sample Output 2:</p>
<p>1 9359</p>
<hr>
<p>Problem Statement # 2</p>
<p>You are to write a program that takes a list of strings containing integers and words and returns a sorted version of the list.</p>
<p>The goal is to sort this list in such a way that all words are in alphabetical order and all integers are in numerical order. Furthermore, if the nth element in the list is an integer it must remain an integer, and if it is a word it must remain a word.</p>
<p>Input Specification:<br>The input will contain a single, possibly empty, line containing a space-separated list of strings to be sorted. Words will not contain spaces, will contain only the lower-case letters a-z. Integers will be in the range -999999 to 999999, inclusive. The line will be at most 1000 characters long.</p>
<p>Output Specification:<br>The program must output the list of strings, sorted per the requirements above. Strings must be separated by a single space, with no leading space at the beginning of the line or trailing space at the end of the line.</p>
<p>Sample Input 1:</p>
<p>1</p>
<p>Sample Output 1:</p>
<p>1</p>
<p>Sample Input 2:</p>
<p>car truck bus</p>
<p>Sample Output 2:</p>
<p>bus car truck</p>
<p>Sample Input 3:</p>
<p>8 4 6 1 -2 9 5</p>
<p>Sample Output 3:</p>
<p>-2 1 4 5 6 8 9</p>
<p>Sample Input 4:</p>
<p>car truck 8 4 bus 6 1</p>
<p>Sample Output 4:</p>
<p>bus car 1 4 truck 6 8</p>
<h3 id="解答第一题"><a href="#解答第一题" class="headerlink" title="解答第一题"></a>解答第一题</h3><h4 id="简述题意"><a href="#简述题意" class="headerlink" title="简述题意:"></a>简述题意:</h4><p>设定一组正整数,个数为N(N &gt; 1,2 &lt;= N &lt;= 10^5),将这组正整数分成两份,个数分别为N1,N2.再两个集合是A1,A2来存放,之后再获取A1,A2中的总和,赋值为S1,S2.要求当|N1-N2|最小时,|S1-S2|最大,并输出.所有的数字和结果小于2^31</p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路:"></a>解题思路:</h4><p>个数差最小只有两种情况,0和1.当N为偶数时,个数差为0,但N为奇数是,个数差为1.将一开始存放数据的集合进行排序,若按从大到小的方式,当N为偶数时,N1为N/2,当N为奇数时,N1为(N/2 + 1).分好后计算总和差即可</p>
<h4 id="答案代码"><a href="#答案代码" class="headerlink" title="答案代码:"></a>答案代码:</h4><pre><code>package com.cgtest.demo;

import java.util.Scanner;
import java.util.Vector;

/**
 * @author cg
 *思路:个数差最小为0或1,按大小排序分个数后总和相减
 *偶数为0,平分个数
 *奇数为1,多取一位
 *
 */
public class TestDemo1 {
    public static void main(String [] args){
        Hint hint = new Hint();
        int n = hint.showHint();
        hint.getValue(hint.sortVector(hint.getAllValue(n)));
    }
}

class Hint{
    Scanner scanner = new Scanner(System.in);

    public int showHint(){
        int n = -1;
        System.out.println(&quot;输入正整数的个数:&quot;);
        n = scanner.nextInt();
        return n; 
    }

    public Vector&lt;Integer&gt; getAllValue(int n){
        Vector&lt;Integer&gt; vector = new Vector&lt;Integer&gt;();

        for(int i = 0; i &lt; n; i++){

            System.out.println(&quot;请输入第&quot; + (i + 1) + &quot;个数&quot;);
            int x = scanner.nextInt();
            vector.add(i, x);

        }

        for(int i = 0; i &lt; vector.size(); i++){
            System.out.print(vector.get(i) + &quot;----&quot;);
        }

        scanner.close();

        return vector;
    }

    public Vector&lt;Integer&gt; sortVector(Vector&lt;Integer&gt; vector){

        for(int i = 0; i &lt; vector.size(); i++){
            for(int j = 0; j &lt; vector.size() - 1; j++){

                if((int)vector.get(j) &lt; (int)vector.get(j + 1)){

                    int temp = (int)vector.get(j);
                    vector.set(j, vector.get(j+1));
                    vector.set(j+1, temp);
                }
            }
        }
        return vector;

    }

    public void getValue(Vector&lt;Integer&gt; vector){
        Vector&lt;Integer&gt; vector1 = new Vector&lt;Integer&gt;();
        Vector&lt;Integer&gt; vector2 = new Vector&lt;Integer&gt;();

        if(vector.size() % 2 == 0){
            System.out.println(&quot;个数差为0&quot;);
            oddSize(vector, vector1, vector2);
        }else{
            System.out.println(&quot;个数差为1&quot;);
            evenSize(vector, vector1, vector2);
        }

    }
    public void oddSize(Vector&lt;Integer&gt; vector,Vector&lt;Integer&gt; vector1,Vector&lt;Integer&gt; vector2){

        int n1 = 0,n2 = 0;

        for(int i = 0; i &lt; vector.size() / 2; i++){
            vector1.add(i, vector.get(i));
        }
        for(int i = vector.size() / 2 ,j = 0; i &lt; vector.size(); i++,j++){
            vector2.add(j, vector.get(i));
        }

        for (Integer integer : vector1) {
            n1 += integer;
        }
        System.out.println(&quot;n1=&quot; + n1);

        for (Integer integer : vector2) {
            n2 += integer;
        }

        System.out.println(n1 - n2);

    }
    public void evenSize(Vector&lt;Integer&gt; vector,Vector&lt;Integer&gt; vector1,Vector&lt;Integer&gt; vector2){

        int n1 = 0,n2 = 0;

        for(int i = 0; i &lt; (vector.size() + 1) / 2; i++){
            vector1.add(i, vector.get(i));
        }
        for(int i = (vector.size() + 1) / 2 ,j = 0; i &lt; vector.size(); i++,j++){
            vector2.add(j, vector.get(i));
        }

        for (Integer integer : vector1) {
            n1 += integer;
        }

        for (Integer integer : vector2) {
            n2 += integer;
        }

        System.out.println(n1 - n2);
    }

}
</code></pre><h3 id="第二题"><a href="#第二题" class="headerlink" title="第二题:"></a>第二题:</h3><h4 id="简述题意-1"><a href="#简述题意-1" class="headerlink" title="简述题意:"></a>简述题意:</h4><p>写一个小程序,实现输入一段字符串(包括数字和字符)后,按规则排序后输出<br>其规则是</p>
<ul>
<li>数字与数字之间排序,单个字符串和字符串之间排序,</li>
<li>原本放数字的位置就放数字,原本放字符串的位置还是放字符串.</li>
<li>数字按大小排序,字符串依据首字母按26个字母表排序</li>
</ul>
<h4 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路:"></a>解题思路:</h4><p>首先用一个集合存放整个字符串,实现单个字符串里的字符不分离.再将该集合中的单个字符串元素和数字元素分离,并获取在原集合存放的排列位置(下标 + 1)分别存放到两个二维集合中(类似键值对的方式),再操作这两个集合,实现排序,然后将排序后的两个二维集合整合,再排序,此时的排序则是按照存放集合中的原集合存放的排列位置排序,并输出,就可以了</p>
<h4 id="答案代码-1"><a href="#答案代码-1" class="headerlink" title="答案代码:"></a>答案代码:</h4><pre><code>package com.cgtest.demo2;

import java.util.ArrayList;
import java.util.Scanner;
import java.util.Vector;
import java.util.regex.Pattern;

/**
 * @author cg
 *思路:将输入的内容区分数字和字符串后分别存放到二维集合中,元素内容格式:\[原集合的位数(下标+1), value\],将其看做整体
 *并在这两个集合元素中的value按规则排序
 *排序完成后重新整合,并按位数排序
 */
public class TestDemo2 {
    public static void main(String [] args){
        Hint hint = new Hint();
        Vector&lt;String&gt; vector = hint.getInputStr();
        Vector&lt;Vector&lt;String&gt;&gt; vectorSortStr = hint.getStringIndexAndValue(vector);
        Vector&lt;Vector&lt;Integer&gt;&gt; vectorSortInt = hint.getIntIndexAndValue(vector);
        ArrayList&lt;ArrayList&lt;String&gt;&gt; arrayList = hint.produceNewString(vectorSortStr, vectorSortInt);
        hint.showConsole(arrayList);
    }
}
class Hint{
    public Vector&lt;String&gt; getInputStr(){

        Scanner scanner = new Scanner(System.in);
        Vector&lt;String&gt; vector = new Vector&lt;String&gt;();
        StringBuffer strBuffer = new StringBuffer();
        int n = 0;

        System.out.println(&quot;请输入内容:&quot;);
        String str = scanner.nextLine();

        char [] arrayStr = str.toCharArray();

        for(int i = 0; i &lt; arrayStr.length; i++){
            String strC = String.valueOf(arrayStr[i]);
            if(strC.equals(&quot; &quot;)){
                vector.add(n, strBuffer.toString());
                strBuffer = new StringBuffer();
                n++;
            }else if(i == arrayStr.length - 1){
                strBuffer.append(strC);
                vector.add(n, strBuffer.toString());
            }else{
                strBuffer.append(strC);
            }
        }
        System.out.println(&quot;排序前:&quot;);
        for (String vectorItem : vector) {
            System.out.print(vectorItem + &quot;\t&quot;);
        }
        System.out.println();
        scanner.close();
        return vector;
    }

    public Vector&lt;Vector&lt;String&gt;&gt; getStringIndexAndValue(Vector&lt;String&gt; vector){
        /*
         *获取String类型的字符串和在原集合中的位数(下标+1)
         *并返回
         */
        Vector&lt;Vector&lt;String&gt;&gt; vectorStr = new Vector&lt;Vector&lt;String&gt;&gt;();
        Vector&lt;Vector&lt;String&gt;&gt; vectorSortStr = new Vector&lt;Vector&lt;String&gt;&gt;();

        for(int i = 0; i &lt; vector.size(); i++){
            Vector&lt;String&gt; vector1 = new Vector&lt;String&gt;();
            if(!isNum(vector.get(i))){
                vector1.add(&quot;&quot; + (i + 1));
                vector1.add(vector.get(i));
                vectorStr.add(vector1);
            }
        }

        vectorSortStr = getSortStringVector(vectorStr);

        return vectorSortStr;
    }

    public Vector&lt;Vector&lt;Integer&gt;&gt; getIntIndexAndValue(Vector&lt;String&gt; vector){
        /*
         * 获取int类型的整数和在原集合中的位数(下标+1)
         * 并返回
         */
        Vector&lt;Vector&lt;Integer&gt;&gt; vectorInt = new Vector&lt;Vector&lt;Integer&gt;&gt;();
        Vector&lt;Vector&lt;Integer&gt;&gt; vectorSortInt = new Vector&lt;Vector&lt;Integer&gt;&gt;();

        for(int i = 0; i &lt; vector.size(); i++){
            Vector&lt;Integer&gt; vector1 = new Vector&lt;Integer&gt;();
            if(isNum(vector.get(i))){
                vector1.add((i + 1));
                vector1.add(Integer.valueOf(vector.get(i)));
                vectorInt.add(vector1);
            }
        }

        vectorSortInt = getSortIntVector(vectorInt);

        return vectorSortInt;
    }

    public Vector&lt;Vector&lt;String&gt;&gt; getSortStringVector(Vector&lt;Vector&lt;String&gt;&gt; vector){
        /*
         * 将字符串安字母表(ASII)表排序
         * 并返回
         */

        String sortArray[] = new String[vector.size()];


        for(int i = 0; i &lt; vector.size(); i++){
                sortArray[i] = vector.elementAt(i).get(1);
        }
        for(int i = 0; i &lt; sortArray.length - 1; i++){
            for(int j = 0; j &lt; sortArray.length - i -1; j++){
                if(sortArray[j].toCharArray()[0] &gt; sortArray[j + 1].toCharArray()[0]){
                    String strTemp = sortArray[j];
                    sortArray[j] = sortArray[j + 1];
                    sortArray[j + 1] = strTemp;
                }
            }
        }

        for(int i = 0; i &lt; vector.size(); i++){

            vector.elementAt(i).set(1, sortArray[i]);

        }
        return vector;
    }
    public Vector&lt;Vector&lt;Integer&gt;&gt; getSortIntVector(Vector&lt;Vector&lt;Integer&gt;&gt; vector){
        /*
         * 将整数按大小排序
         * 并返回
         */

        int sortArray[] = new int[vector.size()];

        for(int i = 0; i &lt; vector.size(); i++){
            sortArray[i] = vector.elementAt(i).get(1);
        }
        for(int i = 0; i &lt; sortArray.length - 1; i++){
            for(int j = 0; j &lt; sortArray.length - i -1; j++){
                if(sortArray[j] &gt; sortArray[j + 1]){
                    int strTemp = sortArray[j];
                    sortArray[j] = sortArray[j + 1];
                    sortArray[j + 1] = strTemp;
                }
            }
        }
        for(int i = 0; i &lt; vector.size(); i++){
            vector.elementAt(i).set(1, sortArray[i]);
        }
        return vector;
    }

    public ArrayList&lt;ArrayList&lt;String&gt;&gt; produceNewString(Vector&lt;Vector&lt;String&gt;&gt; vectorStr, Vector&lt;Vector&lt;Integer&gt;&gt; vectorInt){
        /*
         * 将两个集合整合并排序,返回
         */

        ArrayList&lt;ArrayList&lt;String&gt;&gt; arrayListStr = new ArrayList&lt;ArrayList&lt;String&gt;&gt;();

        for(int i = 0; i &lt; vectorStr.size(); i++){
            ArrayList&lt;String&gt; arrayList1 = new ArrayList&lt;String&gt;();
            for(int j = 0; j &lt; vectorStr.elementAt(i).size(); j++){
                arrayList1.add(vectorStr.elementAt(i).get(j));
            }
            arrayListStr.add(arrayList1);
        }

        for(int i = 0; i &lt; vectorInt.size(); i++){
            ArrayList&lt;String&gt; arrayList1 = new ArrayList&lt;String&gt;();
            for(int j = 0; j &lt; vectorInt.elementAt(i).size(); j++){
                arrayList1.add(vectorInt.elementAt(i).get(j).toString());
            }
            arrayListStr.add(arrayList1);
        }

        for(int i = 0; i &lt; arrayListStr.size(); i++){
            for(int j = 0; j &lt; arrayListStr.get(i).size(); j++){
                for(int m = 0; m &lt; arrayListStr.size() - i - 1; m++){
                    if(Integer.parseInt(&quot;&quot; + arrayListStr.get(m).get(0)) &gt; Integer.parseInt(&quot;&quot; + arrayListStr.get(m + 1).get(0))){
                        ArrayList&lt;String&gt; temp = arrayListStr.get(m);
                        arrayListStr.set(m, arrayListStr.get(m + 1));
                        arrayListStr.set(m + 1, temp);
                    }
                }
            }
        }
        return arrayListStr;
    }

    public boolean isNum(String str) {    
        Pattern pattern = Pattern.compile(&quot;^[-\\+]?[\\d]*$&quot;);    
        return pattern.matcher(str).matches();    
      }  

    public void showConsole(ArrayList&lt;ArrayList&lt;String&gt;&gt; arrayList){
        System.out.println(&quot;排序后:&quot;);
        for (ArrayList&lt;String&gt; arraylist : arrayList) {
            System.out.print(arraylist.get(1) + &quot;\t&quot;);
        }
    }

}
</code></pre><p>在这里,提醒下自己,以后写完代码一定要测试完全!!多测试没错,而我,就是没测试完全,就将我的代码发给了hr,不仅没按规定时间完成,还发了个错误的代码,,,,,,能过才<br>而我的出错的地方就是没实现对负数的处理,要是输入的字符串中包含负数,<br><code>isNum(String str)</code><br>就不能识别负数,会将负数判定为字符串,,,,,<br>原先的</p>
<p><code>isNum(String str)</code></p>
<p>的代码如下:</p>
<pre><code>public boolean isNum(String str){
    /*
    * 不能判断负数,,,,,,
    */
 for (int i = str.length();--i&gt;=0;){    
   if (!Character.isDigit(str.charAt(i))){  
    return false;  
       }  
  }  
 return true;  
}
</code></pre><p>我的答案代码太过臃肿,我也完全没想到笔试题是关于算法的,我应聘的是java实习生啊,又不是C/C++语言,不过想想hr肯定是有他的目的的<br>代码太臃肿,还得多学习</p>
]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> codeing </tag>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[你正朽于喧哗,我正老于世故]]></title>
      <url>/2017/03/13/daily/2017-3-13-daily-day/</url>
      <content type="html"><![CDATA[<p>今天雨天,很冷</p>
<p>中午11点才醒,不想吃饭,一直耗到近14点才起床</p>
<p>昨天晚上凌晨2点多睡的,脑子里也不知道瞎装了些啥.</p>
<p>一天就这样浑浑噩噩的过去了,说是混吃等死这一点都没错.</p>
<p>现在都大三了,感觉自己还是很轻浮,现在的自己一点目标都没有.</p>
<a id="more"></a>
<p>这两个星期大部分都在找实习工作,面试了几家都无果,投出去的简历一点音讯都没有,有也肯定是培训公司,好累.</p>
<p>最近一些很好的哥们也都是在忙着找工作的事,打个电话都是诉说着不知道去做什么</p>
<p>唉,不知道去干什么</p>
<p>不过昨天有件挺开心的事就是女朋友给我寄的艾米果到了,这是在三年来在武汉第一次吃艾米果</p>
<p>看着艾米果,心里很感动.</p>
<p>很开心能有这么好的女朋友</p>
<p>不过转念想到自己工作都还没找到,一下子就又回到了低谷</p>
<p>………</p>
<p>明天雨天,也很冷</p>
<p><img src="/images/daily/daily-day.jpg" alt="daily-aimiguo"></p>
]]></content>
      
        <categories>
            
            <category> daily </category>
            
        </categories>
        
        
        <tags>
            
            <tag> daily </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python加密文本内容]]></title>
      <url>/2017/03/10/python/2017-3-10-python-encryptionText/</url>
      <content type="html"><![CDATA[<p>使用python来加密文本内容,这是我之前在图书馆偶然间看到了一本python加密算法的书,看到了就想了解下</p>
<p>现在做的只是整理重温,代码是以前的,笔记也是以前的,现在只不过是想放到博客里方便以后看</p>
<p>这里就直接写明我所在书上看到的简单的加密算法,<br>有三种:</p>
<ul>
<li>反转加密法:</li>
<li>凯撒加密法:</li>
<li>换位加密法:</li>
</ul>
<p>这三种都特别简单,只适合用来随便玩玩.<br>我想如果要是以后还记得的话,可以抽出时间来多深入的了解下关于这反面的知识.</p>
<a id="more"></a>
<p>ok,进入正题</p>
<h3 id="反转加密法"><a href="#反转加密法" class="headerlink" title="反转加密法"></a>反转加密法</h3><h4 id="描述"><a href="#描述" class="headerlink" title="描述:"></a>描述:</h4><p>就是通过反向输出文本进行加密,就这样.这是最简单的加密方法</p>
<h4 id="加密方法"><a href="#加密方法" class="headerlink" title="加密方法:"></a>加密方法:</h4><pre><code>encryptionStr = &apos;&apos;
i = len(message) - 1
while i &gt;= 0:
    encryption += message[i]
    i -= 1
return encryptionStr
</code></pre><p>就这几行代码,将原文本反向输出,即完成了最简单的加密</p>
<h4 id="解密方法"><a href="#解密方法" class="headerlink" title="解密方法:"></a>解密方法:</h4><p>解密方法:再运行一次即可解密</p>
<p>就是这么简单直接,,,,</p>
<h3 id="凯撒加密法"><a href="#凯撒加密法" class="headerlink" title="凯撒加密法"></a>凯撒加密法</h3><h4 id="描述-1"><a href="#描述-1" class="headerlink" title="描述:"></a>描述:</h4><p>通过数字秘钥匹配到字母表中,通过下标加上或减去秘钥得到新数字,以新数字为下标获取字符,用来替换原来的字符</p>
<h4 id="加密方法-1"><a href="#加密方法-1" class="headerlink" title="加密方法:"></a>加密方法:</h4><pre><code>letters = &apos;ABCDEFGHIJKLMNOPQRSTUVWXYZ&apos;
encryptionStr = &apos;&apos;
key = 
message = message.upper()    
for element in message:
    if element in letters:
        num = letters.find(element)
        num += key
        if num &gt;= len(letters):
            num -= len(letters)
        elif num &lt; 0:
            num += len(letters)
        encryptionStr += letters[num]
    else:
        encryptionStr += element
return encryptionStr
</code></pre><p>这个就是根据一个数字,以这个数字作为秘钥,然后从文本中通过下标的只来跟秘钥做运算,得到的新的数字就为被代替成新字符</p>
<h4 id="解密方法-1"><a href="#解密方法-1" class="headerlink" title="解密方法:"></a>解密方法:</h4><p>将代码:</p>
<p><code>num += key</code></p>
<p>改成:</p>
<p><code>num -= key</code></p>
<h3 id="换位加密法"><a href="#换位加密法" class="headerlink" title="换位加密法:"></a>换位加密法:</h3><h4 id="描述-2"><a href="#描述-2" class="headerlink" title="描述:"></a>描述:</h4><p>通过数字秘钥更换文本内容中字符的顺序,得到新的排序</p>
<h4 id="加密方法-2"><a href="#加密方法-2" class="headerlink" title="加密方法:"></a>加密方法:</h4><pre><code>key = 
encryptionStr = [&apos;&apos;] * key
for colNum in range(key):
    pointer = colNum
    while pointer &lt; len(strMessage):
        encryptionStr[colNum] += strMessage[pointer]
        pointer += key
return &apos;&apos;.join(encryptionStr)
</code></pre><p>这个比前两个稍微复杂一点,需要借助表格来填字符.</p>
<p>以画一个表格,key列,其行数就是需要能容纳下全部字符即可.加密过程就是将文本的内容按行(从第一行起,从左往右)依次填如表格,填完后,就按列读取,第一列从上往下读取,读完后再读第二列,,,,,依次读取下去,最后得到的就是密文</p>
<p>这个密文的加密程度稍微比前两个加密算法好点,但这跟秘钥值的关系较大</p>
<h4 id="解密方法-2"><a href="#解密方法-2" class="headerlink" title="解密方法:"></a>解密方法:</h4><pre><code>colNum = math.ceil(len(message) / key)
rowNum = key
shadeBoxNum = (colNum * rowNum) - len(message)
decryptionStr = [&apos;&apos;] * colNum
pointerCol = 0
pointerRow = 0
for element in message:
    decryptionStr[pointerCol] += element
    pointerCol += 1
    if(pointerCol == colNum) or ((pointer == colNum - 1) and (pointerRow &gt;= rowNum - shadeBoxNum)):
        pointerCol = 0
        pointerRow += 1
return &apos;&apos;.join(decryptionStr)
</code></pre><p>解密就是跟加密反着来就是了,前面一样关键就是后面的读取方式,这时候就按照加密的填法读取了</p>
<h3 id="实践"><a href="#实践" class="headerlink" title="实践:"></a>实践:</h3><p>我自己也实践了第三种算法.读取原文本文件后,执行加密算法后输出保存加密后的加密文件,</p>
<p>同样也有解密程序将加密文件解密后输出保存</p>
<ul>
<li>加密文件: hwEncryptionFile.py</li>
<li>解密文件: hwDecryptionFile.py</li>
<li>原文件:ShowFile.java</li>
</ul>
<p>这三个文件都存放在同一目录下</p>
<h4 id="hwEncryptionFile-py"><a href="#hwEncryptionFile-py" class="headerlink" title="hwEncryptionFile.py"></a>hwEncryptionFile.py</h4><pre><code>import time
import os
import sys

def main():

    print(&quot;使用换位算法加密同目录下的ShowFile.java文件&quot;)
    inputFileName = &apos;ShowFile.java&apos;
    outputFileName = &apos;ShowFile-encrypted.java&apos;
    key = 8

    if not os.path.exists(inputFileName):
    print(&quot;%s 不存在&quot; %(inputFileName))
    sys.exit()

    if os.path.exists(outputFileName):
    print(&quot;This will overwrite the file %s.(c)Continue or (q)Quit ?&quot; %(outputFileName))
    choiceStr = input(&apos;&gt; &apos;)
    if not choiceStr.lower().startswith(&apos;c&apos;):
        sys.exit()

    #读取文件内容,并将&apos;\n&apos;替换成&apos;|&apos;        
    fileContent = readFile(inputFileName)

    firstStartTime = time.time()

    #将内容加密
    encryptionFileContent = encryptionStr(key,fileContent)

    encryptionTime = round((time.time() - firstStartTime), 4) 

    #将加密后的内容写入到新的文件中
    writeFile(outputFileName,encryptionFileContent)

    totalTime = round((time.time() - firstStartTime), 4)
    print(&quot;Done encryption %s (%s characters)&quot; %(inputFileName,len(encryptionFileContent)))
    print(&quot;encrypted file is %s&quot; %outputFileName)
    print(&quot;enctyption time: %s seconds&quot; %encryptionTime)
    print(&quot;TotalTime %s seconds&quot; %totalTime)

def readFile(inputFileName):

    #读取文件内容,先将换行符替换成&apos;|&apos;,再全部返回

    fileContent = &quot;&quot;
    fileObj = open(inputFileName, &apos;r&apos;)
    while True:
    line = fileObj.readline()
    if line:
        line = line.replace(&quot;\n&quot;,&quot;|&quot;)
        fileContent += line
    else:
        break
    fileObj.close()

    return fileContent

def encryptionStr(intKey,strContent):

    #intKey:换位加密算法秘钥
    #strContent:需要加密的内容(且不包含换行符)
    #加密后返回

    encryptionStrContent = [&apos;&apos;] * intKey
    for colNum in range(intKey):
    pointer = colNum
    while pointer &lt; len(strContent):
        encryptionStrContent[colNum] += strContent[pointer]
        pointer += intKey

    return &apos;&apos;.join(encryptionStrContent)

def writeFile(outputFileName,fileContent):
    fileObj = open(outputFileName,&apos;w&apos;)
    fileObj.write(fileContent)
    fileObj.close()


if __name__ == &apos;__main__&apos;:
    main()
</code></pre><h4 id="hwDecryptionFile-py"><a href="#hwDecryptionFile-py" class="headerlink" title="hwDecryptionFile.py"></a>hwDecryptionFile.py</h4><pre><code>import time
import os
import sys
import math

def main():

    print(&quot;解密同目录下被encryptionFile.py加密的ShowFile-enctypted.txt文件&quot;)
    inputFileName = &apos;ShowFile-encrypted.java&apos;
    outputFileName = &apos;ShowFile-decrypted.java&apos;
    key = 8

    if not os.path.exists(inputFileName):
    print(&quot;%s 不存在&quot; %(inputFileName))
    sys.exit()

    if os.path.exists(outputFileName):
    print(&quot;This will overwrite the file %s.(c)Continue or (q)Quit ?&quot; %(outputFileName))
    choiceStr = input(&apos;&gt; &apos;)
    if not choiceStr.lower().startswith(&apos;c&apos;):
        sys.exit()

    #读取被加密文件的内容
    fileContent = readFileContent(inputFileName)

    firstStartTime = time.time()
    #解密文件内容
    decryptionFileContent = decryptionStr(key,fileContent)

    #将解密后的内容中的&apos;|&apos;替换成&apos;\n&apos;
    normalFileContent = regetNewLineSymbol(decryptionFileContent)
    decryptionTime = round((time.time() - firstStartTime), 4)

    #将解密得到的内容写到新的文件
    writeFileContent(outputFileName,normalFileContent)
    totalTime = round((time.time() - firstStartTime), 4)

    print(&quot;Done decryption %s (%s characters)&quot; %(inputFileName,len(normalFileContent)))
    print(&quot;encrypted file is %s&quot; %outputFileName)
    print(&quot;enctyption time: %s seconds&quot; %decryptionTime)
    print(&quot;TotalTime %s seconds&quot; %totalTime)


def readFileContent(inputFileName):

    #读取文件内容并返回

    fileObj = open(inputFileName, &apos;r&apos;)
    fileContent = fileObj.read()
    fileObj.close()
    return fileContent

def writeFileContent(outputFileName,fileContent):
    fileObj = open(outputFileName,&apos;w&apos;)
    fileObj.write(fileContent)
    fileObj.close()

def decryptionStr(intKey,strContent):

    #intKey:换位加密算法秘钥-用来解密
    #strContent:需要解密的内容(且不包含换行符)
    #解密后返回

    numOfCol = math.ceil(len(strContent) / intKey)

    numOfRow = intKey

    numOfShadedBox = (numOfCol * numOfRow) - len(strContent)

    decryptionStr = [&apos;&apos;] * numOfCol

    pointerCol = 0
    pointerRow = 0

    for element in strContent:
    decryptionStr[pointerCol] += element
    pointerCol += 1

    if(pointerCol == numOfCol) or ((pointerCol == numOfCol - 1) and (pointerRow &gt;= numOfRow - numOfShadedBox)):
        pointerCol = 0
        pointerRow += 1

    return &apos;&apos;.join(decryptionStr)



def regetNewLineSymbol(strContent):

    #将含有&apos;|&apos;符号的内容还原成有&apos;\n&apos;的,并返回

    reStrContent = strContent.replace(&quot;|&quot;,&quot;\n&quot;)
    return reStrContent


if __name__ == &apos;__main__&apos;:
    main()
</code></pre><h4 id="ShowFile-java"><a href="#ShowFile-java" class="headerlink" title="ShowFile.java"></a>ShowFile.java</h4><pre><code>import java.io.File;

public class ShowFile {
    public static void main(String [] args){
        String filePath = &quot;/home/cg/Work/Testnew/Java&quot;;
        printFile(new File(filePath), 1);
    }
    public static void printFile(File fileDir,int n){
        if(fileDir.isDirectory()){
            File nextDir [] = fileDir.listFiles();
            for(int i = 0;i &lt; nextDir.length;i++){
                for(int j = 0;j &lt; n;j++){
                    System.out.print(&quot;| - - -&quot;);
                }
                System.out.println(nextDir[i].getName());
                if(nextDir[i].isDirectory()){
                    printFile(nextDir[i],n + 1);
                }
            }
        }
    }
}
</code></pre><p>这里做测试的是java代码</p>
<p>测试如图:</p>
<p><img src="/images/python/python-hwEncryption.png" alt="python-hwEncryption"></p>
]]></content>
      
        <categories>
            
            <category> python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> codeing </tag>
            
            <tag> python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JavaEE-Hibernate框架概况]]></title>
      <url>/2017/03/08/javaee/2017-3-08-javaEE-Hibernate-introduce/</url>
      <content type="html"><![CDATA[<p>复习Hibernaet框架.知识重温</p>
<h3 id="Hibernate框架简述"><a href="#Hibernate框架简述" class="headerlink" title="Hibernate框架简述"></a>Hibernate框架简述</h3><p>总得来说,它就是用来操作数据库的.在JavaEE开发方面来说,它这个框架所用在层面是数据访问层,在系统上来说算是底层的操作<br>Hibernate框架其主要是封装了JDBC的一系列操作.使用Hibernate框架可以使得系统在于数据库进行数据传递时不需要用到SQL语句,其实现的方法是实体类于数据库表之间的映射关系,也即是ORM(Object Relation Mapping)对象关系映射<br>通过ORM,使得系统在获取数据时可以直接从实体类中获取,而不需要一味的去操作数据库.ORM映射机制就相当于在实体类和数据库表中搭建了一座桥梁,数据库表中的数据通过桥梁,将数据赋值给实体类中的属性,根据面向对象系统只需要获取此时的实体类的对象就可以获取到其数据,并进行对数据的操作.反过来,数据在被系统操作之后,新的数据就被重新赋值给了实体类的属性,系统再通过Hibernate的ORM机制,将此时实体类的对象里的属性存储到数据库表中,完成数据的存储.</p>
<a id="more"></a>
<p>当中的读取和存储过程都不需要用到sql语句来对数据库表进行操作,这样使用Hibernate就简化了系统对数据库的访问操作.所以,Hibernate框架就可以简单的理解为是为使系统能简单的只从实体类中就可以获得数据的一种工具,为达到上面的目的,想想Hibernate要怎么做才能实现仅通过ORM而不是用sql语句就可以从数据库中获取数据呢<br>这就是它的奥妙之处.<br>Hibernate通过在实体类和数据库表中间建立一种映射机制,实现映射机制就需要用到映射文件,就是实体类和对应的数据库表之间的映射文件<br>参照例子代码:</p>
<ul>
<li>实体类Student</li>
<li>实体类映射配置文件Student.hbm.xml</li>
<li>Hibernate核心配置文件hibernate.cfg.xml</li>
</ul>
<h4 id="Student-java"><a href="#Student-java" class="headerlink" title="Student.java"></a>Student.java</h4><p>有一个实体类Student,代码如下:</p>
<pre><code>package com.cgtest.beans;

public class Student {

    private String stuId;
    private String stuName;
    private String stuSex;
    private int stuAge;
    private String stuAddress;
    private String stuTel;

    public String getStuId() {
        return stuId;
    }
    public void setStuId(String stuId) {
        this.stuId = stuId;
    }
    public String getStuName() {
        return stuName;
    }
    public void setStuName(String stuName) {
        this.stuName = stuName;
    }
    public String getStuSex() {
        return stuSex;
    }
    public void setStuSex(String stuSex) {
        this.stuSex = stuSex;
    }
    public int getStuAge() {
        return stuAge;
    }
    public void setStuAge(int stuAge) {
        this.stuAge = stuAge;
    }
    public String getStuAddress() {
        return stuAddress;
    }
    public void setStuAddress(String stuAddress) {
        this.stuAddress = stuAddress;
    }
    public String getStuTel() {
        return stuTel;
    }
    public void setStuTel(String stuTel) {
        this.stuTel = stuTel;
    }
}
</code></pre><p>实体类中的属性都是private的,属性就是用来临时存放相对应的数据的,这些数据就是从与实体类相对应相映射的数据库表中得来的,那么就必须会有一张表存放这个实体类对应的数据,就比如这个表中的数据都有6个字段与上面的实体类中的6个属性值相对应,那么再需要一个映射文件来将表和类连接起来<br>那么对应上面</p>
<h4 id="Student-hbm-xml"><a href="#Student-hbm-xml" class="headerlink" title="Student.hbm.xml"></a>Student.hbm.xml</h4><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;!DOCTYPE hibernate-mapping PUBLIC
    &quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot;
    &quot;http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&quot;&gt;

&lt;hibernate-mapping&gt;
    &lt;!-- 配置类和表对应
            class标签:    
                name属性值:实体类全路径
                table属性值:数据库中表的名字
     --&gt;
    &lt;class name=&quot;com.cgstudy.student.Student&quot; table=&quot;dt_t_stuMsg&quot;&gt;
        &lt;!-- 配置实体类id和表id对应 
            hibernate要求实体类有一个属性是唯一值,也就是值不能重复
            同样也要求表中的字段有唯一值
        --&gt;
        &lt;!-- id标签
            name属性值:实体类里id(唯一值)的属性名称(这里的是学号为主键,学号是唯一的)
            column属性值:生成表的字段名称,一般跟name的值一样
         --&gt;
        &lt;id name=&quot;stuId&quot; column=&quot;stuId&quot;&gt;
            &lt;!-- 设置数据库表id增长策略 
                    native:使生成的id值为主键并自动增长
            --&gt;
            &lt;generator class=&quot;assigned&quot;&gt;&lt;/generator&gt;
        &lt;/id&gt;
        &lt;!-- 配置实体类中其他属性和表中的字段相对应--&gt;
        &lt;!-- property标签
                name属性值:实体类的属性值
                column属性值:表中的字段的名字,一般跟name值一样
         --&gt;
         &lt;property name=&quot;stuName&quot; column=&quot;stuName&quot;&gt;&lt;/property&gt;
         &lt;property name=&quot;stuSex&quot; column=&quot;stuSex&quot;&gt;&lt;/property&gt;
         &lt;property name=&quot;stuAge&quot; column=&quot;stuAge&quot;&gt;&lt;/property&gt;
         &lt;property name=&quot;stuAddress&quot; column=&quot;stuAddress&quot;&gt;&lt;/property&gt;
         &lt;property name=&quot;stuTel&quot; column=&quot;stuTel&quot;&gt;&lt;/property&gt;
    &lt;/class&gt;
&lt;/hibernate-mapping&gt;
</code></pre><p>代码块中已经有了注释,就不再解释代码的意思了,总之,需要有专门的映射文件将实体类和数据库表相连接起来.另外,Hibernate会自动在数据库中创建表,只是表,不会创建数据库.其创建表的依据就是根据实体类的属性以及映射文件的相关配置来创建表.例如上面映射文件中的class标签中的table属性值为”dt_t_stuMsg”,那么在系统运行后,将会在数据库中创建一个名为dt_t_stuMsg的表,这个表就是跟Student.java这个实体类相互映射的<br>这里总结一下知识点,顺便用来承上启下</p>
<ul>
<li>实体类和表的映射文件名格式:xxx.hbm.xml(xxx一般为实体类的名字)</li>
<li>映射文件的存放位置一般在实体类所在的包下</li>
<li>Hibernate核心配置文件的命名格式为:hibernate.cfg.xml(固定的)</li>
<li>Hibernate核心配置文件存放位置在src文件夹下(固定的)</li>
<li>解压后其中的lib目录下的就是我们开发所需要的jar包，其中required是我们所必须需要的包,同样需要数据库驱动jar包</li>
</ul>
<h4 id="hibernate-cfg-xml"><a href="#hibernate-cfg-xml" class="headerlink" title="hibernate.cfg.xml"></a>hibernate.cfg.xml</h4><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;!DOCTYPE hibernate-configuration PUBLIC
    &quot;-//Hibernate/Hibernate Configuration DTD 3.0//EN&quot;
    &quot;http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd&quot;&gt;
&lt;hibernate-configuration&gt;
    &lt;session-factory&gt;
        &lt;!-- 配置数据库信息,必须要有 --&gt;
        &lt;property name=&quot;hibernate.connection.driver_class&quot;&gt;com.mysql.jdbc.Driver&lt;/property&gt;
        &lt;property name=&quot;hibernate.connection.url&quot;&gt;jdbc:mysql://localhost:3306/dt_stuMsg&lt;/property&gt;
        &lt;property name=&quot;hibernate.connection.username&quot;&gt;root&lt;/property&gt;
        &lt;property name=&quot;hibernate.connection.password&quot;&gt;0827&lt;/property&gt;

        &lt;!-- 配置Hibernate信息,可选 --&gt;
        &lt;!-- 输出底层sql语句 --&gt;
        &lt;property name=&quot;hibernate.show_sql&quot;&gt;true&lt;/property&gt;
        &lt;!-- 格式化sql语句,使语句更整洁 --&gt;
        &lt;property name=&quot;hibernate.format_sql&quot;&gt;true&lt;/property&gt;
        &lt;!-- Hibernate帮创建表,需要配置之后 
            update:如已有表,则更新,若无,则创建
        --&gt;

        &lt;property name=&quot;hibernate.hbm2ddl.auto&quot;&gt;update&lt;/property&gt;


        &lt;!-- 配置数据库方言 --&gt;
        &lt;property name=&quot;hibernate.dialect&quot;&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt;

        &lt;!-- 把映射文件放到这里核心配置文件中,必须 
            resource的属性值为相对路径
        --&gt;
        &lt;mapping resource=&quot;/com/cgstudy/student/Student.hbm.xml&quot;/&gt;

    &lt;/session-factory&gt;
&lt;/hibernate-configuration&gt;
</code></pre><h3 id="Hibernate核心配置文件的作用"><a href="#Hibernate核心配置文件的作用" class="headerlink" title="Hibernate核心配置文件的作用"></a>Hibernate核心配置文件的作用</h3><ul>
<li>连接数据库</li>
<li>加载映射文件</li>
<li>配置Hibernate</li>
</ul>
<h3 id="使用Hibernate框架用到的一些代码和对象"><a href="#使用Hibernate框架用到的一些代码和对象" class="headerlink" title="使用Hibernate框架用到的一些代码和对象"></a>使用Hibernate框架用到的一些代码和对象</h3><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre><code>Configuration configuration = null;
SessionFactory sessionFactory = null;
Session session = null;
Transcation transcation = null;
try{
    //加载核心配置文件
    configuration =  new Configuration().configure();
    //创建sessionFactory对象,并读取核心配置文件内容
    //在过程中会根据硬映射关系,在数据库中创建表
    sessionFactory = configuration.buildSessionFactory();
    //创建session对象.类似连接
    session = sessionFactory.openSession();
    //开启事务
    transaction = session.beginTransaction();
    .....
    .....//操作数据
    .....
    //事务的提交
    transaction.commit();
}catch(Exception e){
    //事务的回滚
    transaction.rollback();
}finall{
    //关闭事务
    transcation.close();
    //关闭session
    session.close();
}
</code></pre><p>其中,在创建SessionFactory对象的过程中,将会特别消耗资源</p>
<h4 id="SessionFactory类"><a href="#SessionFactory类" class="headerlink" title="SessionFactory类"></a>SessionFactory类</h4><p>这里了解下SessionFactory这个类,它是一个接口,一个SessionFactory实例对应一个数据存储源,应用从SessionFactory中获取Session实例.<br>SessionFactory特点:</p>
<ul>
<li>线程是安全的,这意味着它的同一个实例可以被应用的多个线程共享</li>
<li>它是重量级的,意味着不能随意创建或销毁它的实例</li>
<li>如果应用只访问一个数据库,则只需要创建一个SessionFactory实例,在应用初始化时创建该实例</li>
<li>如果同时访问多个数据库,则需要对每个数据库单独创建一个SessionFactory实例</li>
</ul>
<p>所以,考虑资源损耗方面,一般一个项目中就只创建一个SessionFactory对象,所以这里的解决方法是为SessionFactory专门创建一个工具类,放在系统中,给系统其他需要用到的SessionFactory使用<br>如代码:</p>
<pre><code>public class HibernateUtils{
    private static Configuration configuration = null;
    private static SessionFactory sessionFactory = null;

    static{
        configuration = new Configuration().configure();
        sessionFactory = configuration.buildSessionFactory();
    }
    public static SessionFactory getSessionFactory(){
        return sessionFactory;
    }
}
</code></pre><p>这样的话,得到的sessionFactory对象就不用关闭了</p>
<h4 id="Session类"><a href="#Session类" class="headerlink" title="Session类"></a>Session类</h4><p>其中的Session类也是一个接口<br>Session接口是Hibernate应用里使用最广泛的接口<br>Session也被称为持久化管理器,它提供了和持久化相关的操作,如添加,更新,删除,加载和查询对象<br>特点<br>不是线程安全的,因此在设计软件架构时,应该避免多个线程共享一个Session实例<br>轻量级的.它的创建和销毁不需要消耗太多的资源<br>Session类似jdbc中的connection<br>Session对象是单线程对象,不能共用<br>session操作数据常用的方法</p>
<ul>
<li>添加:save()方法</li>
<li>修改:update()方法</li>
<li>删除:delete()方法</li>
<li>根据主键查询:get()方法,load()方法</li>
</ul>
<p>在而,代码<br><code>transcation.rollback()</code><br>实现了事务的回滚,那么也就是说Hibernate类似与git命令一样,有缓存机制,即Hibernate的一级缓存.它的缓存就是把数据存放到内存中,省去了Hibernate重复读取数据库数据的步骤,但系统出现异常,可以将内存中的原始的缓存数据重新存放到数据库中,避免了数据的丢失</p>
<h3 id="Hibernate里可以实现查询的对象"><a href="#Hibernate里可以实现查询的对象" class="headerlink" title="Hibernate里可以实现查询的对象"></a>Hibernate里可以实现查询的对象</h3><h4 id="Query对象"><a href="#Query对象" class="headerlink" title="Query对象"></a>Query对象</h4><p>需要用到hql(Hibernate Query Language)语句,它跟sql相似<br>hql和sql的区别</p>
<ul>
<li>sql操作的是表和表字段</li>
<li>hql操作的是实体类和属性</li>
</ul>
<p>查询所有数据的hql语句:from 实体类名称<br>例</p>
<pre><code>Query query = session.createQuery(&quot;from Student&quot;);
List&lt;Student&gt; list = query.list();
for(Student student : list){
    System.out.println(student);
}
</code></pre><h4 id="Criteria对象"><a href="#Criteria对象" class="headerlink" title="Criteria对象"></a>Criteria对象</h4><p>其不需要用到任何语句，查询所有数据的代码</p>
<pre><code>Criteria criteria = session.createCriteria(Student.class);
List&lt;Student&gt; list = criteria.list();
for(Student student : list){
        System.out.println(student);
}
</code></pre><h4 id="SQLQuery对象"><a href="#SQLQuery对象" class="headerlink" title="SQLQuery对象"></a>SQLQuery对象</h4><p>可以使用SQL语句来操作</p>
<pre><code>SQLQuery sqlQuery = session.createSQLQuery(&quot;SELECT * FROM td_t_stuMsg&quot;);
List&lt;Object[]&gt; list = sqlQuery.list();
for(Object[] object : list){
    System.out.println(Arrays.toString(object));
}
</code></pre><p>其中，这里获取到的list集合是二维的集合,如果需要得到和上面两个Query和Criteria对象获取的Student的所有对象信息,那么<br>代码如下</p>
<pre><code>SQLQuery sqlQuery = session.createSQLQuery(&quot;SELECT * FROM td_t_stuMsg&quot;);
sqlQuery.addEntity(Student.class);
List&lt;Student&gt; list = sqlQuery.list();
for(Student student : list){
    System.out.println(student);
}
</code></pre><p>Query,Criteria,SQLQuery这三个对象,通常会使用前两个,第三个使用的比较少,Hibernate的基本内容先写到这,当然还有许多内容并未总结,例如表的关系的配置等.到后面再慢慢总结</p>
<p>谢谢</p>
]]></content>
      
        <categories>
            
            <category> javaEE </category>
            
        </categories>
        
        
        <tags>
            
            <tag> codeing </tag>
            
            <tag> javaEE </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java环境变量]]></title>
      <url>/2017/03/08/java/2017-3-08-java-EnvironmentVariable/</url>
      <content type="html"><![CDATA[<p>Java环境变量的设置.这还是大一的时候学的,现在大三了,重温一下,免得忘记</p>
<h3 id="Windows系统"><a href="#Windows系统" class="headerlink" title="Windows系统"></a>Windows系统</h3><p>在官网上下载java开发包切安装完成后，接下来就是配置环境变量了。在“我的电脑”右键后点击“属性”，在弹出的控制面板主页中点击“高级系统配置”，随即在弹出的系统属性的对话框中点击“环境变量”，之后就可以在弹出的对话框中看到有用户变量和系统变量，我们配置java环境变量就是在系统变量中进行。<br>先直接说下我们需要配置的环境变量的名称：<br>有两种：</p>
<p>第一种是一定要配置的环境变量：PATH和CLASSPATH<br>第二种就是可要可不要的环境变量：JAVA_HOME</p>
<a id="more"></a>
<h4 id="JAVA-HOME变量"><a href="#JAVA-HOME变量" class="headerlink" title="JAVA_HOME变量"></a>JAVA_HOME变量</h4><p>JAVA_HOME变量可要可不要，是因为它的作用仅仅只是作为一个中间变量，是一个用来传递的作用，为了在配置PATH和CLASSPATH变量时达到简介的效果。<br>再者，先认识下PATH变量：</p>
<p>PATH变量的设定简单的来说就是为了让系统能在不同目录下都能执行PATH的值所指引的目录下的可执行文件，类似一个全局静态变量的作用，知道这个变量的作用之后再来说下这个变量的值，因为这个变量在系统中都早已存在，所赋予的值都是为了系统执行的方便，而java的值就是这样。</p>
<p>java程序的编译和运行需要用到两个exe程序，一个是java编译器(javac.exe)和java解释器(java.exe)，它俩是组成jvm的一部分，也就是说，要想在不同目录下执行这两个exe程序来编译运行java程序，就得需要在PATH环境变量中为其指定这两个exe程序的存放路径，所以PATH环境变量就是这样来的。</p>
<h4 id="CLASSPATH变量"><a href="#CLASSPATH变量" class="headerlink" title="CLASSPATH变量"></a>CLASSPATH变量</h4><p>先不说怎么填写PATH的值，先再了解下CLASSPATH环境变量的作用。</p>
<p>CLASSPATH环境变量的在我的电脑上之前没有这个变量，估计也得都是自己添加。CLASSPATH从字面上来看(毕竟编程都讲究名字不能随便起，都需要达到看到字能够确切的想到某种东西的效果)，CLASSPATH中大概的意思就是类的路径，这也不难猜测，毕竟jdk中提供了许多类库，敲代码都少不了导入一些自带的类库，也正因为如此，如果在编译运行java程序时，该程序导入了许多类库，比如最简单的<code>import java.util.Scanner</code>;导入Scanner类，如果不指明Scanner类库的存放位置，编译就会出错，所以自然就需要一个环境变量来指定那些类库的存放目录了。<br>JAVA_HOME就是充当了一个中间传递者的角色，该变量的值就是jdk安装目录的值。</p>
<h4 id="PATH变量"><a href="#PATH变量" class="headerlink" title="PATH变量"></a>PATH变量</h4><p>现在就来说PATH变量的值，就是javac.exe和java.exe的存放路径，其两个exe程序都存放在jdk的\bin目录下。假设jdk的安装目录为:</p>
<p><code>C:\Program Files\Java\jdk1.8.0_66</code>;</p>
<p>那么PATH变量所添加的值就为:</p>
<p><code>C:\Program Files\Java\jdk1.8.0_66\bin</code></p>
<p>如果增加了JAVA_HOME变量，且其值为:</p>
<p><code>C:\Program Files\Java\jdk1.8.0_66</code></p>
<p>那么PATH变量的所添加的值就为</p>
<p><code>%JAVA_HOME%\bin</code></p>
<p>CLASSPATH的值就是指定类库的存放路径，其存放位置是在jdk的\jre\lib目录下的rt.jar包里面，所以它的值为:</p>
<p><code>C:\Program Files\Java\jdk1.8.0_66\jre\lib\rt.jar;.;</code></p>
<p>后面有“;.;”三个符号,表示可以加载该目录下的类及其子目录下的类。</p>
<p>同样如果设置了JAVA_HOME则值为:</p>
<p><code>.:%JAVA_HOME%\jre\lib\rt.jar;.;</code></p>
<p>到这里，Java的环境变量就设定好了，，</p>
<p>cmd下检测输入java -version和javac如若输出正常则环境变量就完全设定好了，<br>之后就可安装eclipse开发java程序了</p>
<p>总得来说：</p>
<pre><code>JAVA_HOME:C:\Program Files\Java\jdk1.8.0_66
PATH:后面添加:;%JAVA_HOME%\bin;
不能存在“;;”
CLASSPATH:.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar
</code></pre><h3 id="Linux-Ubuntu-系统上搭建Java环境"><a href="#Linux-Ubuntu-系统上搭建Java环境" class="headerlink" title="Linux(Ubuntu)系统上搭建Java环境"></a>Linux(Ubuntu)系统上搭建Java环境</h3><p>在官网上下载Jdk后，先在/usr/lib下新建jvm文件夹，因为后面的jdk安装在jvm里面<br>在终端进入下载目录,将下载好的jdk解压，我这里是jdk-8u66-linux-x64.tar.gz，并将其解压至/usr/lib/jvm下<br>命令：<code>sudo tar -zvxf jdk-8u66-linux-x64.tar.gz -C /usr/lib/jvm</code><br>完后就是得配置java开发环境了<br>在新打开的终端上输入命令： <code>gksu gedit /etc/profile</code>  (当然也可以是gedit ~/.bashrc，只不过.bashrc是针对先用户才管用，而/etc/profile是对全局管用)<br>在打开的文本后面加上如下</p>
<pre><code># Java-environment
export JAVA_HOME=/usr/lib/jvm/jdk1.8.0_77 
export PATH=$JAVA_HOME/bin:$PATH 
export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar 
</code></pre><p>即可保存</p>
<p>之后再运行命令:<code>source /etc/profile</code></p>
<p>在终端上输入java -version和javac显示正常即完成了java的环境配置</p>
<p><img src="/images/java/java-environmentVariable.png" alt="java-bookContorlSystem"></p>
<p>好了,谢谢</p>
<hr>
<h3 id="update"><a href="#update" class="headerlink" title="update"></a>update</h3><p>给公司centos服务器配置的java环境如下</p>
<pre><code>#Java-environment
export JAVA_HOME=/home/xm6f/dev/jdk1.7.0_80
export JRE_HOME=/home/xm6f/dev/jdk1.7.0_80/jre
export CLASS_PATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tool.jar:$JRE_HOME/lib
export PATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin
</code></pre>]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> codeing </tag>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java中Scanner类扫描文件]]></title>
      <url>/2017/02/23/java/2017-2-24-java-ScannerJiexiFile/</url>
      <content type="html"><![CDATA[<p>Java中的Scanner类除了可以用来读取扫描从键盘输入,还可以扫描文件<br>Scanner类很基本,通过读取用户从键盘输入字符来实现交互.主要是通过Scanner类中的nextLine()方法来获取输入的所有内容,也可以使用next()方法,<br>但next()方法不会获取空格,但一般使用nextLine()方法</p>
<a id="more"></a>
<p>nextInt()则是获取键盘输入的数字.Scanner同IO输入输出流一样需要关闭,所以在程序退出时,需要调用close()方法将扫描器</p>
<p>例如代码:</p>
<pre><code>package com.cgtest.scannerDemo;

import java.util.Scanner;

public class ScannerDemo {
    public static void main(String [] args){
        Scanner scanner = new Scanner(System.in);
        System.out.println(&quot;请输入内容:&quot;);
        while(true){
            String inputStr = scanner.nextLine();

            if(inputStr.equals(&quot;exit&quot;)){
                scanner.close();
                break;
            }
            System.out.println(&quot;&gt;&gt;&gt;&quot; + inputStr);
        }
    }
}
</code></pre><p>运行结果:</p>
<pre><code>请输入内容:
憨头
&gt;&gt;&gt;憨头
hey
&gt;&gt;&gt;hey
666
&gt;&gt;&gt;666
exit
</code></pre><p>可以用字符串,输入流(InputStream),文件等作为参数来创建Scanner对象.这里例子是用file用作参数来创建Scanner对象,就用创建之后的scanner对象来扫描此文件了.</p>
<p>扫描文件一般使用正则表达式来从文件中获取想要的内容</p>
<p>例如代码:</p>
<pre><code>// package com.cgstudy.s0922;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;

public class ScannerJiexi {                                      //使用正则表达式来解析文件
    public static void main(String [] args){
        File file = new File(&quot;cost.txt&quot;);
        Scanner sc = null;
        double sum = 0;
        try{
            sc = new Scanner(file);
            sc.useDelimiter(&quot;[^0123456789.]+&quot;); //useDelimiter()将正则表达式作为分隔符
            while(sc.hasNextDouble()){
                double price = sc.nextDouble();
                sum = sum+price;
                System.out.println(price);
            }
            System.out.println(&quot;总共消费了&quot;+sum+&quot;元&quot;);
        }catch(FileNotFoundException e){
            e.printStackTrace();
        }
    }
}
</code></pre><p>文件cost.txt中的内容是:</p>
<pre><code>TV cost 876 dollar,
Computer cost 2398 dollar,
The milk cost 98 dollar,
The apples cost 198 dollar.
</code></pre><p>程序的输出为:</p>
<p><img src="/images/java/java-ScannerJiexi.png" alt="java-bookContorlSystem"></p>
<p>Scanner对象能这样解析文件,更何况查看文件,它可以做到同IO中的输入流一样的作用,要达到这样的功能,只需更改一些代码即可,</p>
<p>如下代码片段:</p>
<pre><code>scanner = new Scanner(file);
while(scanner.hasNextLine()){
    System.out.println(scanner.nextLine());
}
</code></pre><p>只需要将这些的代码代替ScannerJiexi类中的try-catch中的代码块即可<br>之后程序的输出就为cost.txt的文本内容</p>
]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> codeing </tag>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java遍历显示文件]]></title>
      <url>/2017/02/20/java/2017-2-20-java-ShowFile/</url>
      <content type="html"><![CDATA[<p>用来遍历文件夹内容的后树形显示内容的一段小代码<br>如下代码:</p>
<a id="more"></a>
<pre><code>import java.io.File;

public class ShowFile {
    public static void main(String [] args){
        String filePath = &quot;/home/cg/Work/Testnew/Java&quot;;
        printFile(new File(filePath), 1);
    }
    public static void printFile(File fileDir,int n){
        if(fileDir.isDirectory()){
            File nextDir [] = fileDir.listFiles();
            for(int i = 0;i &lt; nextDir.length;i++){
                for(int j = 0;j &lt; n;j++){
                    System.out.print(&quot;| - - -&quot;);
                }
                System.out.println(nextDir[i].getName());
                if(nextDir[i].isDirectory()){
                    printFile(nextDir[i],n + 1);
                }
            }
        }
    }
}
</code></pre><p>这段代码将保存在上面的路径/home/cg/Work/Testnew/Java文件夹下,名字为ShowFile.java<br>之后在终端中编译运行,如下图:</p>
<p><img src="/images/java/java-ShowFile.png" alt="java-bookContorlSystem"></p>
]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> codeing </tag>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java编写图书馆信息管理系统]]></title>
      <url>/2017/02/20/java/2017-2-20-java-BookContorlSystem/</url>
      <content type="html"><![CDATA[<p>这里记录的是一个图书馆信息管理系统,是之前自己闲着无聊练手的,现在记录下来就是为了回想之前的知识点,重温总结</p>
<h3 id="运行效果"><a href="#运行效果" class="headerlink" title="运行效果"></a>运行效果</h3><p>这里先贴下运行效果,进行测试</p>
<p>首先打开数据库</p>
<p><img src="/images/java/java-bookControlSystem-1.png" alt="java-bookControlSystem"></p>
<p>之后运行main函数,如下:</p>
<a id="more"></a>
<h4 id="登录界面"><a href="#登录界面" class="headerlink" title="登录界面"></a>登录界面</h4><p><img src="/images/java/java-bookControlSystem-login.png" alt="java-bookControlSystem"></p>
<p>输出学号和密码后点击登录,就会在新的面板中出现此学号在图书馆的借阅信息,例如我输入学号为V201441122,登录后如下图</p>
<h4 id="操作界面"><a href="#操作界面" class="headerlink" title="操作界面"></a>操作界面</h4><p><img src="/images/java/java-bookControlSystem-ui.png" alt="java-bookControlSystem"></p>
<p>之后就可以在这个面板中进行相关的借书还书操作<br>代码实现的大致就这样,这里需要用到的开发工具是xampp软件包(Apache + MariaDB + PHP + Perl)作为服务器,当然里面也集成了MySQL数据库,主要的编码工具是Eclipse<br>知道了这些,就可以进行开发工作了<br>在进行开发工作时,需要对所做的系统进行规划,编写需求分析计划书和系统概要设计等等.由于这里我只是用来打发时间,所以没详细进行这编写,只是大概的绘制了系统界面功能图及流程图</p>
<h4 id="系统流程图"><a href="#系统流程图" class="headerlink" title="系统流程图"></a>系统流程图</h4><p>如下:</p>
<p><img src="/images/java/java-bookControlSystem-liuchengtu.png" alt="java-bookControlSystem"></p>
<h4 id="界面设计图"><a href="#界面设计图" class="headerlink" title="界面设计图"></a>界面设计图</h4><p>为编码前绘制的系统登录界面图</p>
<p><img src="/images/java/java-bookControlSystem-plan-login-ui.png" alt="java-bookControlSystem"></p>
<p>继而下图为信息面板:</p>
<p><img src="/images/java/java-bookControlSystem-plan-ms-ui.png" alt="java-bookControlSystem"></p>
<p>依据上面的流程图和ui设计图来进行编码工作</p>
<h3 id="编码操作"><a href="#编码操作" class="headerlink" title="编码操作"></a>编码操作</h3><p>这里项目所有创建了的文件:</p>
<ul>
<li>ConnectionDatabase.java-连接数据库</li>
<li>LoginWin.java-登录窗口</li>
<li>LoginAction.java-处理登录窗口上发生的事件</li>
<li>CheckAccount.java-检查验证账户的正确性及是否存在</li>
<li>MsgShowWin.java-操作界面</li>
<li>MsgShowWinAction.java-处理操作界面上发生的事件</li>
<li>OperateDatabase.java-对数据的处理,并写入到数据库中</li>
<li>MyJDialog.java-自定义的一个窗口样式</li>
<li>BookControlSystem.java-程序的入口</li>
<li>数据库的建立脚本</li>
</ul>
<p>建立需要的包和main函数后,再来创建一个文件用来连接数据库操作,例如这里为</p>
<h4 id="ConnectionDatabase-java代码如下"><a href="#ConnectionDatabase-java代码如下" class="headerlink" title="ConnectionDatabase.java代码如下:"></a>ConnectionDatabase.java代码如下:</h4><pre><code>package com.cgtest.data;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;


public class ConnectionDatabase {

    private static final String databaseDriver = &quot;com.mysql.jdbc.Driver&quot;;
    private static final String databaseUrl = &quot;jdbc:mysql://localhost:3306/bookControlSystem&quot;;
    private static final String databaseUser = &quot;root&quot;;
    private static final String databasePasswd = &quot;0827&quot;;

    public Connection conectionDatabse(){
        Connection connection = null;

        try {
            Class.forName(databaseDriver);
            connection = DriverManager.getConnection(databaseUrl, databaseUser, databasePasswd);
        } catch (ClassNotFoundException e) {
//            e.printStackTrace();
            System.out.println(&quot;未找到驱动&quot;);
        } catch (SQLException e) {
//            e.printStackTrace();
            System.out.println(&quot;e异常:未连接数据库&quot;);
//            new MyJDialog
        }
        if(connection == null){
            System.out.println(&quot;connectionDatabase:未连接数据库&quot;);
        }

        return connection;
    }
}
</code></pre><p>连接数据库需要加载驱动,所以提前在项目的根目录下建立一个lib文件夹,将数据库驱动放置文件夹内,这里的<a href="https://dev.mysql.com/downloads/connector/j/" target="_blank" rel="external">驱动下载页面</a>,下载后将解压得到的jar文件就是驱动.代码中的<code>databaseUrl</code>,<code>databaseUser</code>和<code>databasePasswd</code>是自己本地利用lampp搭建的数据库服务器地址与自己配置的用户名和登录密码,这个类ConnectionDatabase在连接数据库后会返回一条连接,也就是一个Connection对象<br>当登录窗口运行后,当用户在该面板中产生点击操作后,程序将会连接数据库,也就是调用ConnectionDatabase类,获取一条数据库连接<br>如下代码登录窗口代码,文件名为</p>
<h4 id="LoginWin-java"><a href="#LoginWin-java" class="headerlink" title="LoginWin.java"></a>LoginWin.java</h4><pre><code>package com.cgtest.ui;

import java.awt.Dimension;
import java.awt.Toolkit;

import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JPasswordField;
import javax.swing.JTextField;
import javax.swing.SwingUtilities;
import javax.swing.UIManager;
import javax.swing.UnsupportedLookAndFeelException;

import com.cgtest.action.LoginAction;

public class LoginWin extends JFrame{

    private static final long serialVersionUID = 1L;

    private final static int loginWinWidth = 380,loginWinHeight = 270;

    public JTextField inputName;
    public JPasswordField inputPasswd;
    public JButton btCancel,btLogin;

    public LoginWin(){
        SwingUtilities.invokeLater(new Runnable() {

            @Override
            public void run() {
                try {
                    UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
                } catch (ClassNotFoundException | InstantiationException | IllegalAccessException
                        | UnsupportedLookAndFeelException e) {
                    e.printStackTrace();
                }
                drawWin(&quot;华师图书馆&quot;);
            }
        });
    }
    public void drawWin(String s){

        JPanel panel = new JPanel();
//        panel.setBackground(Color.yellow);
        panel.setLayout(null);
        this.add(panel);

        JLabel labelFirst = new JLabel(&quot;系统登陆&quot;);
        panel.add(labelFirst);
        labelFirst.setBounds(180, 10, 100, 25);

        JLabel labelName = new JLabel(&quot;学  号:&quot;);
        inputName = new JTextField();
        panel.add(labelName);
        panel.add(inputName);
        labelName.setBounds(90, 60, 100, 25);
        inputName.setBounds(135, 60, 150, 25);

        JLabel labelPasswd = new JLabel(&quot;密  码:&quot;);
        inputPasswd = new JPasswordField();
        panel.add(labelPasswd);
        panel.add(inputPasswd);
        labelPasswd.setBounds(90, 120, 100, 25);
        inputPasswd.setBounds(135, 120, 150, 25);

        btCancel = new JButton(&quot;取消&quot;);
        panel.add(btCancel);
        btCancel.setBounds(135, 180, 60, 22);

        btLogin = new JButton(&quot;登录&quot;);
        panel.add(btLogin);
        btLogin.setBounds(225, 180, 60, 22);
        btLogin.setEnabled(false);

        new LoginAction(this,inputName, inputPasswd, btCancel, btLogin);

        this.setTitle(s);
        this.setSize(loginWinWidth, loginWinHeight);
//        this.setLayout(null);
        this.setResizable(false);
        Toolkit toolkit = Toolkit.getDefaultToolkit();
        Dimension  dimension = toolkit.getScreenSize();
        int screenWidth = dimension.width;
        int screenHeight = dimension.height;
        this.setLocation((screenWidth - loginWinWidth) / 2, (screenHeight - loginWinHeight) / 2);
        this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        this.validate();
        this.setVisible(true);
    }
}
</code></pre><p>上面的代码主要作用是担当登录窗口的布局设置,<br>其中代码<br><code>new LoginAction(this,inputName, inputPasswd, btCancel, btLogin);</code><br>是将使LoginWin.java和LoginAction.java连接起来,使得登录窗口中的所有响应事件都由LoginAction.java文件来处理<br>构造方法中的<br><code>SwingUtilities.invokeLater(new Runnable())</code><br>方法是用来获取系统主题样式,并将登录窗口的样式主题设置为于系统主题一样<br>方法中的参数代码:<br><code>UIManager.getSystemLookAndFeelClassName();</code><br>就是获取系统的主题样式,与之相对应的相应事件操作的代码如下,文件名为</p>
<h4 id="LoginAction-java"><a href="#LoginAction-java" class="headerlink" title="LoginAction.java:"></a>LoginAction.java:</h4><pre><code>package com.cgtest.action;

import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;

import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JPasswordField;
import javax.swing.JTextField;

import com.cgtest.data.CheckAccount;
import com.cgtest.ui.MsgShowWin;
import com.cgtest.ui.MyJDialog;

public class LoginAction implements ActionListener,MouseListener{

    public JFrame jframe;
    public JTextField inputName;
    public JPasswordField inputPasswd;
    public JButton btCancel,btLogin;

    public LoginAction(JFrame jframe,JTextField inputName,JPasswordField inputPasswd,JButton btCancel,JButton btLogin){
        btCancel.addActionListener(this);
        btLogin.addActionListener(this);
        btLogin.addMouseListener(this);
        jframe.addMouseListener(this);
        inputName.addMouseListener(this);
        inputPasswd.addMouseListener(this);
        this.jframe = jframe;
        this.inputName = inputName;
        this.inputPasswd = inputPasswd;
        this.btCancel = btCancel;
        this.btLogin = btLogin;
    }

    @Override
    public void actionPerformed(ActionEvent e) {
        String strInputName = inputName.getText(),strInputPasswd = String.valueOf(inputPasswd.getPassword());//密码不能直接toString()
        CheckAccount checkAccount = new CheckAccount();
        int checkConnect = checkAccount.checkConnectDatabase();
        if(e.getSource() == btCancel){
            new MyJDialog(true, jframe).showChoice(&quot;确定退出?&quot;);

        }else if(e.getSource() == btLogin){
            int n = checkAccount.checkNamePasswd(strInputName, strInputPasswd);
            if(checkConnect == 1){
                if(n == -1){
                    new MyJDialog(true, jframe).showMessage(&quot;无数据&quot;);
                }else if(n == -2){
                    new MyJDialog(true, jframe).showMessage(&quot;用户不存在&quot;);
                }else if(n == -3){
                    new MyJDialog(true, jframe).showMessage(&quot;密码错误,请重新输入&quot;);
                }else if(n == 1){
                    new MsgShowWin(checkAccount);
                    jframe.dispose();
                }else{
                    System.out.println(&quot;代码错误&quot;);
                }
            }else{
                new MyJDialog(true, jframe).showMessage(&quot;未连接数据库&quot;);
            }
        }
    }

    @Override
    public void mouseClicked(MouseEvent e) {

    }

    @Override
    public void mousePressed(MouseEvent e) {

    }

    @Override
    public void mouseReleased(MouseEvent e) {

    }

    @Override
    public void mouseEntered(MouseEvent e) {
        // TODO Auto-generated method stub
        if(e.getSource() == jframe){
            if(inputName.getText().length() != 0 &amp;&amp; inputPasswd.getPassword().length != 0){
                btLogin.setEnabled(true);
            }else{
                btLogin.setEnabled(false);
            }
        }
    }

    @Override
    public void mouseExited(MouseEvent e) {
        // TODO Auto-generated method stub
        if(e.getSource() == inputName || e.getSource() == inputPasswd){
            if(inputName.getText().length() != 0 &amp;&amp; inputPasswd.getPassword().length != 0){
                btLogin.setEnabled(true);
            }else{
                btLogin.setEnabled(false);
            }
        }
    }
}
</code></pre><p>上面代码中actionPerformed(ActionEvent e)方法中,代码<br><code>CheckAccount checkAccount = new CheckAccount();</code><br>将产生一个数据库连接<br>代码<br><code>int checkConnect = checkAccount.checkConnectDatabase();</code><br>中的checkConnectDatabase()方法将是用来检查数据库服务器是否开启,如果是,则进行下一步:验证用户输入的用户名是否存在.就如下代码<br>代码:<br><code>int n = checkAccount.checkNamePasswd(strInputName, strInputPasswd);</code><br>方法chexkNamePasswd(strInputName, strInputPasswd)将用户输入的用户名和密码作为参数,用来验证是否存在或正确,因此,来看对象checkAccount的如下代码,文件名为</p>
<h4 id="CheckAccount-java"><a href="#CheckAccount-java" class="headerlink" title="CheckAccount.java:"></a>CheckAccount.java:</h4><pre><code>package com.cgtest.data;

import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.Vector;


public class CheckAccount {

    public Vector&lt;Object&gt; vectorUserInputLogined = new Vector&lt;Object&gt;();

    public CheckAccount(){

    }
    public Vector&lt;Vector&lt;Object&gt;&gt; getAllNamePasswd(){
        /*
         * 获取并返回数据库中所有的用户名和密码
         */
        Vector&lt;Vector&lt;Object&gt;&gt; vectorAllNamePasswd = new Vector&lt;&gt;();
        String sqlGetNamePasswd = &quot;SELECT accountName,accountPasswd FROM accountMsg&quot;;
        Connection connection = new ConnectionDatabase().conectionDatabse();
        try {
            Statement statement = connection.createStatement();
            ResultSet resultSet = statement.executeQuery(sqlGetNamePasswd);
            while(resultSet.next()){
                Vector&lt;Object&gt; vectorOne = new Vector&lt;Object&gt;();
                for(int i = 1; i &lt;= 2; i++){
                    vectorOne.add(resultSet.getString(i));
                }
                vectorAllNamePasswd.add(vectorOne);
            }
            resultSet.close();
        } catch (SQLException e) {
            e.printStackTrace();
//            System.out.println(&quot;未连接数据库&quot;);
        }
        try {

            connection.close();
        } catch (SQLException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
        return vectorAllNamePasswd;
    }

    public int checkNamePasswd(String strInputName, String strInputPasswd){
        /*
         * 根据用户输入的用户名和密码,并以此来对比数据库中存在的用户名和密码,验证登录
         */
        int n = 0, index = 0;
        Vector&lt;Vector&lt;Object&gt;&gt; vectorAllNamePasswd = getAllNamePasswd();
        if(vectorAllNamePasswd.size() == 0){
//            new MyJDialog(true, jframe).showMessage(&quot;未连接数据库&quot;);
            n = -1;
        }else{
            for(int i = 0; i &lt; vectorAllNamePasswd.size(); i++){
                if(vectorAllNamePasswd.elementAt(i).get(0).equals(strInputName)){
                    index = i;
                    break;
                }else{
                    index = -1;
                }
            }
            if(index == -1){
//                new MyJDialog(true, jframe).showMessage(&quot;用户不存在&quot;);
                n = -2;
            }else{
                if(vectorAllNamePasswd.elementAt(index).get(1).equals(strInputPasswd)){
//                    new MsgShowWin();
                    vectorUserInputLogined.add(vectorAllNamePasswd.elementAt(index).get(0));
                    vectorUserInputLogined.add(vectorAllNamePasswd.elementAt(index).get(1));
                    /*
                     * 只有当账户密码都输入正确后(成功登录后),才将登录账户发送到vectorUserInputLogined
                     */
                    n = 1;
                }else{
//                    new MyJDialog(true, jframe).showMessage(&quot;密码错误,请重新输入&quot;);
                    n = -3;
                }
            }
        }
//        if(vectorAllNamePasswd.size() == 0){
//            System.out.println(&quot;空&quot;);
//        }else{
//            System.out.println(&quot;非空&quot; + index);
//        }
        return n;
    }

    public Vector&lt;Object&gt; transmitAccountMsg(){
        /*
         * 只有当用户成功登录后,才返回登录账户密码
         */
        Vector&lt;Object&gt; vector = new Vector&lt;Object&gt;();
//        System.out.println(vectorUserInputLogined.size());
        if(this.vectorUserInputLogined.size() != 0){
            for(int i = 0; i &lt; this.vectorUserInputLogined.size(); i++){
//                System.out.println(vectorUserInputLogined.get(i));
                vector.add(this.vectorUserInputLogined.get(i));
            }
        }else{
//            System.out.println(&quot;vectorUserInputLogined:用户未登录&quot;);
        }
        return vector;
    }


    public int checkConnectDatabase(){
        /*
         * for loginWin登录窗口
         */
        int n = 0;
        Connection connection = new ConnectionDatabase().conectionDatabse();
        if(connection != null){
            n = 1;
        }else{ 
            n = -1;
        }
        try {
            connection.close();
        } catch (SQLException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
        return n;
    }
}
</code></pre><p>看上面的代码,这里主要说方法checkNamePasswd(String strInputName, String strInputPasswd)的工作方式.首相checkNamePasswd()方法将调用自身类的一个getAllNamePasswd()无参数方法,用来获取数据库中所有已注册的用户账户名和密码,getAllNamePasswd()的返回值为<code>Vector&lt;Vector&lt;Object&gt;&gt;</code>双层的Vector集合,所以会返回一条双层的Vector集合,返回的集合将用在checkNamePasswd方法中作为局部变量,方法checkNamePasswd()将先根据用户输入的用户名来和数据库中所有存在的用户名来对比,如果为对比到,那么将返回-2,意味着用户不存在<br>方法checkNamePasswd()将会有多中int类型的返回值,其返回值将用在LoginAction类中的actionPerformed(ActionEvent e)中,将根据其返回值来判断是否存在/正确,如果返回值为1,那么证明用户输入的用户名和密码都正确,则将打开下一个信息面板,而关闭登录窗口.再将登录的账户名和密码封装进一个专有的Vector集合,并返回的Vector集合将会通过LoginAction类利用代码<code>new MsgShowWin(checkAccount);</code>来传递给MsgShowWin这个类,使得在打开这个面板的时候就可以直接通过账户名来获取借阅信息并显示在信息面板上<br>如下信息窗口代码,文件名为</p>
<h4 id="MsgShowWin-java"><a href="#MsgShowWin-java" class="headerlink" title="MsgShowWin.java:"></a>MsgShowWin.java:</h4><pre><code>package com.cgtest.ui;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Toolkit;
import java.util.Vector;

import javax.swing.BorderFactory;
import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JMenu;
import javax.swing.JMenuBar;
import javax.swing.JMenuItem;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JTable;
import javax.swing.JTextField;
import javax.swing.SwingUtilities;
import javax.swing.UIManager;
import javax.swing.UnsupportedLookAndFeelException;
import javax.swing.border.MatteBorder;
import javax.swing.table.DefaultTableCellRenderer;
import javax.swing.table.DefaultTableModel;

import com.cgtest.action.MsgShowWinAction;
import com.cgtest.data.CheckAccount;
import com.cgtest.data.OperateDatabase;

public class MsgShowWin extends JFrame{

    private static final long serialVersionUID = 1L;

    private final static int msgWinWidth = 800,msgWinHeight = 500;

    public String accountName, personName, sex, allBookNum ,strShowDBMsg;

    public JLabel jlabelAccountName, jlabelPersonName, jlabelSex, jlabelAllBookNum, jlabelShowDBMsg;
    public JPanel showPortrait;
    public JTextField jtfInputIndexBorrow,jtfShowBookBorrow,jtfInputIndexReturn,jtfShowBookReturn;
    public JButton btSearchBorrow,btConfirmBorrow,btSearchReturn,btConfirmReturn;
    public DefaultTableModel defaultTableModel;
    public JTable jtableMsg;
    public Vector&lt;Vector&lt;Object&gt;&gt; vectorJTableMsg;
    public Vector&lt;Object&gt; vectorJTableTitle;
    public JMenuBar jmenuBar;
    public JMenu jmenu;
    public JMenuItem jmenuItemLogout, jmenuItemExit;

    public int myJDialogChoice;

    public MsgShowWin(CheckAccount checkAccount){
        SwingUtilities.invokeLater(new Runnable() {

            @Override
            public void run() {
                try {
                    UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
                } catch (ClassNotFoundException | InstantiationException | IllegalAccessException
                        | UnsupportedLookAndFeelException e) {
                    // TODO Auto-generated catch block
                    e.printStackTrace();
                }
                strShowDBMsg = new OperateDatabase().checkConnectDatabase();
                setShowAccountMsg(checkAccount);
                vectorJTableMsg = new OperateDatabase().getUserBorrowMsg(checkAccount);
                int bookNum = vectorJTableMsg.size();
                allBookNum = bookNum + &quot;/10&quot;;
                drawMsgShowWin();
            }
        });
    }

    public void drawMsgShowWin(){

        jmenuBar = new JMenuBar();
        this.setJMenuBar(jmenuBar);

        jmenu = new JMenu(&quot;选项&quot;);
        jmenuBar.add(jmenu);

        jmenuItemLogout = new JMenuItem(&quot;注销&quot;);
        jmenuItemExit = new JMenuItem(&quot;退出&quot;);
        jmenu.add(jmenuItemLogout);
        jmenu.add(jmenuItemExit);


        JPanel jpanelMsg = new JPanel();
        JLabel jlabel1 = new JLabel(&quot;学号:&quot;);
        JLabel jlabel2 = new JLabel(&quot;姓名:&quot;);
        JLabel jlabel3 = new JLabel(&quot;性别:&quot;);
        JLabel jlabel4 = new JLabel(&quot;可借数量:&quot;);

        this.setLayout(null);

        JPanel panelWest = new JPanel();
        JPanel panelEast = new JPanel();
        JPanel panelSouth = new JPanel();
        panelWest.setBackground(new Color(255, 255, 243));
        panelEast.setBackground(new Color(255, 255, 243));
        panelSouth.setBackground(new Color(255, 255, 243));
        panelWest.setBounds(0, 0, 396, 180);
        panelEast.setBounds(396, 0, 400, 180);
        panelSouth.setBounds(0, 180, 800, 280);
        panelWest.setLayout(null);
        panelEast.setLayout(null);
        panelSouth.setLayout(null);
        this.add(panelWest);
        this.add(panelEast);
        this.add(panelSouth);

        panelWest.add(jpanelMsg);
        jpanelMsg.setBounds(47, 5, 160, 165);
        jpanelMsg.setLayout(null);
        jpanelMsg.setBackground(new Color(255,255,255));
        jpanelMsg.setBorder(new MatteBorder(0,0,0,1,Color.gray));

        jpanelMsg.add(jlabel1);
        jlabel1.setBounds(0, 15, 30, 25);
        jlabelAccountName = new JLabel(accountName);
        jpanelMsg.add(jlabelAccountName);
        jlabelAccountName.setBounds(35, 15, 90, 25);
        jlabelAccountName.setOpaque(true);
        jlabelAccountName.setBackground(new Color(255,255,255));

        jpanelMsg.add(jlabel2);
        jlabel2.setBounds(0, 48, 30, 25);
        jlabelPersonName = new JLabel(personName);
        jpanelMsg.add(jlabelPersonName);
        jlabelPersonName.setBounds(35, 48, 70, 25);
        jlabelPersonName.setOpaque(true);
        jlabelPersonName.setBackground(new Color(255,255,255));

        jpanelMsg.add(jlabel3);
        jlabel3.setBounds(0, 81, 30, 25);
        jlabelSex = new JLabel(sex);
        jpanelMsg.add(jlabelSex);
        jlabelSex.setBounds(35, 81, 30, 25);
        jlabelSex.setOpaque(true);
        jlabelSex.setBackground(new Color(255,255,255));

        jpanelMsg.add(jlabel4);
        jlabel4.setBounds(0, 114, 60, 25);
        jlabelAllBookNum = new JLabel(allBookNum);
        jpanelMsg.add(jlabelAllBookNum);
        jlabelAllBookNum.setBounds(65, 114, 60, 25);
        jlabelAllBookNum.setOpaque(true);
        jlabelAllBookNum.setBackground(new Color(255,255,255));

        showPortrait = new JPanel();
        panelWest.add(showPortrait);
        showPortrait.setBounds(240, 16, 120, 135);
        showPortrait.setBorder(BorderFactory.createLineBorder(Color.gray));

        JPanel jpanelChoice1 = new JPanel();
        JPanel jpanelChoice2 = new JPanel();

        panelEast.add(jpanelChoice1);
        panelEast.add(jpanelChoice2);
        jpanelChoice1.setLayout(null);
        jpanelChoice2.setLayout(null);
        jpanelChoice1.setBounds(0, 0, 386, 90);
        jpanelChoice2.setBounds(0, 90, 386, 90);
        jpanelChoice1.setBackground(new Color(255, 255, 243));
        jpanelChoice2.setBackground(new Color(255, 255, 243));
        jpanelChoice1.setBorder(new MatteBorder(0, 1, 1, 0, Color.gray));
        jpanelChoice2.setBorder(new MatteBorder(0, 1, 0, 0, Color.gray));

        JLabel jlabel5 = new JLabel(&quot;借书&quot;);
        JLabel jlabel6 = new JLabel(&quot;还书&quot;);

        jpanelChoice1.add(jlabel5);
        jlabel5.setBounds(30, 31, 30, 25);

        jtfInputIndexBorrow = new JTextField();
        jtfInputIndexBorrow.setText(&quot;输入所借图书的索引&quot;);
        jpanelChoice1.add(jtfInputIndexBorrow);
        jtfInputIndexBorrow.setBounds(80, 10, 200, 26);

        btSearchBorrow = new JButton(&quot;查找&quot;);
        jpanelChoice1.add(btSearchBorrow);
        btSearchBorrow.setBounds(290,11,60,25);

        jtfShowBookBorrow = new JTextField();
        jtfShowBookBorrow.setEnabled(false);
        jpanelChoice1.add(jtfShowBookBorrow);
        jtfShowBookBorrow.setBounds(80, 50, 200, 26);

        btConfirmBorrow = new JButton(&quot;借书&quot;);
        btConfirmBorrow.setEnabled(false);
        jpanelChoice1.add(btConfirmBorrow);
        btConfirmBorrow.setBounds(290,51,60,25);

        jpanelChoice2.add(jlabel6);
        jlabel6.setBounds(30, 31, 30, 25);

        jtfInputIndexReturn = new JTextField();
        jtfInputIndexReturn.setText(&quot;输入所还图书的索引&quot;);
        jpanelChoice2.add(jtfInputIndexReturn);
        jtfInputIndexReturn.setBounds(80, 10, 200, 26);

        btSearchReturn = new JButton(&quot;查找&quot;);
        jpanelChoice2.add(btSearchReturn);
        btSearchReturn.setBounds(290,11,60,25);

        jtfShowBookReturn = new JTextField();
        jtfShowBookReturn.setEnabled(false);
        jpanelChoice2.add(jtfShowBookReturn);
        jtfShowBookReturn.setBounds(80, 50, 200, 26);

        btConfirmReturn = new JButton(&quot;还书&quot;);
        btConfirmReturn.setEnabled(false);
        jpanelChoice2.add(btConfirmReturn);
        btConfirmReturn.setBounds(290,51,60,25);

        vectorJTableTitle = new Vector&lt;Object&gt;();

        vectorJTableTitle.add(0, &quot;索引&quot;);
        vectorJTableTitle.add(1, &quot;书名&quot;);
        vectorJTableTitle.add(2, &quot;借书日期&quot;);
        vectorJTableTitle.add(3, &quot;到期时间&quot;);

        JPanel jpanelJTable = new JPanel();
        panelSouth.add(jpanelJTable);
        jpanelJTable.setLayout(null);
        jpanelJTable.setBounds(15, 0, 768, 255);
        jpanelJTable.setBackground(new Color(255, 255, 243));
        jpanelJTable.setBorder(BorderFactory.createTitledBorder(new MatteBorder(1, 0, 0, 0, Color.gray), &quot;借书详情&quot;));

        defaultTableModel = new DefaultTableModel(vectorJTableMsg, vectorJTableTitle);
        jtableMsg = new JTable(defaultTableModel);
        jtableMsg.setRowHeight(25);
        DefaultTableCellRenderer r = new DefaultTableCellRenderer();   
        r.setHorizontalAlignment(JLabel.CENTER);   
        jtableMsg.setDefaultRenderer(Object.class,r);
        JScrollPane jscrollPane = new JScrollPane(jtableMsg);
        jpanelJTable.add(jscrollPane);
        jscrollPane.setBackground(Color.white);
        jscrollPane.setBounds(0, 18, 765, 235);

        jlabelShowDBMsg = new JLabel(strShowDBMsg);
        panelSouth.add(jlabelShowDBMsg);
        jlabelShowDBMsg.setBounds(680, 250, 100, 20);


        new MsgShowWinAction(this, jmenuItemLogout, jmenuItemExit, btSearchBorrow, btConfirmBorrow, btSearchReturn,btConfirmReturn,
                jtfInputIndexBorrow, jtfShowBookBorrow, jtfInputIndexReturn, jtfShowBookReturn, jtableMsg, vectorJTableTitle, 
                accountName, jlabelAllBookNum);

        this.setTitle(&quot;华师图书馆&quot;);
        this.setSize(msgWinWidth, msgWinHeight);
        Toolkit toolkit = Toolkit.getDefaultToolkit();
        Dimension dimension = toolkit.getScreenSize();
        int screenWidth = dimension.width;
        int screenHeight = dimension.height;
        this.setLocation((screenWidth - msgWinWidth) / 2, (screenHeight - msgWinHeight) / 2);
        this.setResizable(false);
        this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        this.validate();
        this.setVisible(true);
    }

    public void setShowAccountMsg(CheckAccount checkAccount){
        Vector&lt;Object&gt; vectorAccountMsg = new OperateDatabase().getAccountMsg(checkAccount);
        accountName = String.valueOf(vectorAccountMsg.get(0));
        personName = String.valueOf(vectorAccountMsg.get(2));
        sex = String.valueOf(vectorAccountMsg.get(3));
    }
}
</code></pre><p>同登录窗口的LoginWin.java文件一样,上面代码的大体作用一样是面板的布局</p>
<p>面板第一时间显示的信息都在该类的构造方法中完成<br>例如代码<br><code>strShowDBMsg = new OperateDatabase().checkConnectDatabase();</code><br>将调用一个OperateDatabase类中的checkConnectDatabase()方法来检测是否与数据库进行连接,其返回值为String类型的数据,用来在该面板底部显示数据库连接情况.起初并未打算在此处检测是否连接,但貌似那会儿没想到如何用来传递这种信息,所以就在这进行检测了,后面的几行代码依然如此<br>下面贴下于MsgShowWin类对应的action时间处理类的代码,文件名</p>
<h4 id="MsgShowWinAction-java"><a href="#MsgShowWinAction-java" class="headerlink" title="MsgShowWinAction.java:"></a>MsgShowWinAction.java:</h4><pre><code>package com.cgtest.action;

import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.FocusEvent;
import java.awt.event.FocusListener;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.Vector;

import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JMenuItem;
import javax.swing.JTable;
import javax.swing.JTextField;
import javax.swing.table.DefaultTableModel;

import com.cgtest.data.OperateDatabase;
import com.cgtest.ui.MyJDialog;

public class MsgShowWinAction implements ActionListener, MouseListener, FocusListener{

    public JFrame jframe;
    public JMenuItem jmenuItemLogout,jmenuItemExit;
    public JButton btSearchBorrow,btConfirmBorrow,btSearchReturn,btConfirmReturn;
    public JTextField jtfInputIndexBorrow,jtfShowBookBorrow,jtfInputIndexReturn,jtfShowBookReturn;
    public JTable jtable;
    public Vector&lt;Object&gt; vectorJTableTitle;
    public String accountName;
    public JLabel jlabelAllBookNum;


    public MsgShowWinAction(JFrame jframe, JMenuItem jmenuItemLogout, JMenuItem jmenuItemExit, JButton btSearchBorrow, JButton btConfirmBorrow,
            JButton btSearchReturn, JButton btConfirmReturn, JTextField jtfInputIndexBorrow, JTextField jtfShowBookBorrow,
            JTextField jtfInputIndexReturn, JTextField jtfShowBookReturn, JTable jtable, Vector&lt;Object&gt; vectorJTableTitle, 
            String accountName, JLabel jlabelAllBookNum){
        this.jframe = jframe;
        this.jmenuItemLogout = jmenuItemLogout;
        this.jmenuItemExit = jmenuItemExit;
        this.btSearchBorrow = btSearchBorrow;
        this.btConfirmBorrow = btConfirmBorrow;
        this.btSearchReturn = btSearchReturn;
        this.btConfirmReturn = btConfirmReturn;
        this.jtfInputIndexBorrow = jtfInputIndexBorrow;
        this.jtfShowBookBorrow = jtfShowBookBorrow;
        this.jtfInputIndexReturn = jtfInputIndexReturn;
        this.jtfShowBookReturn = jtfShowBookReturn;
        this.jtable = jtable;
        this.vectorJTableTitle = vectorJTableTitle;
        this.accountName = accountName;
        this.jlabelAllBookNum = jlabelAllBookNum;
        jmenuItemLogout.addActionListener(this);
        jmenuItemExit.addActionListener(this);
        btSearchBorrow.addActionListener(this);
        btConfirmBorrow.addActionListener(this);
        btSearchReturn.addActionListener(this);
        btConfirmReturn.addActionListener(this);
        jframe.addMouseListener(this);
        jtfShowBookBorrow.addMouseListener(this);
        jtfShowBookReturn.addMouseListener(this);
        btConfirmBorrow.addMouseListener(this);
        btConfirmReturn.addMouseListener(this);
        jtfInputIndexBorrow.addFocusListener(this);
        jtfInputIndexReturn.addFocusListener(this);
    }

    @Override
    public void actionPerformed(ActionEvent e) {
        if(e.getSource() == jmenuItemLogout){

            MyJDialog myJDialog = new MyJDialog(true, jframe);
            myJDialog.showChoiceForMsgWin(&quot;确定注销登录吗?&quot;);

        }else if(e.getSource() == jmenuItemExit){

            new MyJDialog(true, jframe).showChoice(&quot;确定退出系统?&quot;);

        }else if(e.getSource() == btSearchBorrow){

            String strjtfInputIndexBorrow = jtfInputIndexBorrow.getText();
            if(strjtfInputIndexBorrow.length() != 0){
                String strMsgorName = new OperateDatabase().searchBook(strjtfInputIndexBorrow);
                if(strMsgorName.equals(&quot;未找到此书&quot;)){
                    new MyJDialog(true, jframe).showMessage(&quot;未找到此书&quot;);
                }else{
                    jtfShowBookBorrow.setText(strMsgorName);
                }
            }else{
                new MyJDialog(true, jframe).showMessage(&quot;请输入图书索引&quot;);
            }

        }else if(e.getSource() == btConfirmBorrow){
            Vector&lt;Vector&lt;Object&gt;&gt; vectorJTableMsg = new Vector&lt;Vector&lt;Object&gt;&gt;();
//            System.out.println(accountName);
            String strjtfInputIndexBorrow = jtfInputIndexBorrow.getText();
            String strjtfShowBookBorrow = jtfShowBookBorrow.getText();
            String str = new OperateDatabase().borrowBook(strjtfInputIndexBorrow, strjtfShowBookBorrow, accountName);
            new MyJDialog(true, jframe).showMessage(str);
            if(str.equals(&quot;借书成功&quot;)){
                vectorJTableMsg = new OperateDatabase().getUserBorrowMsg(accountName);
                int bookNumNew = vectorJTableMsg.size();
                DefaultTableModel defaultTableModel = new DefaultTableModel(vectorJTableMsg, vectorJTableTitle);
                jtable.setModel(defaultTableModel);
                String allBookNumNew = bookNumNew + &quot;/10&quot;;
                jlabelAllBookNum.setText(allBookNumNew);
            }
        }else if(e.getSource() == btSearchReturn){

            String strjtfInputIndexReturn = jtfInputIndexReturn.getText();
            if(strjtfInputIndexReturn.length() != 0){
                String strMsgorName = new OperateDatabase().searchBook(strjtfInputIndexReturn);
                if(strMsgorName.equals(&quot;未找到此书&quot;)){
                    new MyJDialog(true, jframe).showMessage(&quot;未找到此书&quot;);
                }else{
                    jtfShowBookReturn.setText(strMsgorName);
                }
            }else{
                new MyJDialog(true, jframe).showMessage(&quot;请输入图书索引&quot;);
            }

        }else if(e.getSource() == btConfirmReturn){
            Vector&lt;Vector&lt;Object&gt;&gt; vectorJTableMsg = new Vector&lt;Vector&lt;Object&gt;&gt;();
            String strjtfShowBookReturn = jtfShowBookReturn.getText();
            String str = new OperateDatabase().returnBook(strjtfShowBookReturn);
            new MyJDialog(true, jframe).showMessage(str);
            if(str.equals(&quot;还书成功&quot;)){
                vectorJTableMsg = new OperateDatabase().getUserBorrowMsg(accountName);
                int bookNumNew = vectorJTableMsg.size();
                DefaultTableModel defaultTableModel = new DefaultTableModel(vectorJTableMsg, vectorJTableTitle);
                jtable.setModel(defaultTableModel);
                String allBookNumNew = bookNumNew + &quot;/10&quot;;
                jlabelAllBookNum.setText(allBookNumNew);
            }
        }
    }

    @Override
    public void mouseClicked(MouseEvent e) {

    }

    @Override
    public void mousePressed(MouseEvent e) {

    }

    @Override
    public void mouseReleased(MouseEvent e) {

    }

    @Override
    public void mouseEntered(MouseEvent e) {
        // TODO Auto-generated method stub
        if(e.getSource() == btConfirmBorrow){
            if(jtfShowBookBorrow.getText().length() != 0){
                btConfirmBorrow.setEnabled(true);
            }else{
                btConfirmBorrow.setEnabled(false);
            }
        }else if(e.getSource() == btConfirmReturn){
            if(jtfShowBookReturn.getText().length() != 0){
                btConfirmReturn.setEnabled(true);
            }else{
                btConfirmReturn.setEnabled(false);
            }
        }else if(e.getSource() == jframe){
            if(jtfShowBookBorrow.getText().length() != 0){
                btConfirmBorrow.setEnabled(true);
            }else if(jtfShowBookBorrow.getText().length() == 0){
                btConfirmBorrow.setEnabled(false);
            }else if(jtfShowBookReturn.getText().length() != 0){
                btConfirmReturn.setEnabled(true);
            }else if(jtfShowBookReturn.getText().length() == 0){
                btConfirmReturn.setEnabled(false);
            }
        }
    }

    @Override
    public void mouseExited(MouseEvent e) {

    }

    @Override
    public void focusGained(FocusEvent e) {
        // TODO Auto-generated method stub
        if(e.getSource() == jtfInputIndexBorrow){
            if(jtfInputIndexBorrow.getText().equals(&quot;输入所借图书的索引&quot;)){
                jtfInputIndexBorrow.setText(null);
            }
            jtfInputIndexReturn.setText(&quot;输入所还图书的索引&quot;);
            jtfShowBookBorrow.setText(null);
            jtfShowBookReturn.setText(null);
        }else if(e.getSource() == jtfInputIndexReturn){
            if(jtfInputIndexReturn.getText().equals(&quot;输入所还图书的索引&quot;)){
                jtfInputIndexReturn.setText(null);
            }
            jtfInputIndexBorrow.setText(&quot;输入所借图书的索引&quot;);
            jtfShowBookBorrow.setText(null);
            jtfShowBookReturn.setText(null);
        }
    }

    @Override
    public void focusLost(FocusEvent e) {
        // TODO Auto-generated method stub
        if(e.getSource() == jtfInputIndexBorrow){
            if(jtfInputIndexBorrow.getText().length() == 0){
                jtfInputIndexBorrow.setText(&quot;输入所借图书的索引&quot;);
            }
        }else if(e.getSource() == jtfInputIndexReturn){
            if(jtfInputIndexReturn.getText().length() == 0){

                jtfInputIndexReturn.setText(&quot;输入所还图书的索引&quot;);
            }
        }
    }

}
</code></pre><p>上面的代码中,在actionPerformed(ActionEvent e)方法中就是执行借书/还书/查询的操作,这里就直接看下实现借书操作的代码片段.借书分为两步,先是查找书籍,再是借书,先看查书,实现搜索图书的关键方法代码:<br><code>searchBook(strjtfInputIndexBorrow);</code><br>这里将用户输入的图书索引用作OperateDatabase类中的searchBook(strjtfInputIndexBorrow)的参数,其searchBook(strjtfInputIndexBorrow)的返回值为String类型的,且只有两种返回值,其返回值赋值给strMsgorName<br>从此行的下一行代码<code>if(strMsgorName.equals(&quot;未找到此书&quot;)){</code>就可以看出<br>再看借书,代码是调用OperateDataBase中的borrowBook(strjtfInputIndexBorrow, strjtfShowBookBorrow, accountName)方法,类OperateDataBase中的borrowBook()方法有3个参数,<br><code>strjtfInputIndexBorrow</code>即为查找图书用的索引,查书不到就无法进行借书,所以查找图书所用的索引是正确的<br><code>strjtfShowBookBorrow</code>即图书名字<br><code>accountName</code>及账户名<br>方法borrowBook()的返回值也为String类型,且只有两种情况,同样根据下面一行代码<code>if(str.equals(&quot;借书成功&quot;)){</code>就可以确认,其跟searchBook(strjtfInputIndexBorrow)类似<br>再来看类OperateDatabase的代码,文件名为</p>
<h4 id="OperateDatabase-java"><a href="#OperateDatabase-java" class="headerlink" title="OperateDatabase.java:"></a>OperateDatabase.java:</h4><pre><code>package com.cgtest.data;

import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;
import java.util.Vector;

public class OperateDatabase {
    public Vector&lt;Object&gt; dataAccount= new Vector&lt;&gt;();

    public Vector&lt;Object&gt; getAccountMsg(CheckAccount checkAccount){
        /*
         * 登录前(打开MsgShowWin面板前)获取账户信息
         * 使用原先创建CheckAccount对象的引用,来传递checkAccount的引用的vector
         * 依据登录名来获取姓名,性别
         */
        Vector&lt;Object&gt; vectorAccountMsg = new Vector&lt;Object&gt;();
        dataAccount = checkAccount.transmitAccountMsg();
//        if(dataAccount.size() == 0){
//            System.out.println(&quot;dataAccount:未得到数据&quot;);
//        }else{
//            for(int i = 0; i &lt; dataAccount.size(); i++){
//                System.out.println(dataAccount.get(i));
//            }
//        }
        String strAccountName = String.valueOf(dataAccount.get(0));
        String strSearchAccountMsg = &quot;SELECT * FROM accountMsg WHERE accountName = &quot; + &quot;&apos;&quot; + strAccountName + &quot;&apos;&quot;;
        Connection connection = new ConnectionDatabase().conectionDatabse();
        try {
            Statement statement = connection.createStatement();
            ResultSet resultSet = statement.executeQuery(strSearchAccountMsg);
            while(resultSet.next()){
                for(int i = 1; i &lt;= 6; i++){
                    vectorAccountMsg.add(resultSet.getString(i));
                }
            }
            resultSet.close();
            statement.close();
        } catch (SQLException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }

        try {
            connection.close();
        } catch (SQLException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }

        return vectorAccountMsg;
    }

    public Vector&lt;Vector&lt;Object&gt;&gt; getUserBorrowMsg(CheckAccount checkAccount){
        /*
         * 登录前(打开MsgShowWin面板前)获取账户借书信息
         * 根据登录账号获取所现借书信息
         */
        Vector&lt;Vector&lt;Object&gt;&gt; vectorUserBorrowMsg = new Vector&lt;Vector&lt;Object&gt;&gt;();
        dataAccount = checkAccount.transmitAccountMsg();
        String strAccountName = String.valueOf(dataAccount.get(0));
        String strSearchUserBorrowMsg = &quot;SELECT * FROM borrowBookMsg WHERE borrowAccountName = &quot; + &quot;&apos;&quot; + strAccountName + &quot;&apos;&quot;;
        Connection connection = new ConnectionDatabase().conectionDatabse();
        try {
            Statement statement = connection.createStatement();
            ResultSet resultSet = statement.executeQuery(strSearchUserBorrowMsg);
            while(resultSet.next()){
                Vector&lt;Object&gt; vectorOne = new Vector&lt;Object&gt;();
                for(int i = 2; i &lt;= 5; i++){
                    vectorOne.add(resultSet.getString(i));
                }
                vectorUserBorrowMsg.add(vectorOne);
            }
            resultSet.close();
            statement.close();
        } catch (SQLException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
        try {
            connection.close();
        } catch (SQLException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
        return vectorUserBorrowMsg;
    }

//    public Vector&lt;Object&gt; getAccountMsg(String accountName){
//        /*
//         * 登录后,用来刷新数据
//         * 通过登录名来获取账户信息
//         */
//        Vector&lt;Object&gt; vectorAccountMsg = new Vector&lt;Object&gt;();
//        String sqlSearchAccountMsg = &quot;SELECT * FROM accountMsg WHERE accountName = &quot; + &quot;&apos;&quot; + accountName + &quot;&apos;&quot;;
//        Connection connection = new ConnectionDatabase().conectionDatabse();
//        try {
//            Statement statement = connection.createStatement();
//            ResultSet resultSet = statement.executeQuery(sqlSearchAccountMsg);
//            while(resultSet.next()){
//                for(int i = 1; i &lt;= 6; i++){
//                    vectorAccountMsg.add(resultSet.getString(i));
//                }
//            }
//            resultSet.close();
//            statement.close();
//        } catch (SQLException e) {
//            // TODO Auto-generated catch block
//            e.printStackTrace();
//        }
//        
//        try {
//            connection.close();
//        } catch (SQLException e) {
//            // TODO Auto-generated catch block
//            e.printStackTrace();
//        }
//        
//        return vectorAccountMsg;
//    }

    public Vector&lt;Vector&lt;Object&gt;&gt; getUserBorrowMsg(String accountName){
        /*
         * 登录后获取,用来刷新数据
         * 根据登录账号名获取所现借书信息
         */
        Vector&lt;Vector&lt;Object&gt;&gt; vectorUserBorrowMsg = new Vector&lt;Vector&lt;Object&gt;&gt;();
        String sqlSearchUserBorrowMsg = &quot;SELECT * FROM borrowBookMsg WHERE borrowAccountName = &quot; + &quot;&apos;&quot; + accountName + &quot;&apos;&quot;;
        Connection connection = new ConnectionDatabase().conectionDatabse();
        try {
            Statement statement = connection.createStatement();
            ResultSet resultSet = statement.executeQuery(sqlSearchUserBorrowMsg);
            while(resultSet.next()){
                Vector&lt;Object&gt; vectorOne = new Vector&lt;Object&gt;();
                for(int i = 2; i &lt;= 5; i++){
                    vectorOne.add(resultSet.getString(i));
                }
                vectorUserBorrowMsg.add(vectorOne);
            }
            resultSet.close();
            statement.close();
        } catch (SQLException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
        try {
            connection.close();
        } catch (SQLException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
        return vectorUserBorrowMsg;
    }

    public String searchBook(String strjtfInputIndexBorrow){
        /*
         * 根据索引来查找图书名称,并返回
         */
        String str = &quot;未找到此书&quot;;
        String sqlSearchBook = &quot;SELECT bookName FROM allBook WHERE bookIndex = &quot; + &quot;&apos;&quot; + strjtfInputIndexBorrow + &quot;&apos;&quot;;
        Connection connection = new ConnectionDatabase().conectionDatabse();
        try {
            Statement statement = connection.createStatement();
            ResultSet resultSet = statement.executeQuery(sqlSearchBook);

            while(resultSet.next()){
                str = resultSet.getString(1);
            }
            resultSet.close();
            statement.close();
        } catch (SQLException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
        try {
            connection.close();
        } catch (SQLException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
        return str;
    }

    public String borrowBook(String strjtfInputIndexBorrow, String strjtfShowBookBorrow, String accountName){
        /*
         * 借书过程,
         * 先通过传递过来的书名,通过书名来在borrowBookMsg所有已经借出去的书的信息库中对比,确认该库中是否有这本书(若有,则表示该书已经借出去)
         * 若有,继而再判断是不是现在的登录账户借了,如果不是,则返回已经被别人借走,
         * 若无,则开始借书过程
         */
        String str = null;
        String sqlCheckAccountWetherBorrow = &quot;SELECT borrowAccountName FROM borrowBookMsg WHERE borrowBookName = &quot; + &quot;&apos;&quot; + strjtfShowBookBorrow + &quot;&apos;&quot;;
        Connection connection = new ConnectionDatabase().conectionDatabse();
        try {
            Statement statement = connection.createStatement();
            ResultSet resultSet = statement.executeQuery(sqlCheckAccountWetherBorrow);
            Vector&lt;Object&gt; vectorAccountName = new Vector&lt;Object&gt;();
            while(resultSet.next()){
                vectorAccountName.add(resultSet.getString(1));
            }
            if(vectorAccountName.size() != 0){
                if(vectorAccountName.get(0).equals(accountName)){
                    str = &quot;你已借阅该图书,请注意保管&quot;;
                }else{
                    str = &quot;该图书已被他人借阅&quot;;
                }
            }else{
//                System.out.println(&quot;该书在架上&quot;);
                SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy.MM.dd&quot;);
                String borrowTime = simpleDateFormat.format(new Date());
                String borrowNeedReturnTime = getNeedReturnTime();
                String sqlBorrowInsert = &quot;INSERT INTO borrowBookMsg(borrowAccountName, borrowBookIndex, borrowBookName, borrowTime, borrowNeedReturnTime)&quot;
                        + &quot;VALUES&quot; + &quot;(&quot; + &quot;&apos;&quot; + accountName + &quot;&apos;&quot; + &quot;,&quot; + &quot;&apos;&quot; + strjtfInputIndexBorrow + &quot;&apos;&quot; + &quot;,&quot; + &quot;&apos;&quot; + strjtfShowBookBorrow + &quot;&apos;&quot; + &quot;,&quot; 
                        + &quot;&apos;&quot; + borrowTime + &quot;&apos;&quot; + &quot;,&quot; + &quot;&apos;&quot;+ borrowNeedReturnTime + &quot;&apos;&quot; + &quot;)&quot;;
                int n = statement.executeUpdate(sqlBorrowInsert);
                if(n &gt; 0){
                    str = &quot;借书成功&quot;;
                }else{
                    str = &quot;借书失败&quot;;
                }
            }
            resultSet.close();
            statement.close();

        } catch (SQLException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
        try {
            connection.close();
        } catch (SQLException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
        return str;
    }

    public String returnBook(String strjtfShowBookReturn){
        /*
         * 还书
         */
        String str = null;
        String sqlCheckWetherBorrow = &quot;SELECT borrowAccountName FROM borrowBookMsg WHERE borrowBookName = &quot; + &quot;&apos;&quot; + strjtfShowBookReturn + &quot;&apos;&quot;;
        String sqlReturnBook = &quot;DELETE FROM borrowBookMsg WHERE borrowBookName = &quot; + &quot;&apos;&quot; + strjtfShowBookReturn + &quot;&apos;&quot;;
        Connection connection = new ConnectionDatabase().conectionDatabse();
        try {
            Statement statement = connection.createStatement();
            ResultSet resultSet = statement.executeQuery(sqlCheckWetherBorrow);
            Vector&lt;Object&gt; vectorAccountName = new Vector&lt;Object&gt;();
            while(resultSet.next()){
                vectorAccountName.add(resultSet.getString(1));
            }
            if(vectorAccountName.size() != 0){
                int n = statement.executeUpdate(sqlReturnBook);
                if( n &gt; 0){
                    str = &quot;还书成功&quot;;
                }else{
                    str = &quot;还书失败&quot;;
                }
            }else{
                str = &quot;该书未借出&quot;;
            }
            resultSet.close();
            statement.close();
        } catch (SQLException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
        try {
            connection.close();
        } catch (SQLException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
        return str;
    }

    public String getNeedReturnTime(){
        /*
         * 获取当前系统时间的下一个月时间,并返回
         */
        String str = null;
        Calendar calendar = Calendar.getInstance();
        calendar.setTime(new Date());
        calendar.add(Calendar.MONTH, +1);
        Date dateNextMonth = calendar.getTime();
        SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy.MM.dd&quot;);
        str = simpleDateFormat.format(dateNextMonth);
        return str;
    }

    public String checkConnectDatabase(){
        /*
         * for MsgWin窗口
         */
        String str = null;
        Connection connection = new ConnectionDatabase().conectionDatabse();
        if(connection != null){
            str = &quot;已连接数据库&quot;;
        }else{
            str = &quot;未连接数据库&quot;;
        }
        try {
            connection.close();
        } catch (SQLException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
        return str;
    }

}
</code></pre><p>其中的方法borrowBook()显示通过书名,来与已经借出去的书的信息库中进行对比,也就是有一张表专门用来存放记录所有已经借出去的书籍,这样一来,如果对比到了的话说明这本书已经借出去,然而借出去的话有两种情况,一种是被自己借了,另一种就是被别人借走了,所以如果表中有该书名,那么还要根据表来对比账号名.所以这样做,使得借书和还书都更简单了,所以借书的道理也差不多.当然,这里我也自定义了一个对话框,<br>如下对话框代码,文加名字为</p>
<h4 id="MyJDialog-java"><a href="#MyJDialog-java" class="headerlink" title="MyJDialog.java:"></a>MyJDialog.java:</h4><pre><code>package com.cgtest.ui;

import java.awt.BorderLayout;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

import javax.swing.JButton;
import javax.swing.JDialog;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.SwingUtilities;
import javax.swing.UIManager;
import javax.swing.UnsupportedLookAndFeelException;


/**
 * @author cg
 *自定义对话框，
 *如果将组件属性设置为static，那么将会出现变量值不会初始化
 *pack()方法和validate()方法不能共存
 *showChoiceForMsgWin(),drawShowChoiceForMsgWin()这两个方法是专门为系统注销登录而写的消息窗口,代码臃肿.重复,,,,日后改进-----2016.11.13
 */
public class MyJDialog{
    public JFrame jframe;
    public JDialog jdialog;
    public JLabel labelShow;
    public JButton btEnter,btCancel;
    public JPanel panelCenter = new JPanel(),panelSouth = new JPanel();
    boolean modal;

    public int index = 0, indexChoice = 0;

    public MyJDialog(boolean modal, JFrame jframe){
        this.modal = modal;
        this.jframe = jframe;
    }

    public void showMessage(String str){
        SwingUtilities.invokeLater(new Runnable() {

            @Override
            public void run() {
                try {
                    UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
                } catch (ClassNotFoundException | InstantiationException | IllegalAccessException
                        | UnsupportedLookAndFeelException e) {
                    e.printStackTrace();
                }
                drawShowMessage(str);
            }
        });

    }
    public void drawShowMessage(String str){
        jdialog = new JDialog();
        jdialog.setModal(modal);

        jdialog.add(panelCenter,BorderLayout.CENTER);        
        jdialog.add(panelSouth, BorderLayout.SOUTH);

        labelShow = new JLabel(str);
        panelCenter.add(labelShow);

        btEnter = new JButton(&quot;确定&quot;);
        panelSouth.add(btEnter);
        btEnter.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                    jdialog.dispose();
            }
        });

        jdialog.setTitle(&quot;消息&quot;);
        jdialog.pack();
        jdialog.setResizable(false);
        int widthDia = (jframe.getX()+(jframe.getWidth())/2) - jdialog.getWidth()/2;
        int heightDia = (jframe.getY() + (jframe.getHeight()/2) - jdialog.getHeight()/2);
        jdialog.setLocation(widthDia, heightDia);
        jdialog.setVisible(true);
    }
    public void showChoice(String str){
        SwingUtilities.invokeLater(new Runnable() {

            @Override
            public void run() {
                try {
                    UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
                } catch (ClassNotFoundException | InstantiationException | IllegalAccessException
                        | UnsupportedLookAndFeelException e) {
                    e.printStackTrace();
                }
                drawShowChoice(str);
            }
        });
    }
    public void drawShowChoice(String str){
        jdialog = new JDialog();
        jdialog.setModal(modal);

        jdialog.add(panelCenter,BorderLayout.CENTER);
        jdialog.add(panelSouth, BorderLayout.SOUTH);

        labelShow = new JLabel(str);
        panelCenter.add(labelShow);

        btEnter = new JButton(&quot;确定&quot;);
        panelSouth.add(btEnter);
        btEnter.addActionListener(new ActionListener() {

            @Override
            public void actionPerformed(ActionEvent e) {
                jdialog.dispose();
                jframe.dispose();
                System.exit(0);
            }
        });

        btCancel = new JButton(&quot;取消&quot;);
        panelSouth.add(btCancel);
        btCancel.addActionListener(new ActionListener() {

            @Override
            public void actionPerformed(ActionEvent e) {
                jdialog.dispose();
            }
        });

        jdialog.setTitle(&quot;请注意&quot;);
        jdialog.pack();
        jdialog.setResizable(false);
        int widthDia = (jframe.getX()+(jframe.getWidth())/2) - jdialog.getWidth()/2;
        int heightDia = (jframe.getY() + (jframe.getHeight()/2) - jdialog.getHeight()/2);
        jdialog.setLocation(widthDia, heightDia);
        jdialog.setVisible(true);

    }

    public void showChoiceForMsgWin(String str){
        SwingUtilities.invokeLater(new Runnable() {

            @Override
            public void run() {
                try {
                    UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
                } catch (ClassNotFoundException | InstantiationException | IllegalAccessException
                        | UnsupportedLookAndFeelException e) {
                    e.printStackTrace();
                }
                drawShowChoiceForMsgWin(str);
            }
        });
    }
    public void drawShowChoiceForMsgWin(String str){
        jdialog = new JDialog();
        jdialog.setModal(modal);

        jdialog.add(panelCenter,BorderLayout.CENTER);
        jdialog.add(panelSouth, BorderLayout.SOUTH);

        labelShow = new JLabel(str);
        panelCenter.add(labelShow);

        btEnter = new JButton(&quot;确定&quot;);
        panelSouth.add(btEnter);
        btEnter.addActionListener(new ActionListener() {

            @Override
            public void actionPerformed(ActionEvent e) {
                jdialog.dispose();
                jframe.dispose();
//                System.exit(0);
                try {
                    Thread.sleep(600);                     //神奇的代码,dispose不能关闭线程,system.exit(0)可以
                    new LoginWin();
                } catch (InterruptedException e1) {
                    // TODO Auto-generated catch block
                }
//                System.out.println(&quot;启动登录窗口&quot;);
            }
        });

        btCancel = new JButton(&quot;取消&quot;);
        panelSouth.add(btCancel);
        btCancel.addActionListener(new ActionListener() {

            @Override
            public void actionPerformed(ActionEvent e) {
                jdialog.dispose();
            }
        });

        jdialog.setTitle(&quot;请注意&quot;);
        jdialog.pack();
        jdialog.setResizable(false);
        int widthDia = (jframe.getX()+(jframe.getWidth())/2) - jdialog.getWidth()/2;
        int heightDia = (jframe.getY() + (jframe.getHeight()/2) - jdialog.getHeight()/2);
        jdialog.setLocation(widthDia, heightDia);
        jdialog.setVisible(true);

    }
//    public int choiceTrigger(String str){
//        index = showChoice(str);
//        return index;
//    }

}
</code></pre><p>上面的代码只是自定义对话框,代码有点臃肿,然后就是main函数了<br>如下代码,文件名为</p>
<h4 id="BookControlSystem-java"><a href="#BookControlSystem-java" class="headerlink" title="BookControlSystem.java:"></a>BookControlSystem.java:</h4><pre><code>package com.cgtest.main;

import com.cgtest.ui.LoginWin;

/**
 * @author cg
 * 图书管理系统
 *基于linux系统上的xampp软件包上开发运行
 *实现用户登录,借书,还书
 *,
 */
public class BookControlSystem {
    public static void main(String [] args){
        new LoginWin();
    }
}
</code></pre><p>最后,贴下</p>
<h4 id="数据库的建立脚本"><a href="#数据库的建立脚本" class="headerlink" title="数据库的建立脚本:"></a>数据库的建立脚本:</h4><pre><code>CREATE DATABASE bookControlSystem;
USE bookControlSystem;
CREATE TABLE accountMsg(accountName char(20) PRIMARY KEY,accountPasswd char(20),accountPersonName char(20),accountSex char(5),accountAge int,accountContactInfo char(20))
INSERT INTO accountMsg(accountName,accountPasswd,accountPersonName,accountSex,
accountAge,accountContactInfo) VALUES (&apos;V201441122&apos;,&apos;201441122&apos;,&apos;王珉&apos;,&apos;男&apos;,&apos;20&apos;,&apos;18062449761&apos;);
INSERT INTO accountMsg(accountName,accountPasswd,accountPersonName,accountSex,
accountAge,accountContactInfo) VALUES (&apos;V201441123&apos;,&apos;201441123&apos;,&apos;罗洋&apos;,&apos;男&apos;,&apos;21&apos;,&apos;1390721584&apos;);
INSERT INTO accountMsg(accountName,accountPasswd,accountPersonName,accountSex,
accountAge,accountContactInfo) VALUES (&apos;V201441035&apos;,&apos;wuhan1035&apos;,&apos;王厕所&apos;,&apos;女&apos;,&apos;20&apos;,&apos;18062249061&apos;);


CREATE TABLE borrowBookMsg(borrowAccountName char(20) ,borrowBookIndex char(20),borrowBookName char(20),borrowTime char(20),borrowNeedReturnTime char(20));
INSERT INTO borrowBookMsg(borrowAccountName,borrowBookIndex,borrowBookName,
borrowTime,borrowNeedReturnTime) VALUES (&apos;V201441122&apos;,
&apos;TP221-21&apos;,&apos;檀香刑&apos;,&apos;2016.11.1&apos;,&apos;2016.12.1&apos;);
INSERT INTO borrowBookMsg(borrowAccountName,borrowBookIndex,borrowBookName,
borrowTime,borrowNeedReturnTime) VALUES (&apos;V201441122&apos;,
&apos;TN231-34&apos;,&apos;Java编程思想&apos;,&apos;2016.11.11&apos;,&apos;2016.12.11&apos;);
INSERT INTO borrowBookMsg
(borrowAccountName,borrowBookIndex,borrowBookName,
borrowTime,borrowNeedReturnTime) VALUES (&apos;V201441123&apos;,
&apos;TB124-33&apos;,&apos;C语言入门&apos;,&apos;2016.11.05&apos;,&apos;2016.12.05&apos;);

CREATE TABLE allBook(bookIndex char(20) PRIMARY KEY,bookName char(20));
INSERT INTO allBook(bookIndex,bookName) VALUES (&apos;TP221-21&apos;,&apos;檀香刑&apos;);
INSERT INTO allBook(bookIndex,bookName) VALUES (&apos;TN231-34&apos;,&apos;Java编程思想&apos;);
INSERT INTO allBook(bookIndex,bookName) VALUES (&apos;TB124-33&apos;,&apos;C语言入门&apos;);
INSERT INTO allBook(bookIndex,bookName) VALUES (&apos;TB124-30&apos;,&apos;C语言从入门到精通&apos;);
INSERT INTO allBook(bookIndex,bookName) VALUES (&apos;TP221-20&apos;,&apos;丰乳肥臀&apos;);
INSERT INTO allBook(bookIndex,bookName) VALUES (&apos;TN231-33&apos;,&apos;Java语言入门&apos;);
</code></pre><p>至此,就完成了图书馆管理系统的建立</p>
<p>将代码整合在各个包中,并创建该文件,配置好数据库服务器地址,用户名和密码就可以运行了</p>
<p>代码有点臃肿,我到日后改进</p>
<p>谢谢</p>
]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> codeing </tag>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java读取自己文件内容]]></title>
      <url>/2017/02/13/java/2017-2-13-java-BufferedInputFile/</url>
      <content type="html"><![CDATA[<p>这里使用对文件进行缓冲,将得到的引用传给BufferedReader构造器,从而实现对文件的读取<br>代码如下</p>
<a id="more"></a>
<pre><code>public class BufferedInputFile {
    public static String read(String fileName) throws IOException{

        BufferedReader br = new BufferedReader(new FileReader(fileName));

        String s = null;

        StringBuffer sb = new StringBuffer();
        while((s = br.readLine()) != null){
            sb.append(s + &quot;\n&quot;);
        }
        br.close();
        return sb.toString();
    }

    public static void main(String [] args) throws IOException{
        System.out.println(read(&quot;BufferedInputFile.java&quot;));
    }
}
</code></pre><p>程序的输出则为该程序的源代码,此段程序的文件名为BufferedInputFile.java.文件的运行需要在终端中使用命令运行,如若在Eclipse中运行,则会抛出FileNotFound异常<br>其中,BufferedReader中的readLine()方法会将换行符删掉,所以append方法内需要添加”\n”<br>运行如下图:</p>
<p><img src="/images/java/java-BufferedInputFile.png" alt="java-BufferedInputFile"></p>
]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> codeing </tag>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java中的foreach语法]]></title>
      <url>/2017/02/13/java/2017-2-13-java-Foreach/</url>
      <content type="html"><![CDATA[<p>foreach语法多用与数组和容器，表示不用创建int变量去对由访问项构成的序列进行计数，foreach将自动产生每一项</p>
<ul>
<li><p>程序中Random random = new Random(47)中的47作为种子,是伪随机数生成器的内部状态的初始值，<br>随机产生的数字随着种子的改变而改变也就是使用了种子的随机数生成器其random对象在每一次运行程序时产生的数值都相同，</p>
</li>
<li><p>而Random random = new Random()这中创建对象可以认为是默认使用时间作为种子</p>
</li>
</ul>
<p>代码如下:</p>
<a id="more"></a>
<pre><code>public class ForEachFloat {
    public static void main(String [] args){
        Random random = new Random(47);
        float f[] = new float[5];
        for(int i = 0; i &lt; 5; i++){
            f[i] = random.nextFloat();
        }
        for(float x : f){
            System.out.print(x + &quot;---&quot;);
        }
        System.out.println();
        TextVector textVector = new TextVector();
        textVector.showVector();
    }
}
class TextVector{
    Vector&lt;Object&gt; vector = new Vector&lt;Object&gt;();
    public void showVector(){
        for(int i = 1; i &lt;= 5; i++){
            vector.add(i * 10);
        }
        for(Object x : vector){
            System.out.print(x + &quot;---&quot;);
        }
    }
}
</code></pre><p>输出:</p>
<pre><code>0.72711575---0.39982635---0.5309454---0.0534122---0.16020656---
10---20---30---40---50---
</code></pre>]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> codeing </tag>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java数据类型转换]]></title>
      <url>/2017/02/13/java/2017-2-13-java-CastingNum/</url>
      <content type="html"><![CDATA[<p>Java中的类型转换操作</p>
<p>在java中，类型的转换是一种比较安全的操作，如果要执行一种名为榨化转换的操作(也就是说，将能容纳更多信息的数据类型转换成无法容纳那么多信息的类型)，<br>就有可能面临信息丢失的危险，所以此时，编译器会强制我们进行类型转换，所以说，这可能是意见危险的事情，如果无论如何都要这么做，那必须显式地进行类型转换．<br>而对于扩展转换，则不必显式地进行类型转换，因为新类型肯定能容纳原来类型的信息，不会造成任何信息的丢失</p>
<p>如下程序，java在将float或double类型转换成int类型时，总是对该数字执行截尾．</p>
<a id="more"></a>
<ul>
<li><p>如果想要得到舍入的结构，就需要使用java.lang.Math中的round()方法</p>
</li>
<li><p>比int类型小的数据类型只有byte和short类型</p>
</li>
<li><p>通常，在表达式中出现的最大的数据类型决定了该表达式最终的数据类型，例如一个float值与一个double值相乘，结果就是double类型</p>
</li>
<li><p>如果一个int和一个long类型相加，则结果为long类型</p>
</li>
<li><p>java没有sizeof,在c和c++中，sizeof()操作符可以告诉你为数据项分配的字节数，而通常使用sizeof()的最大原因是为了”移植”．</p>
</li>
<li><p>不同的数据类型在不同的机器上可能有不同的大小，所以在进行一些与存储空间有关的运算时，程序员必须获悉那些数据类型具体有多大．例如，<br>一台计算机可用32位来保存整数，而另一台只用16位来保存，显然，在第一台机器中，程序可保存更大的值，可以想想，移植是令c和c++程序员颇为头疼的一个问题，<br>而java则不需要sizeof()操作符来满足这方面的需要，所有数据类型在所有机器中的大小都是相同的</p>
</li>
</ul>
<p>代码如下:</p>
<pre><code>public class CastingNum {
    public static void main(String [] args){
        double above = 0.7,below = 0.4;
        float fabove = 0.7f,fbelow = 0.4f;
        System.out.println(&quot;int(above)&quot; + (int)above);
        System.out.println(&quot;int(below)&quot; + (int)below);
        System.out.println(&quot;int(fabove)&quot; + (int)fabove);
        System.out.println(&quot;int(fbelow)&quot; + (int)fbelow);
        System.out.println(&quot;下面使用四舍五入的方法&quot;);
        System.out.println(&quot;Math.round(above)&quot; + Math.round(above));
        System.out.println(&quot;Math.round(below)&quot; + Math.round(below));
        System.out.println(&quot;Math.round(fabove)&quot; + Math.round(fabove));
        System.out.println(&quot;Math.round(fbelow)&quot; + Math.round(fbelow));
    }
}
</code></pre><p>输出:</p>
<pre><code>int(above)0
int(below)0
int(fabove)0
int(fbelow)0
下面使用四舍五入的方法
Math.round(above)1
Math.round(below)0
Math.round(fabove)1
Math.round(fbelow)0
</code></pre>]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> codeing </tag>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java类似C中的goto跳转语句]]></title>
      <url>/2017/02/13/java/2017-2-13-java-LikegotoJlabel/</url>
      <content type="html"><![CDATA[<p>Java中的跳转标签机制label</p>
<h5 id="总结点"><a href="#总结点" class="headerlink" title="总结点:"></a>总结点:</h5><ul>
<li><p>break:终端内部迭代，回到外部迭代</p>
</li>
<li><p>continue：使执行点移到内部迭代的起始处</p>
</li>
<li><p>continue label：同时中断内部迭代以及外部迭代，直接转到label处在执行，实际上是继续迭代过程，但却从外部迭代开始</p>
</li>
</ul>
<a id="more"></a>
<ul>
<li><p>break label：中断所有迭代，并回到label处，但并不重新进入迭代，也就是说，是完全终止了两个迭代</p>
</li>
<li><p>所有的对比都是建立在for循环条件中i++之前的i值，而不是i++后的值</p>
</li>
<li><p>continue label语句执行后，也会如同break语句一样，跳过for循环里的i++，</p>
</li>
<li><p>重点:在java里需要使用标签的唯一理由就是因为有循环嵌套存在，而且想从多层嵌套中break或continue</p>
</li>
</ul>
<p>代码如下:</p>
<pre><code>public class LabelTest {
    public static void main(String [] args){
        int i = 0;
        outer:
            for(;;){
                inner:
                    for(; i &lt; 10; i++){
                        System.out.println(&quot;开始i = &quot; + i + &quot;循环&quot;);
                        if(i == 2){
                            System.out.println(&quot;i == 2,执行continue,将执行i=３循环......&quot;);
                            continue;
                        }
                        if(i == 3){
                            System.out.println(&quot;i == 3,执行break,不执行后面的for(k)循环,直接进入for(i)的i=4循环......&quot;);
                            i++;
                            System.out.println(&quot;此时i的值为&quot; + i);
                            break;
                        }
                        if(i == 5){
                            System.out.println(&quot;i == 5，执行continue outer，回到outer标签,从最外层for(;;)循环开始,将执行i=6循环......&quot;);
                            i++;
                            continue outer;
                        }
                        if(i == 9){
                            System.out.println(&quot;i == 9，执行break outer,终止所有循环,程序结束&quot;);
                            break outer;
                        }
                        for(int k = 0; k &lt; 5; k++){
                            if(k == 3){
                                System.out.println(&quot;i = &quot; + i + &quot;的循环,&quot; + &quot;k从０开始，k == 3－＞执行continue inner,回到inner处,从for(i)循环,将执行i = &quot; + (i + 1) + &quot;循环......&quot;);
                                continue inner;
                            }
                        }
                    }
            }
    }
}
</code></pre><p>输出:</p>
<pre><code>开始i = 0循环
i = 0的循环,k从０开始，k == 3－＞执行continue inner,回到inner处,从for(i)循环,将执行i = 1循环......
开始i = 1循环
i = 1的循环,k从０开始，k == 3－＞执行continue inner,回到inner处,从for(i)循环,将执行i = 2循环......
开始i = 2循环
i == 2,执行continue,将执行i=３循环......
开始i = 3循环
i == 3,执行break,不执行后面的for(k)循环,直接进入for(i)的i=4循环......
此时i的值为4
开始i = 4循环
i = 4的循环,k从０开始，k == 3－＞执行continue inner,回到inner处,从for(i)循环,将执行i = 5循环......
开始i = 5循环
i == 5，执行continue outer，回到outer标签,从最外层for(;;)循环开始,将执行i=6循环......
开始i = 6循环
i = 6的循环,k从０开始，k == 3－＞执行continue inner,回到inner处,从for(i)循环,将执行i = 7循环......
开始i = 7循环
i = 7的循环,k从０开始，k == 3－＞执行continue inner,回到inner处,从for(i)循环,将执行i = 8循环......
开始i = 8循环
i = 8的循环,k从０开始，k == 3－＞执行continue inner,回到inner处,从for(i)循环,将执行i = 9循环......
开始i = 9循环
i == 9，执行break outer,终止所有循环,程序结束
</code></pre>]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> codeing </tag>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java跳转语句]]></title>
      <url>/2017/02/13/java/2017-2-13-java-BreakContinue/</url>
      <content type="html"><![CDATA[<p>Java中的break和continue语句</p>
<p>自己即将毕业了,准备把之前学习时编写的代码笔记整理下.重温知识点</p>
<ul>
<li><p>break用于强行退出循环，不执行循环中剩余的语句，而continue则是停止执行当前的迭代，然后退回循环起始处，开始下一次迭代</p>
</li>
<li><p>foreach语句貌似不能像for循环那样依次存储数据，只能遍历输出数据</p>
</li>
<li><p>无穷循环有两种形式:while(true)和for(;;)</p>
</li>
<li><p>为了解break和continue的运行过程的差别,例如程序中的forbreakTest()方法</p>
</li>
</ul>
<a id="more"></a>
<ul>
<li><p>在当i == 2时，程序输出打印后，执行continue语句，在结束本次循环前,会先执行for循环中的条件语句i++，之后在结束本次循环</p>
</li>
<li><p>而break则不同，在当i == 7时，程序输出打印后，执行break语句，结束所有循环，for循环中的条件语句i++会未被执行，直接结束</p>
</li>
</ul>
<p>代码如下:</p>
<pre><code>public class BreakContinue {
    public static void main(String [] args){
        Test test = new Test();
        test.forTest(50);
        test.foreachTest(40);
        test.forbreakTest();
    }
}
class Test{
    public void forTest(int maxNum){
        System.out.println(&quot;所查找出在数字0~&quot; + maxNum + &quot;中,能被３整除且不等于47的数有:&quot;);
        for(int i = 0, j = 1; i &lt; maxNum; i++, j++){
            if(i == 47) break;
            if(i % 3 != 0) continue;
            System.out.println(&quot;第&quot; + j + &quot;次查找,i = &quot; + i);
        }
    }
    public void foreachTest(int maxNum){
        int index[] = new int[10];
        Random random = new Random();
        for(int i = 0; i &lt; index.length; i++){
            index[i] = random.nextInt(maxNum);
        }
        for(int i = 0; i &lt; index.length; i++){
            System.out.println(&quot;index&quot; + &quot;[&quot; + i + &quot;]&quot; + index[i]);
        }
        System.out.println(&quot;在随机生成元素０～&quot; + maxNum + &quot;的数组中不等于47且能被２整除的元素有:&quot;);
        for(int n: index){
            if(n == 47) break;
            if(n % 2 != 0) continue;
            System.out.print(n + &quot;---&quot;);
        }
        System.out.println();
    }
    public void forbreakTest(){
        System.out.println(&quot;下面测试break和continue&quot;);
        for(int i = 0; i &lt; 10; i++){
            System.out.print(&quot;i = &quot; + i + &quot;,&quot;);
            if(i == 2){
                System.out.println();
                System.out.println(&quot;i == 2,执行continue,结束本次循环,进入i=3循环&quot;);
                continue;
            }
            if(i == 7){
                System.out.println();
                System.out.println(&quot;i == 7,执行break,结束整个for循环&quot;);
                break;
            }
        }
    }
}
</code></pre><p>输出:</p>
<pre><code>所查找出在数字0~50中,能被３整除且不等于47的数有:
第1次查找,i = 0
第4次查找,i = 3
第7次查找,i = 6
第10次查找,i = 9
第13次查找,i = 12
第16次查找,i = 15
第19次查找,i = 18
第22次查找,i = 21
第25次查找,i = 24
第28次查找,i = 27
第31次查找,i = 30
第34次查找,i = 33
第37次查找,i = 36
第40次查找,i = 39
第43次查找,i = 42
第46次查找,i = 45
index[0]20
index[1]10
index[2]16
index[3]0
index[4]37
index[5]4
index[6]19
index[7]35
index[8]13
index[9]15
在随机生成元素０～40的数组中不等于47且能被２整除的元素有:
20---10---16---0---4---
下面测试break和continue
i = 0,i = 1,i = 2,
i == 2,执行continue,结束本次循环,进入i=3循环
i = 3,i = 4,i = 5,i = 6,i = 7,
i == 7,执行break,结束整个for循环
</code></pre>]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> codeing </tag>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java打印菱形  ]]></title>
      <url>/2017/01/19/java/2017-1-19-java-DiamonDemo/</url>
      <content type="html"><![CDATA[<p>Java打印菱形和空心菱形，如图：</p>
<p><img src="/images/java/java-diamonDemo.png" alt="java-diamon"></p>
<p>首先理一下思路，先看打印实心菱形，菱形可以看成是两个大小小正三角形，已中间的对角线为分割线来看，实例来说加入一个菱形总共有7行，那么可以看成是上部分是4行的正三角形，下部分是3行的正三角形，<br>那么也就是我们可以分开来打印。</p>
<a id="more"></a>
<p>先打印上部分，第一行3个空格，1个*号，第二行2个空格，3个*号，第三行1个空格，5个*号，，先打印第一行，利用for循环打印，先打印空格，再打印*号<br>ok,再找规律</p>
<table>
<thead>
<tr>
<th>假设总共有4行</th>
<th style="text-align:left">第1行</th>
<th style="text-align:left">第2行</th>
<th style="text-align:left">第3行</th>
<th style="text-align:left">第4行</th>
<th style="text-align:left">….</th>
<th style="text-align:left">第n-1行</th>
<th style="text-align:center">第n行</th>
</tr>
</thead>
<tbody>
<tr>
<td>空格数</td>
<td style="text-align:left">3</td>
<td style="text-align:left">2</td>
<td style="text-align:left">1</td>
<td style="text-align:left">0</td>
<td style="text-align:left">….</td>
<td style="text-align:left">n-(n-1)</td>
<td style="text-align:center">n-n</td>
</tr>
<tr>
<td>*数量</td>
<td style="text-align:left">1</td>
<td style="text-align:left">3</td>
<td style="text-align:left">5</td>
<td style="text-align:left">7</td>
<td style="text-align:left">….</td>
<td style="text-align:left">((n-1)*2)-1</td>
<td style="text-align:center">(n*2)-1</td>
</tr>
</tbody>
</table>
<p>下部分则和上部分反过来看,道理是一样的<br>空心菱形则是则需要添加些if的判断语句，当在打印*号时，当此时位置属于边界时，打印*号，否则打印空格<br>代码如下:</p>
<pre><code>package com.cgtext.diamon;

import java.util.Scanner;

public class DiamonDemo {
    public static void main(String [] args){
        DrawShape drawShape = new DrawShape();
        while (true) {
            int c = drawShape.readChoice();
            if(c == 1){
                drawShape.drawShi(drawShape.readRows());
            }else if(c == 2){
                drawShape.drawKong(drawShape.readRows());
            }else if(c == 0){
                System.exit(0);
            }else{
                System.out.println(&quot;请输入可选序号0~2&quot;);
            }
        }
    }
}

class DrawShape{
    Scanner scanner = new Scanner(System.in);
    public int readChoice(){
        System.out.print(&quot;请输入所打印的形状的序号(1.打印实心菱形；2.打印空心菱形；0.退出)：&quot;);
        int c = scanner.nextInt();
        return c;
    }
    public int readRows(){
        System.out.println(&quot;请输入上部分行数：&quot;);
        int n = scanner.nextInt();
        return n;
    }
    public void drawShi(int n){
        for(int i = 1;i &lt;= n;i++){                      //假设上部分有n行
            for(int x = n-i;x &gt; 0;x--){              //打印空格数，随着行数的增加，空格数减少
                    System.out.print(&quot; &quot;);
//                    sleep(300);      //调用后面定义的sleep(int n)方法,每运行一句输出语句休息300毫秒，只不过现在注销了
            }
            for(int y = 1;y &lt;= (2*i)-1;y++){         //打印*号，随着行数增加，以(2*n)-1的规律增加
                    System.out.print(&quot;*&quot;);
//                    sleep(300);
            }
            System.out.println();
        }
        for(int i = 1;i &lt; n;i++){
            for(int x = 1;x&lt;= n-(n-i);x++){           //第1行有一个空格，最后那行空格数为n-(n-i)
                System.out.print(&quot; &quot;);
//                sleep(300);
            }
            for(int y = (n-i)*2-1;y &gt; 0;y--){          //第1行有(n-i)*2-1个*号，最后一行有1个*号
                System.out.print(&quot;*&quot;);
//                sleep(300);
            }
            System.out.println();
        }
    }
    public void drawKong(int n){
        for (int i = 1; i &lt;= n; i++) {
            for(int x = n-i;x &gt; 0;x--){
                System.out.print(&quot; &quot;);
//                sleep(300);
            }
            for(int y = 1;y &lt;= (2*i)-1;y++){
                if(y == 1 || y == (2*i)-1){
                    System.out.print(&quot;*&quot;);
//                    sleep(300);
                }else{
                    System.out.print(&quot; &quot;);
//                    sleep(300);
                }
            }
            System.out.println();
        }
        for(int i = 1;i &lt; n;i++){
            for(int x = 1;x &lt;= n-(n-i);x++){
                System.out.print(&quot; &quot;);
            }
            for(int y = (n-i)*2-1;y &gt; 0;y--){
                if(y == ((n-i)*2-1) || y == 1){
                    System.out.print(&quot;*&quot;);
//                    sleep(300);
                }else{
                    System.out.print(&quot; &quot;);
//                    sleep(300);
                }
            }
            System.out.println();
        }
    }
    public void sleep(int n){
        try {
            Thread.sleep(n);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
</code></pre>]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> codeing </tag>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[好好奋斗吧]]></title>
      <url>/2017/01/19/daily/2017-1-19-daily-dream/</url>
      <content type="html"><![CDATA[<p>记得外婆之前说过,人一辈子就像花一样,花开一瞬间,花落一瞬间</p>
<p>时间过得很快,马上就过年了,马上明天就是我第二十一个生日了(这段留给自己:文章显示的时间是撰写时间的前一天,今天是1月19号,所以文章显示的时间是1月18号,这貌似是现在jekyll版本的一个bug)…</p>
<a id="more"></a>
<p>想想自己现在还是一无所有……</p>
<p>昨天在外婆家里,和外婆聊了许多,孤单的人心灵总是脆弱的,外婆说着说着就会流泪,我也忘记了这是第几次,只要坐下来陪外婆聊天,外婆就会流泪</p>
<p>外婆住着老房子,一个人特别孤单.</p>
<p>…….</p>
<p><img src="/images/daily/daily-dream-1.jpg" alt="daily-dream-1"></p>
<p>我有一个梦想,梦想追上外婆老去的速度,并有那么一天,我能在外面厦门有房有车,把爸妈和外婆接过去住,叫上哥哥和家人一起在那边旅游</p>
]]></content>
      
        <categories>
            
            <category> daily </category>
            
        </categories>
        
        
        <tags>
            
            <tag> daily </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[该出去了]]></title>
      <url>/2017/01/04/daily/2017-1-4-daily-one/</url>
      <content type="html"><![CDATA[<p>前天家里换房间,我换到爸妈之前住的房间</p>
<p>放假后,拖着行李箱回到家,发现该换到的房间里还都是爸妈的东西,我就跟妈说,还是把这东西都搬到你们自己的房间去,我之前的东西搬过来,不然这样就相当于没换房间一样.</p>
<p>收拾些东西后,发觉爸妈房间放不下这么多东西,我提议说放到其他房间去,反正也没人住,妈说不好,之后我无奈补了一句:那随便吧,反正我在家住的时间不长.<br>然后妈迎合的说了一句:就是嘛,你又不常在家住.</p>
<p>,,,,,,,,</p>
<a id="more"></a>
<p>这时我便恍然意识到:是哦,我又不经常在家.</p>
<p>然后便下楼不准备收拾行李了,妈妈发现我的情绪后,再从房间里收拾了一部分东西出去,还留下一些东西在房间里</p>
<p>现在20岁了,快毕业了,也是该在外面找个栖息地了</p>
<p><img src="/images/daily/d1.jpg" alt="daily-1"></p>
<p>有时,我又想,要是能把生活装进行李箱,该多好</p>
]]></content>
      
        <categories>
            
            <category> daily </category>
            
        </categories>
        
        
        <tags>
            
            <tag> daily </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JavaEE-Spring的helloworld]]></title>
      <url>/2017/01/03/javaee/2017-1-3-javaEE-helloworld/</url>
      <content type="html"><![CDATA[<p>使用Spring框架,编写一个HelloWorld小程序.要求可选择性输出中文\”大家好\”和英文\”Hello EveryOne\”,程序控制流程图如下图所示:</p>
<p><img src="/images/javaee/spring-helloworld.png" alt="spring-helloworld"></p>
<p>这里用文字描述下程序流程图的大概过程.利用一个接口,定义一个具有返回值的抽象方法,其接口有两个实现类HelloWorld和HelloChina,分别用来返回\”Hello Everybody\”和\”大家好\”信息,并通过Person类来接受信息.在程序的main方法中,先读取xml配置文件,通过xml配置文件中代码来控制程序具体由那个实现类来返回信息,之后再调用Person类来进行输出所返回的信息.</p>
<a id="more"></a>
<p>在Eclipse中创建工程之后,需要先搭建Spring框架.在<a href="http://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/#overview-distribution-zip" target="_blank" rel="external">官网上下载Spring压缩包</a>.在工程中新建lib文件夹,将解压后的libs文件夹里的文件全部复制到工程的lib文件夹下(原本只需要4个jar文件:Spring.Core.jar,Spring.Beans.jar,Spring.AOP.jar和Spring.Context.jar),再将其都添加到Build Path路径中.</p>
<p>除此之外,将Spring工具包全添加进去之后,还需要另外下载<a href="http://commons.apache.org/proper/commons-logging/download_logging.cgi" target="_blank" rel="external">commons-logging-1.2-bin.zip</a>,解压后将其中的commons-logging-1.2.jar文件同样复制到工程的lib文件夹下,并添加到Build Path路径中.至此,环境才算搭建完成.即可开始创建Java文件了</p>
<p>在Eclipse中创建实例工程.在这里,我们在工程中逐个创建Java文件和xml配置文件:</p>
<ul>
<li>ShowhelloMessage:一个接口,用于定义输出问候信息</li>
<li>HelloWorld:接口的实现类,返回”Hello Everybody”信息</li>
<li>HelloChina:接口的实现类,返回”大家好”信息</li>
<li>Person:一个人物类,调用ShowhelloMessage接口,接受信息后向用户打印问候信息</li>
<li>spring-HelloWorld.xml:xml配置文件</li>
<li>SpringHelloWorld:程序的入口类,用户加载配置文件并启动IOC容器,调用人物类,向用户打印问候信息</li>
</ul>
<p>也就是说,需要创建5个Java文件,其通过配置文件来选择执行.降低了各个文件之间的耦合度,这就是使用Spring的好处</p>
<p>如下代码:</p>
<font color="#242424">ShowhelloMessage:</font>

<pre><code>package com.springhelloworld.action;

public interface ShowhelloMessage {

    public String showMessage();

}
</code></pre><font color="#242424">HelloWorld:</font>

<pre><code>package com.springhelloworld.action;

public class HelloWorld implements ShowhelloMessage {

    @Override
    public String showMessage() {
        return &quot;Hello Everybody&quot;;
    }
}
</code></pre><font color="#242424">HelloChina:</font>

<pre><code>package com.springhelloworld.action;

public class HelloChina implements ShowhelloMessage{

    @Override
    public String showMessage() {
        return &quot;大家好&quot;;
    }
}
</code></pre><font color="#242424">Person:</font>

<pre><code>package com.springhelloworld.action;

public class Person {

    private ShowhelloMessage showhelloMessage;

    public void setshowhelloMessage(ShowhelloMessage showhelloMessage){
        this.showhelloMessage = showhelloMessage;
    }

    public ShowhelloMessage getshowhelloMessage(){
        return showhelloMessage;
    }
    public String sayHello(){
        return this.showhelloMessage.showMessage();
    }
}
</code></pre><font color="#242424">spring-HelloWorld.xml:</font>

<pre><code>&lt;?xml version = &quot;1.0&quot; encoding = &quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE beans PUBLIC &quot;-//SPRING/DTD BEAN/EN&quot; &quot;http://    www.springframework.org/dtd/spring-beans.dtd&quot;&gt;
&lt;beans&gt;
    &lt;bean id = &quot;helloWorld&quot; class = &quot;com.springhelloworld.action.HelloWorld&quot;&gt;&lt;/bean&gt;
    &lt;bean id = &quot;helloChina&quot; class = &quot;com.springhelloworld.action.HelloChina&quot;&gt;&lt;/bean&gt;
    &lt;bean id = &quot;person&quot; class = &quot;com.springhelloworld.action.Person&quot;&gt;
        &lt;property name=&quot;showhelloMessage&quot; ref=&quot;helloWorld&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre><font color="#242424">SpringHelloWorld:</font>

<pre><code>package com.springhelloworld.main;

import org.springframework.beans.factory.BeanFactory;
import org.springframework.beans.factory.xml.XmlBeanFactory;
import org.springframework.core.io.FileSystemResource;
import org.springframework.core.io.Resource;

import com.springhelloworld.action.Person;

public class SpringHelloWorld {

    public static void main(String [] args){

        Resource resource = new FileSystemResource(&quot;spring-HelloWorld.xml&quot;);
        BeanFactory beanFactory = new XmlBeanFactory(resource);
        Person person = (Person)beanFactory.getBean(&quot;person&quot;);
        String str = person.sayHello();

        System.out.println(&quot;The person is currently saying &quot; + str);
    }
}
</code></pre><p>Output:</p>
<p><font color="f08080">十二月 15, 2016 7:04:30 下午 org.springframework.beans.factory.xml.XmlBeanDefinitionReader loadBeanDefinitions<br>信息: Loading XML bean definitions from file [/home/cg/Work/JavaWork/Eclipse-161103-restudy/Spring-HelloWorld/spring-HelloWorld.xml]</font><br>The person is currently saying Hello Everybody</p>
<p>*</p>
<p>认真阅读上面的代码,可以看出此程序使用的依赖注入的方式是Setter注入方式.在Person类中为使用接口类ShowhelloMessage而编写了set和get方法.并在Person类中定义sayHello()方法来获取抽象类的实现类所返回的问候信息.</p>
<p>其次,在xml配置文件中:</p>
<p> <code>&lt;beans&gt;</code>标签类似html标签中的<code>&lt;body&gt;</code>标签,而<code>&lt;bean&gt;</code>是被包含在<code>&lt;beans&gt;</code>里面的子标签.每一个<code>&lt;bean&gt;</code>标签代表一个类,其中的id属性值用来区分各个类,并在class属性中指明类所在的包的路径.而<code>&lt;property&gt;</code>标签是为描述自己所在<code>&lt;bean&gt;</code>标签的属性值,name的属性值为Person类中声明的私有属性</p>
<p>ShowhelloMessage的对象showhelloMessage,ref属性则表示制定哪个类来返回问候信息,其值就是之前定义的<code>&lt;bean&gt;</code>标签的id值.上面代码中的<code>ref = &quot;helloWorld&quot;</code>则表示配置文件制定调用HelloWorld这个实现类来返回问候信息,所以程序的输出就为英文\”Hello Everybody\”,所以如果需要让程序输出\”大家好\”,则只需要修改ref的属性值改为\”helloChina\”即可</p>
<p>在程序的main方法中,代码:</p>
<p><code>Resource resource = new FileSystemResource(&quot;spring-HelloWorld.xml&quot;)</code></p>
<p>表示利用FileSystemResource来加载读取配置文件,并返回一个Resource类型的对象.其FileSystemResource这个类加载配置文件的路径是从工程的根目录开始,而这里的spring-HelloWorld.xml文件就存放在工程的根目录下,所以名字就是路径名</p>
<p>代码<code>BeanFactory beanFactory = new XmlBeanFactory(resource)</code>则是利用XmlBeanFactory来加载配置文件从而启动IOC容器,其参数就是FileSystemResource在加载配置文件时所返回的Resource类型的对象.此代码执行后将得到一个BeanFactory类型的对象,利用此对象使用BeanFactory类中的getBean(String beanID)方法从IOC容器中获取所需要的bean所指向的类的对象,就如同下一行代码:</p>
<p><code>Person person = (Person)beanFactory.getBean(&quot;person&quot;)</code> </p>
<p>指从IOC容器中获取Person类的实例,这里使用了类型的强制转换</p>
]]></content>
      
        <categories>
            
            <category> javaEE </category>
            
        </categories>
        
        
        <tags>
            
            <tag> codeing </tag>
            
            <tag> javaEE </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JavaEE-Spring概况]]></title>
      <url>/2017/01/03/javaee/2017-1-3-javaEE-spring-introduce/</url>
      <content type="html"><![CDATA[<p>Spring是一个轻量级控制反转(IOC)和面向切面(AOP)的容器框架,它主要是为了解决企业应用开发的复杂性而诞生的.Spring提供一个简易的开发方式,这种开发方式将避免那些可能致使底层代码变得繁杂混乱的大量的属性文件和帮助类.</p>
<p>#####其关键特性如下:</p>
<ul>
<li>强大的基于JavaBean的采用控制反转(Inversion of Control,IOC)原则的配置管理,使得应用程序的组建更加快捷简易</li>
<li>一个可用于从Applet到Java EE等不同运行环境的核心Bean工厂</li>
<li>以资源管理器,DAO实现和事务策略等形式与Hibernate,JDO和iBATIS SQL Maps集成.</li>
<li>数据库事务的一般化抽象层,允许声明事务管理器,简化事务的划分使之与底层无关</li>
<li>提供诸如事务管理等服务的面向切面编程框架</li>
</ul>
<a id="more"></a>
<ul>
<li>JDBC抽象层提供了有针对性的异常等级(不再从SQL异常中提取原始代码),简化了错误处理,极大程度的减少了程序员的编码量</li>
</ul>
<p>Spring框架是一个轻量级的Java开发框架.框架的主要优势之一就是其灵活的分层架构,同事为J2EE应用程序开发提供集成的框架.Spring使用基本的JavaBean来完成以前只可能由EJB完成的事情.然而,Spring的用途不仅局限于服务器端的开发,任何Java应用都可以从Spring的简单,可测试和松耦合等特征中受益.<br>目的:是为了解决JavaEE在企业应用开发中的复杂性<br>功能:使用基本的JavaBean代替EJB<br>范围:任何Java应用</p>
<h5 id="Spring特点"><a href="#Spring特点" class="headerlink" title="Spring特点:"></a>Spring特点:</h5><ul>
<li>轻量:Spring的开销是非常小的,而且是非侵入式的,也就是说基于Spring开发的系统中的对象一般不依赖于Spring</li>
<li>控制反转:Spring提倡使用控制反转(IOC)来实现耦合.当需要某个类的对象时,被动地从Spring的容器中得到,而不是通过new来实例化对象</li>
<li>面向切面:将业务逻辑从系统服务(如事务和日志)中分离出来,系统对象只需要做它们该做的事,即业务逻辑,而不需要关心其他的问题</li>
<li>容器:Spring是一个容器,它包含并管理系统对象的生命周期和配置</li>
<li>框架:Spring可以使用简单的组件配置组合出复杂的应用.在Spring中,系统对象是通过xml文件配置组合起来的.并且Spring提供了很多基础设施(事务处理,持久层集成等),让开发者专注于业务逻辑的开发</li>
</ul>
<h5 id="Spring框架结构"><a href="#Spring框架结构" class="headerlink" title="Spring框架结构:"></a>Spring框架结构:</h5><p>Spring框架由7个模块组成,如下图所示:</p>
<p><img src="/images/javaee/spring-jiagou.png" alt="spring-jiagou"></p>
<p>从整体上看,这7个模块提供了企业级开发应用系统所需要的一切,但是不一定所有模块都必须使用,开发者可以自由选择所需要的模块</p>
<font color="#242424">Spring之IOC:</font>

<p>IOC(Inversion of Control,控制反转)是spring的核心,贯穿始终.所谓IOC,对于spring框架来说,就是有spring来负责控制对象的生命周期和对象间的关系.在IOC开发模式中,IOC容器来安排对象之前的依赖,而在传统的开发模式中,类的对象之间都是属于相互依赖的<br>IOC的另外的名字叫做依赖注入(Dependency Injection),所谓的依赖注入,就是由IOC容器在运行期间,动态的将某种依赖关系注入到对象之中.所以,依赖注入(DI)和控制反转(IOC)是从不同的角度来描述同一件事情,就是指通过引入IOC容器,利用依赖关系注入的方式,实现对象之间的解耦.</p>
<h5 id="IOC的好处"><a href="#IOC的好处" class="headerlink" title="IOC的好处:"></a>IOC的好处:</h5><ul>
<li>IOC在编程过程中不会对业务对象构成很强的侵入性,使用IOC之后,对象具有更好的可实行性,可重用性和可扩展性</li>
<li>降低组件之间的耦合度</li>
<li>提高开发效率和产品质量</li>
<li>统一标准,提高模块的复用性</li>
<li>模块具有热插拔特性</li>
</ul>
<h5 id="IOC通俗的理解如下"><a href="#IOC通俗的理解如下" class="headerlink" title="IOC通俗的理解如下:"></a>IOC通俗的理解如下:</h5><p>IOC控制反转:说的是创建对象实例的控制权从代码控制剥离到IOC容器控制,实际上就是你在xml文件控制,侧重于原理<br>DI依赖注入:说的就是在创建对象实例时,为这个对象注入属性值或其他对象实例,侧重于实现类型<br>依赖注入有3种实现,入下所列.Spring支持后面两种:</p>
<ol>
<li><p>接口注入</p>
</li>
<li><p>构造函数注入</p>
</li>
<li><p>Setter注入</p>
</li>
</ol>
<font color="#242424">Spring之AOP</font>

<h5 id="AOP的基本概念"><a href="#AOP的基本概念" class="headerlink" title="AOP的基本概念:"></a>AOP的基本概念:</h5><p>是一种面向切面的编程思想<br>AOP专门用于处理系统中分布于各个模块中的交叉关注点的问题,在Java EE应用中,常常通过AOP来处理一些具有横切性质的系统级服务,如事务管理,安全检查,缓存,对象池管理等,AOP已经成为一种非常常用的解决方案<br>AOP是对OOP(面向对象)的一种有益的补充,同事AOP是OOP的延续<br>OOP面向静态的领域<br>AOP面向动态的领域<br>那么为什么要用到AOP呢,—–因为由于系统会有很多不同的组件,每一个组件负责一块特定的功能,然而,我们需要每一个组件只关心它的自身核心功能,但在系统中,会有一些组件比如日志模块,事务管理模块和安全模块等等这些组件,会比较频繁的融入到其他的核心业务逻辑组件当中去,这些常用组件会分散到其他多个组件当中,这样会带来的麻烦是,如果这些常用的服务组件经常发生变化,那么我们需要在多个组件中去修改,这些组件因为插入了于自身业务无关的代码而变得很混乱<br>AOP代理其实是有AOP框架动态生成的一个对象,该对象可作为目标对象使用</p>
<h5 id="AOP通俗的理解"><a href="#AOP通俗的理解" class="headerlink" title="AOP通俗的理解:"></a>AOP通俗的理解:</h5><p>一个组件A,不关心其他常用的服务组件B,但是这个组件A使用组件B的时候,不是组件A自身去调用,而是通过配置等其他方式,比如Spring中可以通过xml配置文件.这样就使得A压根就不需要知道服务组件B是怎样的,爱存在不存在,爱怎么存在都于A无关,A只关心自己的业务逻辑,具体A使用B的时候,配置文件去做,于具体的A组件无关<br>在了解理论之后,还是需要赶紧去实践下,例如:<a href="https://cgstudios.github.io/javaee/2017/01/02/javaEE-helloworld.html" target="_blank" rel="external">基于Spring的HelloWorld</a>毕竟高手们的技能永远是强大的学习能力+饱满的热情与积极性+没有拖延的实践精神+拓展的知识面与技能树+解决问的方法论</p>
]]></content>
      
        <categories>
            
            <category> javaEE </category>
            
        </categories>
        
        
        <tags>
            
            <tag> codeing </tag>
            
            <tag> javaEE </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python复制并重命名文件图片]]></title>
      <url>/2016/12/31/python/2016-12-31-python-renamepic/</url>
      <content type="html"><![CDATA[<p>昨天用python写了一个小程序,用于复制并重命名电脑上所截屏存留的图片,linux系统的截屏多了,该文件夹打开速度也就不那么快了,而且linux截屏默认的图片命名格式很长,不方便用于上传到百度云,便写了个这个小脚本.</p>
<p>先不说别的,直接上的代码:</p>
<a id="more"></a>
<pre><code>import os
import sys

#author:cg错过   2016-12-30

def main():

    #用于拷贝.py格式的文件到新的文件夹,并重命名

    copyFile(reFileName())


def reFileName():
    #获取现在文件下的文件夹内的文件名,并返回
    #例如现在本文件存放在tt文件夹内,则此方法是获取tt文件夹内的所有文件的文件名(不包含文件夹),
    index = 0
    filePath = os.getcwd()
    fileList = os.listdir(filePath)
    fileNameList = []

    for fileElement in fileList:
        addFilePath = os.path.join(filePath, fileElement)
        if os.path.isdir(addFilePath):
            continue

        fileType = os.path.splitext(fileElement)[1]

        if fileType == &apos;.png&apos;:

            fileNameList.insert(index,fileElement)
            index += 1

    print(fileNameList)
    return fileNameList


def copyFile(fileNameList):

    #依照上一个方法的例子来说明
    #在tt文件夹下新建一个名为newFloder的文件夹
    #复制文件夹下的所有文件到tt文件夹下的newFolder文件夹下,并重命名

    count = 0

    filePath = os.getcwd()

     if not os.path.exists(&apos;newFolder&apos;):
        print(&quot;Create new folder, name is newFolder&quot;)
        os.mkdir(&apos;newFolder&apos;)

     else:
        print(&quot;Folder is exist,please rename a new folder&quot;)
        sys.exit()


    for fileElement in fileNameList:

    newFileName = str(count) + &apos;.py&apos;
    fileObj = open(str(fileElement), &apos;rb&apos;)

    fileObjContent = fileObj.read()        
    os.chdir(&apos;newFolder&apos;)

    newFileObj = open(newFileName, &apos;wb&apos;)
    newFileObj.write(fileObjContent)
    os.chdir(filePath)

    fileObj.close()
    newFileObj.close()

    count += 1

    print(&quot;done&quot;)


if __name__ == &apos;__main__&apos;:
    main()
</code></pre><p>效果图:</p>
<p><img src="/images/python/python-rename-1.png" alt="python-renamefile"></p>
<p>图中的Pictures文件夹就是存放截屏图片的,而newFloder-16-12-30文件夹是我手动重命名后的</p>
<p>首先先说一下这个脚本的大致实现方式:</p>
<p>方法reFileName():<br>用于获取存放截屏图片的文件夹下的所有文件名,文件夹除外,获取文件名后并作为列表方式返回.方法copyFile(list)方法其参数是一个列表,将文件名列表作为参数传入方法,并使用二进制的读写方式来获取或写入图片二进制内容.后缀名为.png.使用时直接将此脚本复制张贴到存放截屏图片的文件夹下,然后运行即可.</p>
<p>运行后脚本都将在先目录下新建一个名为”newFolder”的文件夹,并将重命名后的文件复制到此文件夹下</p>
<p>提前说明下,这个线程的脚本只是用来复制.png格式的图片,如要复制重命名其他格式文件,则需要更改代码中的<code>.png</code>这个代码即可</p>
]]></content>
      
        <categories>
            
            <category> python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> codeing </tag>
            
            <tag> python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Jekyll生成bolg文件及运作过程了解]]></title>
      <url>/2016/12/29/jekyll/2016-12-29-jekyll-file/</url>
      <content type="html"><![CDATA[<p>最近两天都在折腾博客,网上了解到有Jekyll配合Github搭建博客,也有Hexo配合Gihub来搭建博客的,当然也有其他的,我也没有去了解.此前一直单独用Github来放置个人主页,这很做法简单,但是很古板单一,工作量也大,库里面只能存放已做好的html静态页面,导致每次写博文都得重新写一张网页,填写url然后上传,这就使得过程很繁琐,而且如果没使用第三方框架来写的话,实现的效果也不大理想,交互性不强.</p>
<p>这里放个我以前那个单用github来存放的个人主页链接:<a href="https://cgwh.github.io" target="_blank" rel="external">https://cgwh.github.io</a>,网页实现很简单,没有使用任何第三方框架.个人水平也不高,导致体验性很差.所以现在不打算再更新那个主页了,着手将博文写在这</p>
<a id="more"></a>
<p>我现在是用Jekyll配合Github来实现本站的,所以这里所写的都是个人对Jekyll+Github配合使用时它们的运作过程的了解.不用Hexo的原因很简单,Hexo在我电脑上没搭建好,系统是linux mint17.3.没成功我也不知道原因.不过现在感觉Jekyll挺好的,维护博客也很方便,所以先用着</p>
<p>先了解一下Jekyll具体是干嘛用的,一开始我根本不知道这东西有什么作用.Github大家都知道是用来存放代码文件的,刚开始我在网上搜文章只知道用它配合gihub来搭建个人主页很方便,我也不知道方便在哪里,它怎么方便了,它怎么运作的,它的原理是什么,这些我都不知道.这就让人很迷了</p>
<p>所以我想阐述下我个人对Jekyll的理解</p>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述:"></a>概述:</h3><p>Jekyll的作用就是读取用户对网页所提前做的自定义样式及用户所写的博文内容后,综合起来并编译成html文件的插件</p>
<h4 id="详述"><a href="#详述" class="headerlink" title="详述:"></a>详述:</h4><p>首先,它是用来生成html文件的,只有生成了html文件后放在github上用浏览器浏览才能显示博客.那么,它是怎么生成html文件的呢。<br>我们都知道,一张网页被解析后显示的页面可以分为一个部分,两个部分或者三部分甚至更多,但可以通常的来说,就是三部分:头,身体和脚.</p>
<p>想想我们人不也可以看成这三部分么,当然,你也可以看成说是一部分,就是一个人.每个人的看法都不一样.但在这里,如果将网页分为三部分,那么有个好处就是可以增强代码的复用性,使得代码不会显得那么沉余.这就让我想到了Java中三大特性:封装,集成和多态</p>
<p>同样,若将网页分为三部分:头部,脚部和中间部分,那么我们就可以将这三部分的代码分别封装起来,并定义其中的样式.这样的话,如果以后需要创建一个新的html网页,那么就可以引用其封装起来的头部,脚部,,,我们只需要更改其中间部分即可,这样就很方便了.当然,这里的引用过程是不需要我们手动操作的,这都交给Jekll来操作,我们要做的只是去定义网页的头部,脚部以及中间部分,并封装起来，所以现在来说,我们只需要做这些,就可以完成博客的建立么,答案是否定的。要是真这样的话,那我们所搭建的博客样式不都差不多么,这样就毫无个性可言了<br>要避免这个问题,我们还需要对自己的网页进行自定义.自定义包括css样式的自定义及html组件布局的自定义.想想,要是我们的博客的每一个页面的中间部分都一样,这就没什么新鲜了.就拿比方说,博客的首页和博客的about页面,以及博文的阅读页面,它们的布局是一样好,还是不一样好,,,,<br>所以说,革命尚未结束,同志们仍需努力<br>我们下一步就是要制作网页的布局,说明白一点,就是获取缩写的博文内容及信息后,该怎么放在网页中,在网页中怎么显示,,,等</p>
<p>完成网页的制作,若实现网页的浏览(针对url来说),这个问题并不大。网页的url地址是html的存放位置来定的,而jekyll编译得到的html文件的存放地址则是根据用户自己编写的markdown格式的博文来定的,也就是说,markdown格式的文件可以用来制定jekyll所编译生成的html文件的存放地址,在jekyll中,markdown格式的文件的书写和命名都有规定,jekyll就是获取markdown的信息来生成在制定目录,这样也就实现了网页url的定义了。所以,总的来说,要实现一个博客站点,需要我们自己定义博客的页面信息,样式,以及编写出配合博客信息的markdown文件,然后在交给jekyll让它来帮我们编译出一组完整的博客组成文件<br>关于搭建Jekyll+Github的教程这里就先不写,过程很简单,网上找几篇文章再配合Jekyll官方文档来,很快就可以实现</p>
<p>搭建好Jekyll+Github环境之后</p>
<h3 id="本地建博"><a href="#本地建博" class="headerlink" title="本地建博"></a>本地建博</h3><p>在本地新建一个文件夹,用来存放自己本地的博客，然后在该文件夹下运行命令<br><code>jekyll new xxx</code><br>其中xxx填写自己站点的名字,作为测试,随意填写,之后进入xxx文件夹,在该文件夹下我们可以看到jekyll在运行上面这条命令后为我们生成的文件及文件夹<br>如图</p>
<p><img src="/images/jekyll/jekyll-1.png" alt="jekyll生成文件"></p>
<p>看到图片中显示的文件夹及文件信息,可以说是很悲哀,但也在情理之中.jekyll只为我们生成了这么些文件.<br>为完成本地博客的建立,我们在xxx目录文件夹下再运行命令:<br><code>jekyll serve</code><br>完成之后,在浏览器地址栏中输入<br><code>http://127.0.0.1:4000</code><br>便可查看到我们在本地搭建的博客网页了,如果输入url后不显示网页,那么就说明jekyll环境搭建好,那就需要重新搭建了<br>本地博客网页如图</p>
<p><img src="/images/jekyll/jekyll-2.png" alt="jekyll建站页面"></p>
<p>会发现图片中显示的站点图标跟我现在博客站点的图标一样,,,,,,这我也不懂了,估计这是被我这是我此博客在电脑上的备份文件影响的,也或许这是全局设置,这个到时候再琢磨琢磨.之后,我们再查看下xxx文件夹下的文件信息<br>如图</p>
<p><img src="/images/jekyll/jekyll-3.png" alt="jekyll建站后生成文件"></p>
<p>比较前面的图,会发现多了个_site文件夹,所以也就是说,_site文件夹是jekyll编译后生成的文件夹,接触官方文档后就会知道,这个文件夹就是存放jekyll编译整个站点文件后得到的文件看着jekyll自动生成的文件,一开始的我根本看不懂,根本不知道这写文件的作用,甚至看来官方给的目录结构说明后也不是很明白.后来就去查看别人的主题文件,读里面的代码,才知道一个博客的文件关系<br>所以,要是你一开始就对jekyll默认生成的文件表示疑惑时,建议去下载别人的主题,并阅读它,多读代码,很容易就会明白的<br>例如我们下载一个主题,解压后进入目录,就比如下面图片中的</p>
<p><img src="/images/jekyll/jekyll-file-4.png" alt="jekyll主题文件"></p>
<h4 id="文件简述"><a href="#文件简述" class="headerlink" title="文件简述"></a>文件简述</h4><ul>
<li>css文件夹: 存放css样式</li>
<li>images: 存放站点所需要用到的图片</li>
<li>_includes: 存放网页组成部分,例如头部分—head.html</li>
<li>_layouts: 存放网页html布局文件</li>
<li>_posts: 用户存放博文</li>
<li>_sass: 存放scss样式</li>
<li>scripts: 存放javascript脚本</li>
<li>_site: 存放网站编译后的文件,以上文件编译后都将存放此文件夹中</li>
<li>about.md: about页面</li>
<li>archive.html: 看文件名字,估计是用来显示全部博文的html布局页面</li>
<li>catgory.html: 看文件名字,估计是用来分类显示全部博文的html布局页面</li>
<li>_config.yml: jekyll的配置文件</li>
<li>feed.xml: jekyll的配置文件</li>
<li>index.md: 站点首页,html布局页面</li>
<li>README.md: 介绍此主题,存放至github后会被读取先死在仓库下方</li>
</ul>
<h3 id="文件组成"><a href="#文件组成" class="headerlink" title="文件组成"></a>文件组成</h3><h4 id="includes文件夹下"><a href="#includes文件夹下" class="headerlink" title="_includes文件夹下"></a>_includes文件夹下</h4><p>先看_includes文件夹内的文件,该文件夹下有三个组成文件</p>
<ul>
<li>head.html</li>
<li>header.html</li>
<li>footer.html</li>
</ul>
<p>打开head.html,如下图</p>
<p><img src="/images/jekyll/jekyll-head-5.png" alt="head.html"></p>
<p>看到图中,代码很简单,html标签这里就不解释了,简单都懂<br>看到title标签中出现<br><code>if page.title..</code><br>这行代码(有些字符打出来会出错,所以没打全),其中,<code>page.title</code>是用来获取当前页面的title信息的,这里的当前页面是指每个页面中的title属性,毕竟每个页面都得有head标签,<code>site.title</code>则为获取站点的title属性,也可理解为index.html首页面的title属性,下面一张表列出了jekyll的变量信息.</p>
<table>
<thead>
<tr>
<th>变量</th>
<th style="text-align:left">描述</th>
<th style="text-align:center">例如</th>
</tr>
</thead>
<tbody>
<tr>
<td>site</td>
<td style="text-align:left">类似全局变量,获取全局方位的信息</td>
<td style="text-align:center">site.pages:获取该站点所有被page.html所承载的页面</td>
</tr>
<tr>
<td>page</td>
<td style="text-align:left">只能获取当前页面的信息</td>
<td style="text-align:center">page.title:博文的日期</td>
</tr>
<tr>
<td>content</td>
<td style="text-align:left">页面的主要部分的内容</td>
<td style="text-align:center">content:博文的内容</td>
</tr>
<tr>
<td>paginator</td>
<td style="text-align:left">用来执行分页操作</td>
<td style="text-align:center">paginate=5:每页达到5栏变自动分页</td>
</tr>
</tbody>
</table>
<p>那么,回到上面那行代码,可以知道,这是一条if的条件循环语句,大概的意思是,如果这个head标签加载到的是普通页面则显示该普通页面的标题,反之,则显示站点的标题.所以,head.html这个组成页面可以看成是一张完整网页中的一个head标签<br>其他的页面也是如此,header.html页面就是完整网页的一个导航栏,footer.html则是完整网页的根部,所以其内容也很简单</p>
<p><img src="/images/jekyll/jekyll-footer-6.png" alt="footer.html"></p>
<h4 id="layouts文件夹"><a href="#layouts文件夹" class="headerlink" title="_layouts文件夹"></a>_layouts文件夹</h4><p>之后再来看_layouts文件夹下的html布局文件</p>
<ul>
<li>default.html</li>
<li>page.html</li>
<li>post.html<br>按照经验,default.html是最基础的布局文件,page.html和post都将集成于default.html<br>page.html一般是用来承载站点主页和about页面,按照这个主题,about.md,archive.html和catgory.html以及index.html都将使用此布局<br>而post.html一般用来承载博文<br>了解了这个,我们再来依次查看这些文件</li>
</ul>
<h5 id="default-html"><a href="#default-html" class="headerlink" title="default.html"></a>default.html</h5><p><img src="/images/jekyll/jekyll-default-7.png" alt="default.html"></p>
<p>可以看到,default.html这个文件包含有html5网页的声明<br><code>&lt;!DOCTYPE html&gt;</code><br>所以,这个页面的作用就是给post.html和page.html这两个布局文件一个框架,这样一来,post.html和page.html将遵循default.html的布局格式,其所谓的遵循,就是将自身嵌套进入default.html页面中<br>其嵌套的位置就是在default.html的<br><code>content</code><br>里,并结合上面的表,<code>content</code>所代表的就是被嵌套进default.html页面的其他页面的内容</p>
<h5 id="page-html"><a href="#page-html" class="headerlink" title="page.html"></a>page.html</h5><p><img src="/images/jekyll/jekyll-page-8.png" alt="page.html"></p>
<p>page.html在代码的开头,定义了<br><code>layout: default</code><br>那么,整个page.html就将被赋值给default.html页面中的<code>content</code>将被赋值给default.html，以此来完成嵌套。这以上所说的都是我个人对jekyll的运作过程的琢磨,为验证这个嵌套这一点,我们可以查看已编译好的网页的源代码来证明<br>同样是此主题,在本地运行起来,首先,我们知道该站点的主页index.html是承载于default.html这个布局文件的,如下图:</p>
<p><img src="/images/jekyll/jekyll-index-9.png" alt="index.html"></p>
<p>既然index.html承载在default.html中,那么index.html的内容将被赋值给default.html中的<br><code>content</code><br>所以也就是说,网页在编译成_site文件夹中的一张index.html的完整网页后,上面图片中类名为’home’的div将出现在default.html中类名为’wrapper’的下面,或者说是里面.那么我们打开浏览器,打开本地博客的站点,查看首页index.html的源代码,查找后,如下图</p>
<p><img src="/images/jekyll/jekyll-10.png" alt="test-index.html"></p>
<p>很显然,这样的嵌套是对的。所以,总的来说,jekyll生成的博客就是利用不同的嵌套,以及组成网页,将其整合起来生成网页,根据头信息(官方文档称为YAML信息)来生成url信息。想想一开始我对jekyll丝毫不了解,不懂它是干什么的,不懂它是怎么运作的.不懂为什么这么多人使用它,而不是自己老老实实的写自己的代码,实现自己想要达到的目标.甚至比如那些框架,起初我是很反对接触那些框架的.不懂为什么作为一个常跟代码打交道的程序员,为什么要使用别人的代码,就不能自己做自己实现么,现在想想也很可笑.编程是一个会跟随时代的,现在的编程不同于过去的编程,以后的编程也必定不同于现在的编程.使用前人的代码来更便捷的实现自己的目的没有错,错就错在你不去学习使用别人的代码,学习别人的编码思路,一味的做自己代码而不吸收前辈的经验,是很难成长的,也必将被淘汰</p>
<p>好了,大概先就这样了,剩下的时间交给你,请多多指教.</p>
]]></content>
      
        <categories>
            
            <category> jekyll </category>
            
        </categories>
        
        
        <tags>
            
            <tag> jekyll </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java三元操作符]]></title>
      <url>/2016/12/28/java/2016-12-28-java-TernaryOperator/</url>
      <content type="html"><![CDATA[<p>三元操作符也称为条件操作符,它显得比较独特,因为它有三个操作数;但它确实属于操作符的一种,因为它最终也会生成一个值.其表达式采取的形式如下<br><code>boolean-exp ? value1 : value2</code><br>如果boolean-exp(布尔表达式)的结果为true,则表达式所产生的值就为value1,如果boolean-exp的结果为false,值就计算为value2. 当然,如果需要达成这中需求这也可以用普通的if-else语句,但if-else语句相对于三元操作符来说,if-else显得相对复杂,三元操作符则更为简洁.</p>
<a id="more"></a>
<p>C语言中也有三元操作符,作为古老的编程语言,三元操作符就是C发明出来的,C引以为傲的就是它是一种简练的语言,而且三元操作符的引入多半就是为了体现这种高效的编程,但假如你打算频繁的使用它,那还得三思而后行,因为三元操作符使用多了很容易产生可读性极差的代码.</p>
<p>如下代码:</p>
<pre><code>public class TernaryOperatorTest {

    public static void main(String [] args){

        System.out.println(standardMethod(9));

        System.out.println(ternaryMethod(10));

        System.out.println(standardMethod(9));

    }

    static int ternaryMethod(int i){

        return i &lt; 10 ? i * 100 : i * 10;

    }

    static int standardMethod(int i){

        if(i &lt; 10){

            return i * 100;

        }else{

            return i * 10;

        }

    }
}
</code></pre><p>Output:</p>
<p>900</p>
<p>100</p>
<p>900</p>
<p>通过上面的代码,可以看出,使用了三元操作符的方法ternarMethod()显得更紧凑,<br>方法块更简练<br>而使用了普通if-else语句的方法standardMethod()则更容易理解,而且不需要太多的录入.所以在选择使用三元操作符时,需要仔细考虑</p>
]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> codeing </tag>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Ubuntu15.10打开unity-tweak-tool出错scheme missing]]></title>
      <url>/2016/12/28/linux/2016-12-28-ubuntu-tweaktool-schememissing/</url>
      <content type="html"><![CDATA[<p>ubuntu15.10安装unity-tweak-tool后打不开显示scheme missing！并提示org.gnome.settings-daemon.peripherals.touchpad<br>百度后才得到解决方法：<br>命令cd到/usr/lib/python3/dist-packages/UnityTweakTool/section目录下<br>    命令：cd /usr/lib/python3/dist-packages/UnityTweakTool/section</p>
<a id="more"></a>
<p><img src="/images/linux/t1.png" alt="查看unitytweak配置文件"></p>
<p>如上图，修改system.py文件<br>    命令：gksu gedit system.py<br>找到行数为182,193,205，将这3行都修改成  ‘schema’ : ‘org.gnome.desktop.peripherals.touchpad’<br>之后在section目录下再cd 进如spaghetti文件夹，修改gsettings.py<br>    命令：gksu gedit gsettings.py<br>找到第120行，将其修改成  touch = gnome(‘desktop.peripherals.touchpad’)<br>保存退出<br>之后就可以运行unity-tweak-tool了</p>
]]></content>
      
        <categories>
            
            <category> linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ubuntu15.10修改默认登录器lightdm的登录界面背景图片]]></title>
      <url>/2016/12/27/linux/2016-12-27-ubuntu-loginlightdm-bgpic/</url>
      <content type="html"><![CDATA[<p>现在自己所用的系统是ubuntu15.10，其系统默认的显示管理器是lightdm，用它来登录ubuntu15.10的unity桌面环境。<br>对lightdm的登录界面没什么多大的好感，linux系统对于我来讲只要够稳定就行，用来工作就是要求稳定。</p>
<p>想要更改lightdm的背景图片,网上搜了下有好多方法，这里我介绍下我的方法(参照wiki得到的)</p>
<p>在文件夹/usr/share/glib-2.0/schemas下有很多关于lightdm的配置文件，修改此文件夹下的50_unity-greeter.gschema.override这个文件，这里注意下，不同型号的系统其配置文件的文件名也许会有差异，所以并不一定在你的linux系统下面的会有跟我这个文件名称相同的文件，废话不多说，打开就行了，<br>如下图:</p>
<a id="more"></a>
<p><img src="/images/linux/t1.png" alt="查看lightdm配置文件"></p>
<p>上面是我已经修改好了的样子(其实只要添加一条代码就可以了)<br>先来看看这几行代码<br>这里注意下这个文件里面开头的那个标签[com.canonical.unity-greeter]，也就是标明了是unity桌面环境的登录界面，<br>第一行代码:draw-user-backgrounds=false，这是我自己添加进去的唯一一条代码，也就是这个文件只需要修改这里。<br>这代码的作用是使lightdm的背景图片不会被切换，如果没这行代码，那么在你开机到出现登录界面时，会出现你自己定义的界面背景图片，但又会自动马上切换成桌面背景图片，不知道你们会不会遇到这种情况，方正我是遇到了。<br>第二行代码:,,,很显然，它是指明登录界面的背景图片的存放地址，这张名为warty-final-ubuntu.png的图片，就是ubuntu登录界面默认的背景图片，所以我们只需要拿自己准备的图片替换它就可以了。<br>在替换时，需要注意其原始图片的权限，</p>
<p><img src="/images/linux/t2.png" alt="结果"></p>
<p>上面依然是我已经替换好了的样子，<br>warty-final-ubuntu-old.png是默认的背景图片，warty-final-ubuntu.png是我自定义的图片，我们需要做的是将自定义的图片的权限修改成系统默认的背景图片的权限，<br>这里需要用到命令是chmod，<br>在此文件夹下运行命令:sudo chmod 644 warty-final-ubuntu.png</p>
<p>后面reboot就行了，</p>
<p>其实还有一个不完美的地方，每次开机lightdm显示的主题样式不是自己使用的主题样式，有时候自己该了下也能改变其样式，但不是预想的效果。嗯，这得自己好好琢磨琢磨</p>
<p>这里顺便贴下那篇wiki的地址:<a href="https://wiki.ubuntu.com/LightDM" target="_blank" rel="external">https://wiki.ubuntu.com/LightDM</a>   没事多看看wiki。<br>多说一句，arch wiki更值得去看</p>
]]></content>
      
        <categories>
            
            <category> linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[解决ubuntu15.10开机自动更改DNS服务器问题]]></title>
      <url>/2016/12/27/linux/2016-12-27-ubuntu-startup-dns/</url>
      <content type="html"><![CDATA[<p>我的系统是ubuntu15.10，由于dns服务器地址经常自动更改，不知道什么原因，但肯定不是network-manager的原因，因为在出问题之前network-manager也还在，那会儿dns服务器地址并没有因为其而自动更换。</p>
<p>了解:ubuntu系统的dns服务器地址的存放在/etc/resolv.conf文件中，每一次开机查看此文件可看到其地址都是127.0.1.1，</p>
<a id="more"></a>
<p>解决方法:修改/etc/resolvconf/resolv.conf.d/head 此文件，在里面添加:nameserver 202.114.0.131或者</p>
<p>nameserver 202.114.0.242，这两个地址是在电脑不使用锐捷客户端而是直接使用network-manager连接无线网络时得到的dns服务器地址。这里说一下resolv.conf.d这个文件夹里面的两个文件head和base,一开始在网络上查找到的方法是修改base这个文件，然而此方法对我没用，估计那会儿献此方法的人只有base这一个文件，而没有head这个文件，因此估摸这如果两个文件都有的人，就得像我一样修改head这个文件，反之，则修改base这个文件</p>
]]></content>
      
        <categories>
            
            <category> linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> linux </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
